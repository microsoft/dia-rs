#[repr(transparent)]
pub struct IDiaAddressMap(::windows::core::IUnknown);
impl IDiaAddressMap {
    pub unsafe fn addressMapEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressMapEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn SetaddressMapEnabled<'a, P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).SetaddressMapEnabled)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn relativeVirtualAddressEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).relativeVirtualAddressEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn SetrelativeVirtualAddressEnabled<'a, P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).SetrelativeVirtualAddressEnabled)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn imageAlign(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).imageAlign)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn SetimageAlign(&self, newval: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).SetimageAlign)(::windows::core::Vtable::as_raw(self), newval).ok()
    }
    pub unsafe fn set_imageHeaders<'a, P0>(&self, pbdata: &[u8], originalheaders: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).set_imageHeaders)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pbdata.as_ptr()), originalheaders.into()).ok()
    }
    pub unsafe fn set_addressMap<'a, P0>(&self, pdata: &[DiaAddressMapEntry], imagetosymbols: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).set_addressMap)(::windows::core::Vtable::as_raw(self), pdata.len() as _, ::core::mem::transmute(pdata.as_ptr()), imagetosymbols.into()).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaAddressMap, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaAddressMap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaAddressMap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaAddressMap {}
impl ::core::fmt::Debug for IDiaAddressMap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaAddressMap").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaAddressMap {
    type Vtable = IDiaAddressMap_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaAddressMap {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb62a2e7a_067a_4ea3_b598_04c09717502c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaAddressMap_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub addressMapEnabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub SetaddressMapEnabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, newval: ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub relativeVirtualAddressEnabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub SetrelativeVirtualAddressEnabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, newval: ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub imageAlign: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub SetimageAlign: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, newval: u32) -> ::windows::core::HRESULT,
    pub set_imageHeaders: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cbdata: u32, pbdata: *const u8, originalheaders: ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub set_addressMap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cdata: u32, pdata: *const DiaAddressMapEntry, imagetosymbols: ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaDataSource(::windows::core::IUnknown);
impl IDiaDataSource {
    pub unsafe fn lastError(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lastError)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn loadDataFromPdb<'a, P0>(&self, pdbpath: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        (::windows::core::Vtable::vtable(self).loadDataFromPdb)(::windows::core::Vtable::as_raw(self), pdbpath.into()).ok()
    }
    pub unsafe fn loadAndValidateDataFromPdb<'a, P0>(&self, pdbpath: P0, pcsig70: *const ::windows::core::GUID, sig: u32, age: u32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        (::windows::core::Vtable::vtable(self).loadAndValidateDataFromPdb)(::windows::core::Vtable::as_raw(self), pdbpath.into(), ::core::mem::transmute(pcsig70), sig, age).ok()
    }
    pub unsafe fn loadDataForExe<'a, P0, P1, P2>(&self, executable: P0, searchpath: P1, pcallback: P2) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
        P1: ::std::convert::Into<::windows::core::PCWSTR>,
        P2: ::std::convert::Into<::windows::core::InParam<'a, ::windows::core::IUnknown>>,
    {
        (::windows::core::Vtable::vtable(self).loadDataForExe)(::windows::core::Vtable::as_raw(self), executable.into(), searchpath.into(), pcallback.into().abi()).ok()
    }
    pub unsafe fn loadDataFromIStream<'a, P0>(&self, pistream: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, ::windows::Win32::System::Com::IStream>>,
    {
        (::windows::core::Vtable::vtable(self).loadDataFromIStream)(::windows::core::Vtable::as_raw(self), pistream.into().abi()).ok()
    }
    pub unsafe fn openSession(&self) -> ::windows::core::Result<IDiaSession> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).openSession)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSession>(result__)
    }
    pub unsafe fn loadDataFromCodeViewInfo<'a, P0, P1, P2>(&self, executable: P0, searchpath: P1, pbcvinfo: &[u8], pcallback: P2) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
        P1: ::std::convert::Into<::windows::core::PCWSTR>,
        P2: ::std::convert::Into<::windows::core::InParam<'a, ::windows::core::IUnknown>>,
    {
        (::windows::core::Vtable::vtable(self).loadDataFromCodeViewInfo)(::windows::core::Vtable::as_raw(self), executable.into(), searchpath.into(), pbcvinfo.len() as _, ::core::mem::transmute(pbcvinfo.as_ptr()), pcallback.into().abi()).ok()
    }
    pub unsafe fn loadDataFromMiscInfo<'a, P0, P1, P2>(&self, executable: P0, searchpath: P1, timestampexe: u32, timestampdbg: u32, sizeofexe: u32, pbmiscinfo: &[u8], pcallback: P2) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
        P1: ::std::convert::Into<::windows::core::PCWSTR>,
        P2: ::std::convert::Into<::windows::core::InParam<'a, ::windows::core::IUnknown>>,
    {
        (::windows::core::Vtable::vtable(self).loadDataFromMiscInfo)(::windows::core::Vtable::as_raw(self), executable.into(), searchpath.into(), timestampexe, timestampdbg, sizeofexe, pbmiscinfo.len() as _, ::core::mem::transmute(pbmiscinfo.as_ptr()), pcallback.into().abi()).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaDataSource, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaDataSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaDataSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaDataSource {}
impl ::core::fmt::Debug for IDiaDataSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaDataSource").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaDataSource {
    type Vtable = IDiaDataSource_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaDataSource {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x79f1bb5f_b66e_48e5_b6a9_1545c323ca3d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaDataSource_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub lastError: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub loadDataFromPdb: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdbpath: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub loadAndValidateDataFromPdb: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdbpath: ::windows::core::PCWSTR, pcsig70: *const ::windows::core::GUID, sig: u32, age: u32) -> ::windows::core::HRESULT,
    pub loadDataForExe: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, executable: ::windows::core::PCWSTR, searchpath: ::windows::core::PCWSTR, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub loadDataFromIStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pistream: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub openSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub loadDataFromCodeViewInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, executable: ::windows::core::PCWSTR, searchpath: ::windows::core::PCWSTR, cbcvinfo: u32, pbcvinfo: *const u8, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub loadDataFromMiscInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, executable: ::windows::core::PCWSTR, searchpath: ::windows::core::PCWSTR, timestampexe: u32, timestampdbg: u32, sizeofexe: u32, cbmiscinfo: u32, pbmiscinfo: *const u8, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumDebugStreamData(::windows::core::IUnknown);
impl IDiaEnumDebugStreamData {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn Item(&self, index: u32, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn Next(&self, celt: u32, pcbdata: *mut u32, pbdata: &mut [u8], pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr()), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumDebugStreamData> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumDebugStreamData>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumDebugStreamData, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumDebugStreamData {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumDebugStreamData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumDebugStreamData {}
impl ::core::fmt::Debug for IDiaEnumDebugStreamData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumDebugStreamData").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumDebugStreamData {
    type Vtable = IDiaEnumDebugStreamData_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumDebugStreamData {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x486943e8_d187_4a6b_a3c4_291259fff60d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumDebugStreamData_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub name: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumDebugStreams(::windows::core::IUnknown);
impl IDiaEnumDebugStreams {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item<'a, P0>(&self, index: P0) -> ::windows::core::Result<IDiaEnumDebugStreamData>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, ::windows::Win32::System::Com::VARIANT>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumDebugStreamData>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaEnumDebugStreamData>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumDebugStreams> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumDebugStreams>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumDebugStreams, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumDebugStreams {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumDebugStreams {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumDebugStreams {}
impl ::core::fmt::Debug for IDiaEnumDebugStreams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumDebugStreams").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumDebugStreams {
    type Vtable = IDiaEnumDebugStreams_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumDebugStreams {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x08cbb41e_47a6_4f87_92f1_1c9c87ced044);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumDebugStreams_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<::windows::Win32::System::Com::VARIANT>, stream: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumFrameData(::windows::core::IUnknown);
impl IDiaEnumFrameData {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item(&self, index: u32) -> ::windows::core::Result<IDiaFrameData> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaFrameData>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaFrameData>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumFrameData> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumFrameData>(result__)
    }
    pub unsafe fn frameByRVA(&self, relativevirtualaddress: u32) -> ::windows::core::Result<IDiaFrameData> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).frameByRVA)(::windows::core::Vtable::as_raw(self), relativevirtualaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaFrameData>(result__)
    }
    pub unsafe fn frameByVA(&self, virtualaddress: u64) -> ::windows::core::Result<IDiaFrameData> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).frameByVA)(::windows::core::Vtable::as_raw(self), virtualaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaFrameData>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumFrameData, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumFrameData {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumFrameData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumFrameData {}
impl ::core::fmt::Debug for IDiaEnumFrameData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumFrameData").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumFrameData {
    type Vtable = IDiaEnumFrameData_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumFrameData {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9fc77a4b_3c1c_44ed_a798_6c1deea53e1f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumFrameData_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, frame: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub frameByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, relativevirtualaddress: u32, frame: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub frameByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, virtualaddress: u64, frame: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumInjectedSources(::windows::core::IUnknown);
impl IDiaEnumInjectedSources {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item(&self, index: u32) -> ::windows::core::Result<IDiaInjectedSource> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInjectedSource>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaInjectedSource>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumInjectedSources> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumInjectedSources>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumInjectedSources, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumInjectedSources {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumInjectedSources {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumInjectedSources {}
impl ::core::fmt::Debug for IDiaEnumInjectedSources {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumInjectedSources").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumInjectedSources {
    type Vtable = IDiaEnumInjectedSources_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumInjectedSources {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd5612573_6925_4468_8883_98cdec8c384a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumInjectedSources_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, injectedsource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumInputAssemblyFiles(::windows::core::IUnknown);
impl IDiaEnumInputAssemblyFiles {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item(&self, index: u32) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaInputAssemblyFile>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumInputAssemblyFiles> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumInputAssemblyFiles>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumInputAssemblyFiles, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumInputAssemblyFiles {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumInputAssemblyFiles {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumInputAssemblyFiles {}
impl ::core::fmt::Debug for IDiaEnumInputAssemblyFiles {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumInputAssemblyFiles").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumInputAssemblyFiles {
    type Vtable = IDiaEnumInputAssemblyFiles_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumInputAssemblyFiles {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1c7ff653_51f7_457e_8419_b20f57ef7e4d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumInputAssemblyFiles_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, file: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumLineNumbers(::windows::core::IUnknown);
impl IDiaEnumLineNumbers {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item(&self, index: u32) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaLineNumber>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumLineNumbers, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumLineNumbers {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumLineNumbers {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumLineNumbers {}
impl ::core::fmt::Debug for IDiaEnumLineNumbers {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumLineNumbers").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumLineNumbers {
    type Vtable = IDiaEnumLineNumbers_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumLineNumbers {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfe30e878_54ac_44f1_81ba_39de940f6052);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumLineNumbers_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, linenumber: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumSectionContribs(::windows::core::IUnknown);
impl IDiaEnumSectionContribs {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item(&self, index: u32) -> ::windows::core::Result<IDiaSectionContrib> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSectionContrib>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSectionContrib>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumSectionContribs> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSectionContribs>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumSectionContribs, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumSectionContribs {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumSectionContribs {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumSectionContribs {}
impl ::core::fmt::Debug for IDiaEnumSectionContribs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumSectionContribs").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumSectionContribs {
    type Vtable = IDiaEnumSectionContribs_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumSectionContribs {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1994deb2_2c82_4b1d_a57f_aff424d54a68);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumSectionContribs_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, section: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumSegments(::windows::core::IUnknown);
impl IDiaEnumSegments {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item(&self, index: u32) -> ::windows::core::Result<IDiaSegment> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSegment>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSegment>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumSegments> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSegments>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumSegments, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumSegments {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumSegments {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumSegments {}
impl ::core::fmt::Debug for IDiaEnumSegments {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumSegments").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumSegments {
    type Vtable = IDiaEnumSegments_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumSegments {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe8368ca9_01d1_419d_ac0c_e31235dbda9f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumSegments_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, segment: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumSourceFiles(::windows::core::IUnknown);
impl IDiaEnumSourceFiles {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item(&self, index: u32) -> ::windows::core::Result<IDiaSourceFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSourceFile>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSourceFile>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumSourceFiles> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSourceFiles>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumSourceFiles, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumSourceFiles {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumSourceFiles {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumSourceFiles {}
impl ::core::fmt::Debug for IDiaEnumSourceFiles {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumSourceFiles").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumSourceFiles {
    type Vtable = IDiaEnumSourceFiles_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumSourceFiles {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x10f3dbd9_664f_4469_b808_9471c7a50538);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumSourceFiles_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, sourcefile: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumStackFrames(::windows::core::IUnknown);
impl IDiaEnumStackFrames {
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaStackFrame>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaEnumStackFrames, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumStackFrames {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumStackFrames {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumStackFrames {}
impl ::core::fmt::Debug for IDiaEnumStackFrames {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumStackFrames").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumStackFrames {
    type Vtable = IDiaEnumStackFrames_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumStackFrames {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xec9d461d_ce74_4711_a020_7d8f9a1dd255);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumStackFrames_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumSymbols(::windows::core::IUnknown);
impl IDiaEnumSymbols {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item(&self, index: u32) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumSymbols, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumSymbols {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumSymbols {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumSymbols {}
impl ::core::fmt::Debug for IDiaEnumSymbols {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumSymbols").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumSymbols {
    type Vtable = IDiaEnumSymbols_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumSymbols {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcab72c48_443b_48f5_9b0b_42f0820ab29a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumSymbols_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, symbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumSymbolsByAddr(::windows::core::IUnknown);
impl IDiaEnumSymbolsByAddr {
    pub unsafe fn symbolByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symbolByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn symbolByRVA(&self, relativevirtualaddress: u32) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symbolByRVA)(::windows::core::Vtable::as_raw(self), relativevirtualaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn symbolByVA(&self, virtualaddress: u64) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symbolByVA)(::windows::core::Vtable::as_raw(self), virtualaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Prev(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Prev)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumSymbolsByAddr> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbolsByAddr>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumSymbolsByAddr, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumSymbolsByAddr {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumSymbolsByAddr {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumSymbolsByAddr {}
impl ::core::fmt::Debug for IDiaEnumSymbolsByAddr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumSymbolsByAddr").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumSymbolsByAddr {
    type Vtable = IDiaEnumSymbolsByAddr_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumSymbolsByAddr {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x624b7d9c_24ea_4421_9d06_3b577471c1fa);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumSymbolsByAddr_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub symbolByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub symbolByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, relativevirtualaddress: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub symbolByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, virtualaddress: u64, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Prev: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumSymbolsByAddr2(::windows::core::IUnknown);
impl IDiaEnumSymbolsByAddr2 {
    pub unsafe fn symbolByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.symbolByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn symbolByRVA(&self, relativevirtualaddress: u32) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.symbolByRVA)(::windows::core::Vtable::as_raw(self), relativevirtualaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn symbolByVA(&self, virtualaddress: u64) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.symbolByVA)(::windows::core::Vtable::as_raw(self), virtualaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Prev(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Prev)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumSymbolsByAddr> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbolsByAddr>(result__)
    }
    pub unsafe fn symbolByAddrEx<'a, P0>(&self, fpromoteblocksym: P0, isect: u32, offset: u32) -> ::windows::core::Result<IDiaSymbol>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symbolByAddrEx)(::windows::core::Vtable::as_raw(self), fpromoteblocksym.into(), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn symbolByRVAEx<'a, P0>(&self, fpromoteblocksym: P0, relativevirtualaddress: u32) -> ::windows::core::Result<IDiaSymbol>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symbolByRVAEx)(::windows::core::Vtable::as_raw(self), fpromoteblocksym.into(), relativevirtualaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn symbolByVAEx<'a, P0>(&self, fpromoteblocksym: P0, virtualaddress: u64) -> ::windows::core::Result<IDiaSymbol>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symbolByVAEx)(::windows::core::Vtable::as_raw(self), fpromoteblocksym.into(), virtualaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn NextEx<'a, P0>(&self, fpromoteblocksym: P0, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).NextEx)(::windows::core::Vtable::as_raw(self), fpromoteblocksym.into(), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn PrevEx<'a, P0>(&self, fpromoteblocksym: P0, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).PrevEx)(::windows::core::Vtable::as_raw(self), fpromoteblocksym.into(), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaEnumSymbolsByAddr2, ::windows::core::IUnknown, IDiaEnumSymbolsByAddr);
impl ::core::clone::Clone for IDiaEnumSymbolsByAddr2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumSymbolsByAddr2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumSymbolsByAddr2 {}
impl ::core::fmt::Debug for IDiaEnumSymbolsByAddr2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumSymbolsByAddr2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumSymbolsByAddr2 {
    type Vtable = IDiaEnumSymbolsByAddr2_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumSymbolsByAddr2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e45bd02_be45_4d71_ba32_0e576cfcd59f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumSymbolsByAddr2_Vtbl {
    pub base__: IDiaEnumSymbolsByAddr_Vtbl,
    pub symbolByAddrEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, isect: u32, offset: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub symbolByRVAEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, relativevirtualaddress: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub symbolByVAEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, virtualaddress: u64, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub NextEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub PrevEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaEnumTables(::windows::core::IUnknown);
impl IDiaEnumTables {
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item<'a, P0>(&self, index: P0) -> ::windows::core::Result<IDiaTable>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, ::windows::Win32::System::Com::VARIANT>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaTable>(result__)
    }
    pub unsafe fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaTable>, pceltfetched: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Next)(::windows::core::Vtable::as_raw(self), celt, ::core::mem::transmute(rgelt), ::core::mem::transmute(pceltfetched)).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IDiaEnumTables> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumTables>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaEnumTables, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaEnumTables {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaEnumTables {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaEnumTables {}
impl ::core::fmt::Debug for IDiaEnumTables {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaEnumTables").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaEnumTables {
    type Vtable = IDiaEnumTables_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaEnumTables {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc65c2b0a_1150_4d7a_afcc_e05bf3dee81e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaEnumTables_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<::windows::Win32::System::Com::VARIANT>, table: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Next: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT,
    pub Skip: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaFrameData(::windows::core::IUnknown);
impl IDiaFrameData {
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn lengthBlock(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lengthBlock)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lengthLocals(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lengthLocals)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lengthParams(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lengthParams)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn maxStack(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).maxStack)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lengthProlog(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lengthProlog)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lengthSavedRegisters(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lengthSavedRegisters)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn program(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).program)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn systemExceptionHandling(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).systemExceptionHandling)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn cplusplusExceptionHandling(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).cplusplusExceptionHandling)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn functionStart(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).functionStart)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn allocatesBasePointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).allocatesBasePointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn functionParent(&self) -> ::windows::core::Result<IDiaFrameData> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).functionParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaFrameData>(result__)
    }
    pub unsafe fn execute<'a, P0>(&self, frame: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaStackWalkFrame>>,
    {
        (::windows::core::Vtable::vtable(self).execute)(::windows::core::Vtable::as_raw(self), frame.into().abi()).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaFrameData, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaFrameData {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaFrameData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaFrameData {}
impl ::core::fmt::Debug for IDiaFrameData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaFrameData").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaFrameData {
    type Vtable = IDiaFrameData_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaFrameData {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa39184b7_6a36_42de_8eec_7df9f3f59f33);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaFrameData_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub addressSection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub addressOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub relativeVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub virtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub lengthBlock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub lengthLocals: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub lengthParams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub maxStack: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub lengthProlog: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub lengthSavedRegisters: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub program: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub systemExceptionHandling: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub cplusplusExceptionHandling: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub functionStart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub allocatesBasePointer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub r#type: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub functionParent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub execute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaImageData(::windows::core::IUnknown);
impl IDiaImageData {
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn imageBase(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).imageBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaImageData, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaImageData {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaImageData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaImageData {}
impl ::core::fmt::Debug for IDiaImageData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaImageData").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaImageData {
    type Vtable = IDiaImageData_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaImageData {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8e40ed2_a1d9_4221_8692_3ce661184b44);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaImageData_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub relativeVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub virtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub imageBase: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaInjectedSource(::windows::core::IUnknown);
impl IDiaInjectedSource {
    pub unsafe fn crc(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).crc)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn filename(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).filename)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn objectFilename(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).objectFilename)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn virtualFilename(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualFilename)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn sourceCompression(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).sourceCompression)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_source(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_source)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaInjectedSource, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaInjectedSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaInjectedSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaInjectedSource {}
impl ::core::fmt::Debug for IDiaInjectedSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaInjectedSource").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaInjectedSource {
    type Vtable = IDiaInjectedSource_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaInjectedSource {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xae605cdc_8105_4a23_b710_3259f1e26112);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaInjectedSource_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub crc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub length: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub filename: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub objectFilename: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub virtualFilename: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub sourceCompression: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub get_source: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaInputAssemblyFile(::windows::core::IUnknown);
impl IDiaInputAssemblyFile {
    pub unsafe fn uniqueId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).uniqueId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn index(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).index)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timestamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).timestamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn pdbAvailableAtILMerge(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).pdbAvailableAtILMerge)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn fileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).fileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn get_version(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_version)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaInputAssemblyFile, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaInputAssemblyFile {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaInputAssemblyFile {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaInputAssemblyFile {}
impl ::core::fmt::Debug for IDiaInputAssemblyFile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaInputAssemblyFile").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaInputAssemblyFile {
    type Vtable = IDiaInputAssemblyFile_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaInputAssemblyFile {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3bfe56b0_390c_4863_9430_1f3d083b7684);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaInputAssemblyFile_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub uniqueId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub index: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub timestamp: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub pdbAvailableAtILMerge: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub fileName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub get_version: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaLineNumber(::windows::core::IUnknown);
impl IDiaLineNumber {
    pub unsafe fn compiland(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).compiland)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn sourceFile(&self) -> ::windows::core::Result<IDiaSourceFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).sourceFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSourceFile>(result__)
    }
    pub unsafe fn lineNumber(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lineNumber)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lineNumberEnd(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lineNumberEnd)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn columnNumber(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).columnNumber)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn columnNumberEnd(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).columnNumberEnd)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).sourceFileId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn statement(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).statement)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilandId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).compilandId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaLineNumber, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaLineNumber {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaLineNumber {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaLineNumber {}
impl ::core::fmt::Debug for IDiaLineNumber {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaLineNumber").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaLineNumber {
    type Vtable = IDiaLineNumber_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaLineNumber {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb388eb14_be4d_421d_a8a1_6cf7ab057086);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaLineNumber_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub compiland: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub sourceFile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub lineNumber: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub lineNumberEnd: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub columnNumber: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub columnNumberEnd: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub addressSection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub addressOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub relativeVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub virtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub length: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub sourceFileId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub statement: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub compilandId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaLoadCallback(::windows::core::IUnknown);
impl IDiaLoadCallback {
    pub unsafe fn NotifyDebugDir<'a, P0>(&self, fexecutable: P0, pbdata: &[u8]) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).NotifyDebugDir)(::windows::core::Vtable::as_raw(self), fexecutable.into(), pbdata.len() as _, ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn NotifyOpenDBG<'a, P0>(&self, dbgpath: P0, resultcode: ::windows::core::HRESULT) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        (::windows::core::Vtable::vtable(self).NotifyOpenDBG)(::windows::core::Vtable::as_raw(self), dbgpath.into(), resultcode).ok()
    }
    pub unsafe fn NotifyOpenPDB<'a, P0>(&self, pdbpath: P0, resultcode: ::windows::core::HRESULT) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        (::windows::core::Vtable::vtable(self).NotifyOpenPDB)(::windows::core::Vtable::as_raw(self), pdbpath.into(), resultcode).ok()
    }
    pub unsafe fn RestrictRegistryAccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).RestrictRegistryAccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RestrictSymbolServerAccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).RestrictSymbolServerAccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaLoadCallback, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaLoadCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaLoadCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaLoadCallback {}
impl ::core::fmt::Debug for IDiaLoadCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaLoadCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaLoadCallback {
    type Vtable = IDiaLoadCallback_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaLoadCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc32adb82_73f4_421b_95d5_a4706edf5dbe);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaLoadCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub NotifyDebugDir: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fexecutable: ::windows::Win32::Foundation::BOOL, cbdata: u32, pbdata: *const u8) -> ::windows::core::HRESULT,
    pub NotifyOpenDBG: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dbgpath: ::windows::core::PCWSTR, resultcode: ::windows::core::HRESULT) -> ::windows::core::HRESULT,
    pub NotifyOpenPDB: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdbpath: ::windows::core::PCWSTR, resultcode: ::windows::core::HRESULT) -> ::windows::core::HRESULT,
    pub RestrictRegistryAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RestrictSymbolServerAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaLoadCallback2(::windows::core::IUnknown);
impl IDiaLoadCallback2 {
    pub unsafe fn NotifyDebugDir<'a, P0>(&self, fexecutable: P0, pbdata: &[u8]) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.NotifyDebugDir)(::windows::core::Vtable::as_raw(self), fexecutable.into(), pbdata.len() as _, ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn NotifyOpenDBG<'a, P0>(&self, dbgpath: P0, resultcode: ::windows::core::HRESULT) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        (::windows::core::Vtable::vtable(self).base__.NotifyOpenDBG)(::windows::core::Vtable::as_raw(self), dbgpath.into(), resultcode).ok()
    }
    pub unsafe fn NotifyOpenPDB<'a, P0>(&self, pdbpath: P0, resultcode: ::windows::core::HRESULT) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        (::windows::core::Vtable::vtable(self).base__.NotifyOpenPDB)(::windows::core::Vtable::as_raw(self), pdbpath.into(), resultcode).ok()
    }
    pub unsafe fn RestrictRegistryAccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RestrictRegistryAccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RestrictSymbolServerAccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RestrictSymbolServerAccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RestrictOriginalPathAccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).RestrictOriginalPathAccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RestrictReferencePathAccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).RestrictReferencePathAccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RestrictDBGAccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).RestrictDBGAccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RestrictSystemRootAccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).RestrictSystemRootAccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaLoadCallback2, ::windows::core::IUnknown, IDiaLoadCallback);
impl ::core::clone::Clone for IDiaLoadCallback2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaLoadCallback2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaLoadCallback2 {}
impl ::core::fmt::Debug for IDiaLoadCallback2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaLoadCallback2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaLoadCallback2 {
    type Vtable = IDiaLoadCallback2_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaLoadCallback2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4688a074_5a4d_4486_aea8_7b90711d9f7c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaLoadCallback2_Vtbl {
    pub base__: IDiaLoadCallback_Vtbl,
    pub RestrictOriginalPathAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RestrictReferencePathAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RestrictDBGAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RestrictSystemRootAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaPropertyStorage(::windows::core::IUnknown);
impl IDiaPropertyStorage {
    pub unsafe fn ReadMultiple(&self, cpspec: u32, rgpspec: *const ::windows::Win32::System::Com::StructuredStorage::PROPSPEC) -> ::windows::core::Result<::windows::Win32::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).ReadMultiple)(::windows::core::Vtable::as_raw(self), cpspec, ::core::mem::transmute(rgpspec), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::StructuredStorage::PROPVARIANT>(result__)
    }
    pub unsafe fn ReadPropertyNames(&self, cpropid: u32, rgpropid: *const u32, rglpwstrname: *mut ::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).ReadPropertyNames)(::windows::core::Vtable::as_raw(self), cpropid, ::core::mem::transmute(rgpropid), ::core::mem::transmute(rglpwstrname)).ok()
    }
    pub unsafe fn Enum(&self) -> ::windows::core::Result<::windows::Win32::System::Com::StructuredStorage::IEnumSTATPROPSTG> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Enum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::StructuredStorage::IEnumSTATPROPSTG>(result__)
    }
    pub unsafe fn ReadDWORD(&self, id: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).ReadDWORD)(::windows::core::Vtable::as_raw(self), id, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn ReadLONG(&self, id: u32) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).ReadLONG)(::windows::core::Vtable::as_raw(self), id, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn ReadBOOL(&self, id: u32) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).ReadBOOL)(::windows::core::Vtable::as_raw(self), id, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ReadULONGLONG(&self, id: u32) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).ReadULONGLONG)(::windows::core::Vtable::as_raw(self), id, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn ReadBSTR(&self, id: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).ReadBSTR)(::windows::core::Vtable::as_raw(self), id, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaPropertyStorage, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaPropertyStorage {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaPropertyStorage {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaPropertyStorage {}
impl ::core::fmt::Debug for IDiaPropertyStorage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaPropertyStorage").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaPropertyStorage {
    type Vtable = IDiaPropertyStorage_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaPropertyStorage {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d416f9c_e184_45b2_a4f0_ce517f719e9b);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaPropertyStorage_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub ReadMultiple: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cpspec: u32, rgpspec: *const ::windows::Win32::System::Com::StructuredStorage::PROPSPEC, rgvar: *mut ::core::mem::ManuallyDrop<::windows::Win32::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::HRESULT,
    pub ReadPropertyNames: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cpropid: u32, rgpropid: *const u32, rglpwstrname: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub Enum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ReadDWORD: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut u32) -> ::windows::core::HRESULT,
    pub ReadLONG: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut i32) -> ::windows::core::HRESULT,
    pub ReadBOOL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub ReadULONGLONG: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut u64) -> ::windows::core::HRESULT,
    pub ReadBSTR: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaReadExeAtOffsetCallback(::windows::core::IUnknown);
impl IDiaReadExeAtOffsetCallback {
    pub unsafe fn ReadExecutableAt(&self, fileoffset: u64, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).ReadExecutableAt)(::windows::core::Vtable::as_raw(self), fileoffset, pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaReadExeAtOffsetCallback, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaReadExeAtOffsetCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaReadExeAtOffsetCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaReadExeAtOffsetCallback {}
impl ::core::fmt::Debug for IDiaReadExeAtOffsetCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaReadExeAtOffsetCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaReadExeAtOffsetCallback {
    type Vtable = IDiaReadExeAtOffsetCallback_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaReadExeAtOffsetCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x587a461c_b80b_4f54_9194_5032589a6319);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaReadExeAtOffsetCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub ReadExecutableAt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fileoffset: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaReadExeAtRVACallback(::windows::core::IUnknown);
impl IDiaReadExeAtRVACallback {
    pub unsafe fn ReadExecutableAtRVA(&self, relativevirtualaddress: u32, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).ReadExecutableAtRVA)(::windows::core::Vtable::as_raw(self), relativevirtualaddress, pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaReadExeAtRVACallback, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaReadExeAtRVACallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaReadExeAtRVACallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaReadExeAtRVACallback {}
impl ::core::fmt::Debug for IDiaReadExeAtRVACallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaReadExeAtRVACallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaReadExeAtRVACallback {
    type Vtable = IDiaReadExeAtRVACallback_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaReadExeAtRVACallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8e3f80ca_7517_432a_ba07_285134aaea8e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaReadExeAtRVACallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub ReadExecutableAtRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, relativevirtualaddress: u32, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSectionContrib(::windows::core::IUnknown);
impl IDiaSectionContrib {
    pub unsafe fn compiland(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).compiland)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn notPaged(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).notPaged)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn initializedData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).initializedData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn uninitializedData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).uninitializedData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn remove(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).remove)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn comdat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).comdat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn discardable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).discardable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notCached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).notCached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn share(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).share)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn execute(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).execute)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn read(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).read)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn write(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).write)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataCrc(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).dataCrc)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relocationsCrc(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).relocationsCrc)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilandId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).compilandId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code16bit(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).code16bit)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSectionContrib, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaSectionContrib {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSectionContrib {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSectionContrib {}
impl ::core::fmt::Debug for IDiaSectionContrib {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSectionContrib").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSectionContrib {
    type Vtable = IDiaSectionContrib_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSectionContrib {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0cf4b60e_35b1_4c6c_bdd8_854b9c8e3857);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSectionContrib_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub compiland: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub addressSection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub addressOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub relativeVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub virtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub length: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub notPaged: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub code: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub initializedData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub uninitializedData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub remove: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub comdat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub discardable: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub notCached: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub share: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub execute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub read: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub write: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub dataCrc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub relocationsCrc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub compilandId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub code16bit: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSegment(::windows::core::IUnknown);
impl IDiaSegment {
    pub unsafe fn frame(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).frame)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn read(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).read)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn write(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).write)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn execute(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).execute)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSegment, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaSegment {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSegment {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSegment {}
impl ::core::fmt::Debug for IDiaSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSegment").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSegment {
    type Vtable = IDiaSegment_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSegment {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0775b784_c75b_4449_848b_b7bd3159545b);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSegment_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub frame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub offset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub length: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub read: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub write: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub execute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub addressSection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub relativeVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub virtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSession(::windows::core::IUnknown);
impl IDiaSession {
    pub unsafe fn loadAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).loadAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn SetloadAddress(&self, newval: u64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).SetloadAddress)(::windows::core::Vtable::as_raw(self), newval).ok()
    }
    pub unsafe fn globalScope(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).globalScope)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn getEnumTables(&self) -> ::windows::core::Result<IDiaEnumTables> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getEnumTables)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumTables>(result__)
    }
    pub unsafe fn getSymbolsByAddr(&self) -> ::windows::core::Result<IDiaEnumSymbolsByAddr> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getSymbolsByAddr)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbolsByAddr>(result__)
    }
    pub unsafe fn findChildren<'a, P0, P1>(&self, parent: P0, symtag: SymTag, name: P1, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildren)(::windows::core::Vtable::as_raw(self), parent.into().abi(), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0, P1>(&self, parent: P0, symtag: SymTag, name: P1, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildrenEx)(::windows::core::Vtable::as_raw(self), parent.into().abi(), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0, P1>(&self, parent: P0, symtag: SymTag, name: P1, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), parent.into().abi(), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0, P1>(&self, parent: P0, symtag: SymTag, name: P1, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildrenExByVA)(::windows::core::Vtable::as_raw(self), parent.into().abi(), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0, P1>(&self, parent: P0, symtag: SymTag, name: P1, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), parent.into().abi(), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolByAddr(&self, isect: u32, offset: u32, symtag: SymTag) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findSymbolByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, symtag, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn findSymbolByRVA(&self, rva: u32, symtag: SymTag) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findSymbolByRVA)(::windows::core::Vtable::as_raw(self), rva, symtag, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn findSymbolByVA(&self, va: u64, symtag: SymTag) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findSymbolByVA)(::windows::core::Vtable::as_raw(self), va, symtag, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn findSymbolByToken(&self, token: u32, symtag: SymTag) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findSymbolByToken)(::windows::core::Vtable::as_raw(self), token, symtag, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn symsAreEquiv<'a, P0, P1>(&self, symbola: P0, symbolb: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        (::windows::core::Vtable::vtable(self).symsAreEquiv)(::windows::core::Vtable::as_raw(self), symbola.into().abi(), symbolb.into().abi()).ok()
    }
    pub unsafe fn symbolById(&self, id: u32) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symbolById)(::windows::core::Vtable::as_raw(self), id, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn findSymbolByRVAEx(&self, rva: u32, symtag: SymTag, ppsymbol: *mut ::core::option::Option<IDiaSymbol>, displacement: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).findSymbolByRVAEx)(::windows::core::Vtable::as_raw(self), rva, symtag, ::core::mem::transmute(ppsymbol), ::core::mem::transmute(displacement)).ok()
    }
    pub unsafe fn findSymbolByVAEx(&self, va: u64, symtag: SymTag, ppsymbol: *mut ::core::option::Option<IDiaSymbol>, displacement: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).findSymbolByVAEx)(::windows::core::Vtable::as_raw(self), va, symtag, ::core::mem::transmute(ppsymbol), ::core::mem::transmute(displacement)).ok()
    }
    pub unsafe fn findFile<'a, P0, P1>(&self, pcompiland: P0, name: P1, compareflags: u32) -> ::windows::core::Result<IDiaEnumSourceFiles>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findFile)(::windows::core::Vtable::as_raw(self), pcompiland.into().abi(), name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSourceFiles>(result__)
    }
    pub unsafe fn findFileById(&self, uniqueid: u32) -> ::windows::core::Result<IDiaSourceFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findFileById)(::windows::core::Vtable::as_raw(self), uniqueid, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSourceFile>(result__)
    }
    pub unsafe fn findLines<'a, P0, P1>(&self, compiland: P0, file: P1) -> ::windows::core::Result<IDiaEnumLineNumbers>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::InParam<'a, IDiaSourceFile>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findLines)(::windows::core::Vtable::as_raw(self), compiland.into().abi(), file.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findLinesByAddr(&self, seg: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findLinesByAddr)(::windows::core::Vtable::as_raw(self), seg, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findLinesByLinenum<'a, P0, P1>(&self, compiland: P0, file: P1, linenum: u32, column: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::InParam<'a, IDiaSourceFile>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findLinesByLinenum)(::windows::core::Vtable::as_raw(self), compiland.into().abi(), file.into().abi(), linenum, column, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInjectedSource<'a, P0>(&self, srcfile: P0) -> ::windows::core::Result<IDiaEnumInjectedSources>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInjectedSource)(::windows::core::Vtable::as_raw(self), srcfile.into(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumInjectedSources>(result__)
    }
    pub unsafe fn getEnumDebugStreams(&self) -> ::windows::core::Result<IDiaEnumDebugStreams> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getEnumDebugStreams)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumDebugStreams>(result__)
    }
    pub unsafe fn findInlineFramesByAddr<'a, P0>(&self, parent: P0, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), parent.into().abi(), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA<'a, P0>(&self, parent: P0, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), parent.into().abi(), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA<'a, P0>(&self, parent: P0, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), parent.into().abi(), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines<'a, P0>(&self, parent: P0) -> ::windows::core::Result<IDiaEnumLineNumbers>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineeLines)(::windows::core::Vtable::as_raw(self), parent.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr<'a, P0>(&self, parent: P0, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), parent.into().abi(), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA<'a, P0>(&self, parent: P0, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), parent.into().abi(), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA<'a, P0>(&self, parent: P0, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), parent.into().abi(), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByLinenum<'a, P0, P1>(&self, compiland: P0, file: P1, linenum: u32, column: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::InParam<'a, IDiaSourceFile>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineeLinesByLinenum)(::windows::core::Vtable::as_raw(self), compiland.into().abi(), file.into().abi(), linenum, column, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineesByName<'a, P0>(&self, name: P0, option: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineesByName)(::windows::core::Vtable::as_raw(self), name.into(), option, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findAcceleratorInlineeLinesByLinenum<'a, P0, P1>(&self, parent: P0, file: P1, linenum: u32, column: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
        P1: ::std::convert::Into<::windows::core::InParam<'a, IDiaSourceFile>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findAcceleratorInlineeLinesByLinenum)(::windows::core::Vtable::as_raw(self), parent.into().abi(), file.into().abi(), linenum, column, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag<'a, P0>(&self, parent: P0, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), parent.into().abi(), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag<'a, P0>(&self, parent: P0, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), parent.into().abi(), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findAcceleratorInlineesByName<'a, P0>(&self, name: P0, option: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findAcceleratorInlineesByName)(::windows::core::Vtable::as_raw(self), name.into(), option, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn addressForVA(&self, va: u64, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).addressForVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(pisect), ::core::mem::transmute(poffset)).ok()
    }
    pub unsafe fn addressForRVA(&self, rva: u32, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).addressForRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(pisect), ::core::mem::transmute(poffset)).ok()
    }
    pub unsafe fn findILOffsetsByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findILOffsetsByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findILOffsetsByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findILOffsetsByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findILOffsetsByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findILOffsetsByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInputAssemblyFiles(&self) -> ::windows::core::Result<IDiaEnumInputAssemblyFiles> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInputAssemblyFiles)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumInputAssemblyFiles>(result__)
    }
    pub unsafe fn findInputAssembly(&self, index: u32) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInputAssembly)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn findInputAssemblyById(&self, uniqueid: u32) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInputAssemblyById)(::windows::core::Vtable::as_raw(self), uniqueid, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn getFuncMDTokenMapSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getFuncMDTokenMapSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn getFuncMDTokenMap(&self, pcb: *mut u32, pb: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).getFuncMDTokenMap)(::windows::core::Vtable::as_raw(self), pb.len() as _, ::core::mem::transmute(pcb), ::core::mem::transmute(pb.as_ptr())).ok()
    }
    pub unsafe fn getTypeMDTokenMapSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getTypeMDTokenMapSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn getTypeMDTokenMap(&self, pcb: *mut u32, pb: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).getTypeMDTokenMap)(::windows::core::Vtable::as_raw(self), pb.len() as _, ::core::mem::transmute(pcb), ::core::mem::transmute(pb.as_ptr())).ok()
    }
    pub unsafe fn getNumberOfFunctionFragments_VA(&self, vafunc: u64, cbfunc: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getNumberOfFunctionFragments_VA)(::windows::core::Vtable::as_raw(self), vafunc, cbfunc, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn getNumberOfFunctionFragments_RVA(&self, rvafunc: u32, cbfunc: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getNumberOfFunctionFragments_RVA)(::windows::core::Vtable::as_raw(self), rvafunc, cbfunc, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn getFunctionFragments_VA(&self, vafunc: u64, cbfunc: u32, cfragments: u32, pvafragment: *mut u64, plenfragment: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).getFunctionFragments_VA)(::windows::core::Vtable::as_raw(self), vafunc, cbfunc, cfragments, ::core::mem::transmute(pvafragment), ::core::mem::transmute(plenfragment)).ok()
    }
    pub unsafe fn getFunctionFragments_RVA(&self, rvafunc: u32, cbfunc: u32, cfragments: u32, prvafragment: *mut u32, plenfragment: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).getFunctionFragments_RVA)(::windows::core::Vtable::as_raw(self), rvafunc, cbfunc, cfragments, ::core::mem::transmute(prvafragment), ::core::mem::transmute(plenfragment)).ok()
    }
    pub unsafe fn getExports(&self) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getExports)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn getHeapAllocationSites(&self) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getHeapAllocationSites)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInputAssemblyFile<'a, P0>(&self, psymbol: P0) -> ::windows::core::Result<IDiaInputAssemblyFile>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaSymbol>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), psymbol.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSession, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaSession {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSession {}
impl ::core::fmt::Debug for IDiaSession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSession").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSession {
    type Vtable = IDiaSession_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSession {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f609ee1_d1c8_4e24_8288_3326badcd211);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSession_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub loadAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub SetloadAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, newval: u64) -> ::windows::core::HRESULT,
    pub globalScope: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub getEnumTables: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenumtables: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub getSymbolsByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenumbyaddr: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findChildren: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findChildrenEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findChildrenExByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, isect: u32, offset: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findChildrenExByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, va: u64, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findChildrenExByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findSymbolByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findSymbolByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rva: u32, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findSymbolByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findSymbolByToken: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, token: u32, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub symsAreEquiv: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symbola: *mut ::core::ffi::c_void, symbolb: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub symbolById: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, id: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findSymbolByRVAEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rva: u32, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void, displacement: *mut i32) -> ::windows::core::HRESULT,
    pub findSymbolByVAEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void, displacement: *mut i32) -> ::windows::core::HRESULT,
    pub findFile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcompiland: *mut ::core::ffi::c_void, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findFileById: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, uniqueid: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findLines: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, compiland: *mut ::core::ffi::c_void, file: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findLinesByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, seg: u32, offset: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findLinesByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rva: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findLinesByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findLinesByLinenum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, compiland: *mut ::core::ffi::c_void, file: *mut ::core::ffi::c_void, linenum: u32, column: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInjectedSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, srcfile: ::windows::core::PCWSTR, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub getEnumDebugStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenumdebugstreams: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineFramesByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, isect: u32, offset: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineFramesByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineFramesByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, va: u64, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineeLines: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineeLinesByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, isect: u32, offset: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineeLinesByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, rva: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineeLinesByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, va: u64, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineeLinesByLinenum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, compiland: *mut ::core::ffi::c_void, file: *mut ::core::ffi::c_void, linenum: u32, column: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineesByName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, name: ::windows::core::PCWSTR, option: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findAcceleratorInlineeLinesByLinenum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, file: *mut ::core::ffi::c_void, linenum: u32, column: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findSymbolsForAcceleratorPointerTag: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, tagvalue: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findSymbolsByRVAForAcceleratorPointerTag: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, tagvalue: u32, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findAcceleratorInlineesByName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, name: ::windows::core::PCWSTR, option: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub addressForVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::HRESULT,
    pub addressForRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rva: u32, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::HRESULT,
    pub findILOffsetsByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findILOffsetsByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rva: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findILOffsetsByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInputAssemblyFiles: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInputAssembly: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInputAssemblyById: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, uniqueid: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub getFuncMDTokenMapSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcb: *mut u32) -> ::windows::core::HRESULT,
    pub getFuncMDTokenMap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cb: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT,
    pub getTypeMDTokenMapSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcb: *mut u32) -> ::windows::core::HRESULT,
    pub getTypeMDTokenMap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cb: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT,
    pub getNumberOfFunctionFragments_VA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, vafunc: u64, cbfunc: u32, pnumfragments: *mut u32) -> ::windows::core::HRESULT,
    pub getNumberOfFunctionFragments_RVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rvafunc: u32, cbfunc: u32, pnumfragments: *mut u32) -> ::windows::core::HRESULT,
    pub getFunctionFragments_VA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, vafunc: u64, cbfunc: u32, cfragments: u32, pvafragment: *mut u64, plenfragment: *mut u32) -> ::windows::core::HRESULT,
    pub getFunctionFragments_RVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rvafunc: u32, cbfunc: u32, cfragments: u32, prvafragment: *mut u32, plenfragment: *mut u32) -> ::windows::core::HRESULT,
    pub getExports: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub getHeapAllocationSites: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInputAssemblyFile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psymbol: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSourceFile(::windows::core::IUnknown);
impl IDiaSourceFile {
    pub unsafe fn uniqueId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).uniqueId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn fileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).fileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn checksumType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).checksumType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilands(&self) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).compilands)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_checksum(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_checksum)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaSourceFile, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaSourceFile {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSourceFile {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSourceFile {}
impl ::core::fmt::Debug for IDiaSourceFile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSourceFile").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSourceFile {
    type Vtable = IDiaSourceFile_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSourceFile {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa2ef5353_f5a8_4eb3_90d2_cb526acb3cdd);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSourceFile_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub uniqueId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub fileName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub checksumType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub compilands: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub get_checksum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaStackFrame(::windows::core::IUnknown);
impl IDiaStackFrame {
    pub unsafe fn r#type(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn base(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn size(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).size)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn returnAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).returnAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn localsBase(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).localsBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn lengthLocals(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lengthLocals)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lengthParams(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lengthParams)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lengthProlog(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lengthProlog)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lengthSavedRegisters(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lengthSavedRegisters)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn systemExceptionHandling(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).systemExceptionHandling)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn cplusplusExceptionHandling(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).cplusplusExceptionHandling)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn functionStart(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).functionStart)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn allocatesBasePointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).allocatesBasePointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn maxStack(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).maxStack)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_registerValue(&self, index: u32) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).get_registerValue)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaStackFrame, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaStackFrame {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaStackFrame {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaStackFrame {}
impl ::core::fmt::Debug for IDiaStackFrame {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaStackFrame").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaStackFrame {
    type Vtable = IDiaStackFrame_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaStackFrame {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5edbc96d_cdd6_4792_afbe_cc89007d9610);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaStackFrame_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub r#type: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub base: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub size: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub returnAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub localsBase: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub lengthLocals: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub lengthParams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub lengthProlog: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub lengthSavedRegisters: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub systemExceptionHandling: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub cplusplusExceptionHandling: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub functionStart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub allocatesBasePointer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub maxStack: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub get_registerValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, pretval: *mut u64) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaStackWalkFrame(::windows::core::IUnknown);
impl IDiaStackWalkFrame {
    pub unsafe fn get_registerValue(&self, index: u32) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).get_registerValue)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn put_registerValue(&self, index: u32, newval: u64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).put_registerValue)(::windows::core::Vtable::as_raw(self), index, newval).ok()
    }
    pub unsafe fn readMemory(&self, r#type: MemoryTypeEnum, va: u64, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).readMemory)(::windows::core::Vtable::as_raw(self), r#type, va, pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn searchForReturnAddress<'a, P0>(&self, frame: P0) -> ::windows::core::Result<u64>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaFrameData>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).searchForReturnAddress)(::windows::core::Vtable::as_raw(self), frame.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn searchForReturnAddressStart<'a, P0>(&self, frame: P0, startaddress: u64) -> ::windows::core::Result<u64>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaFrameData>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).searchForReturnAddressStart)(::windows::core::Vtable::as_raw(self), frame.into().abi(), startaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaStackWalkFrame, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaStackWalkFrame {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaStackWalkFrame {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaStackWalkFrame {}
impl ::core::fmt::Debug for IDiaStackWalkFrame {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaStackWalkFrame").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaStackWalkFrame {
    type Vtable = IDiaStackWalkFrame_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaStackWalkFrame {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x07c590c1_438d_4f47_bdcd_4397bc81ad75);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaStackWalkFrame_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub get_registerValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub put_registerValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, newval: u64) -> ::windows::core::HRESULT,
    pub readMemory: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#type: MemoryTypeEnum, va: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
    pub searchForReturnAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void, returnaddress: *mut u64) -> ::windows::core::HRESULT,
    pub searchForReturnAddressStart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void, startaddress: u64, returnaddress: *mut u64) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaStackWalkHelper(::windows::core::IUnknown);
impl IDiaStackWalkHelper {
    pub unsafe fn get_registerValue(&self, index: u32) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).get_registerValue)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn put_registerValue(&self, index: u32, newval: u64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).put_registerValue)(::windows::core::Vtable::as_raw(self), index, newval).ok()
    }
    pub unsafe fn readMemory(&self, r#type: MemoryTypeEnum, va: u64, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).readMemory)(::windows::core::Vtable::as_raw(self), r#type, va, pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn searchForReturnAddress<'a, P0>(&self, frame: P0) -> ::windows::core::Result<u64>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaFrameData>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).searchForReturnAddress)(::windows::core::Vtable::as_raw(self), frame.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn searchForReturnAddressStart<'a, P0>(&self, frame: P0, startaddress: u64) -> ::windows::core::Result<u64>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaFrameData>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).searchForReturnAddressStart)(::windows::core::Vtable::as_raw(self), frame.into().abi(), startaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn frameForVA(&self, va: u64) -> ::windows::core::Result<IDiaFrameData> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).frameForVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaFrameData>(result__)
    }
    pub unsafe fn symbolForVA(&self, va: u64) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symbolForVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn pdataForVA(&self, va: u64, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).pdataForVA)(::windows::core::Vtable::as_raw(self), va, pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn imageForVA(&self, vacontext: u64) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).imageForVA)(::windows::core::Vtable::as_raw(self), vacontext, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn addressForVA(&self, va: u64, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).addressForVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(pisect), ::core::mem::transmute(poffset)).ok()
    }
    pub unsafe fn numberOfFunctionFragmentsForVA(&self, vafunc: u64, cbfunc: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).numberOfFunctionFragmentsForVA)(::windows::core::Vtable::as_raw(self), vafunc, cbfunc, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn functionFragmentsForVA(&self, vafunc: u64, cbfunc: u32, cfragments: u32, pvafragment: *mut u64, plenfragment: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).functionFragmentsForVA)(::windows::core::Vtable::as_raw(self), vafunc, cbfunc, cfragments, ::core::mem::transmute(pvafragment), ::core::mem::transmute(plenfragment)).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaStackWalkHelper, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaStackWalkHelper {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaStackWalkHelper {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaStackWalkHelper {}
impl ::core::fmt::Debug for IDiaStackWalkHelper {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaStackWalkHelper").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaStackWalkHelper {
    type Vtable = IDiaStackWalkHelper_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaStackWalkHelper {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x21f81b1b_c5bb_42a3_bc4f_ccbaa75b9f19);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaStackWalkHelper_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub get_registerValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub put_registerValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, newval: u64) -> ::windows::core::HRESULT,
    pub readMemory: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#type: MemoryTypeEnum, va: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
    pub searchForReturnAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void, returnaddress: *mut u64) -> ::windows::core::HRESULT,
    pub searchForReturnAddressStart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void, startaddress: u64, returnaddress: *mut u64) -> ::windows::core::HRESULT,
    pub frameForVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, ppframe: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub symbolForVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub pdataForVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
    pub imageForVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, vacontext: u64, pvaimagestart: *mut u64) -> ::windows::core::HRESULT,
    pub addressForVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::HRESULT,
    pub numberOfFunctionFragmentsForVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, vafunc: u64, cbfunc: u32, pnumfragments: *mut u32) -> ::windows::core::HRESULT,
    pub functionFragmentsForVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, vafunc: u64, cbfunc: u32, cfragments: u32, pvafragment: *mut u64, plenfragment: *mut u32) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaStackWalkHelper2(::windows::core::IUnknown);
impl IDiaStackWalkHelper2 {
    pub unsafe fn get_registerValue(&self, index: u32) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_registerValue)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn put_registerValue(&self, index: u32, newval: u64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.put_registerValue)(::windows::core::Vtable::as_raw(self), index, newval).ok()
    }
    pub unsafe fn readMemory(&self, r#type: MemoryTypeEnum, va: u64, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.readMemory)(::windows::core::Vtable::as_raw(self), r#type, va, pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn searchForReturnAddress<'a, P0>(&self, frame: P0) -> ::windows::core::Result<u64>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaFrameData>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.searchForReturnAddress)(::windows::core::Vtable::as_raw(self), frame.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn searchForReturnAddressStart<'a, P0>(&self, frame: P0, startaddress: u64) -> ::windows::core::Result<u64>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaFrameData>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.searchForReturnAddressStart)(::windows::core::Vtable::as_raw(self), frame.into().abi(), startaddress, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn frameForVA(&self, va: u64) -> ::windows::core::Result<IDiaFrameData> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.frameForVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaFrameData>(result__)
    }
    pub unsafe fn symbolForVA(&self, va: u64) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.symbolForVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn pdataForVA(&self, va: u64, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.pdataForVA)(::windows::core::Vtable::as_raw(self), va, pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn imageForVA(&self, vacontext: u64) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.imageForVA)(::windows::core::Vtable::as_raw(self), vacontext, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn addressForVA(&self, va: u64, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.addressForVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(pisect), ::core::mem::transmute(poffset)).ok()
    }
    pub unsafe fn numberOfFunctionFragmentsForVA(&self, vafunc: u64, cbfunc: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.numberOfFunctionFragmentsForVA)(::windows::core::Vtable::as_raw(self), vafunc, cbfunc, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn functionFragmentsForVA(&self, vafunc: u64, cbfunc: u32, cfragments: u32, pvafragment: *mut u64, plenfragment: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.functionFragmentsForVA)(::windows::core::Vtable::as_raw(self), vafunc, cbfunc, cfragments, ::core::mem::transmute(pvafragment), ::core::mem::transmute(plenfragment)).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaStackWalkHelper2, ::windows::core::IUnknown, IDiaStackWalkHelper);
impl ::core::clone::Clone for IDiaStackWalkHelper2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaStackWalkHelper2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaStackWalkHelper2 {}
impl ::core::fmt::Debug for IDiaStackWalkHelper2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaStackWalkHelper2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaStackWalkHelper2 {
    type Vtable = IDiaStackWalkHelper2_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaStackWalkHelper2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8222c490_507b_4bef_b3bd_41dca7b5934c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaStackWalkHelper2_Vtbl {
    pub base__: IDiaStackWalkHelper_Vtbl,
}
#[repr(transparent)]
pub struct IDiaStackWalker(::windows::core::IUnknown);
impl IDiaStackWalker {
    pub unsafe fn getEnumFrames<'a, P0>(&self, phelper: P0) -> ::windows::core::Result<IDiaEnumStackFrames>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaStackWalkHelper>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getEnumFrames)(::windows::core::Vtable::as_raw(self), phelper.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumStackFrames>(result__)
    }
    pub unsafe fn getEnumFrames2<'a, P0>(&self, cpuid: CV_CPU_TYPE_e, phelper: P0) -> ::windows::core::Result<IDiaEnumStackFrames>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaStackWalkHelper>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getEnumFrames2)(::windows::core::Vtable::as_raw(self), cpuid, phelper.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumStackFrames>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaStackWalker, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaStackWalker {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaStackWalker {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaStackWalker {}
impl ::core::fmt::Debug for IDiaStackWalker {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaStackWalker").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaStackWalker {
    type Vtable = IDiaStackWalker_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaStackWalker {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5485216b_a54c_469f_9670_52b24d5229bb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaStackWalker_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub getEnumFrames: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phelper: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub getEnumFrames2: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cpuid: CV_CPU_TYPE_e, phelper: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaStackWalker2(::windows::core::IUnknown);
impl IDiaStackWalker2 {
    pub unsafe fn getEnumFrames<'a, P0>(&self, phelper: P0) -> ::windows::core::Result<IDiaEnumStackFrames>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaStackWalkHelper>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.getEnumFrames)(::windows::core::Vtable::as_raw(self), phelper.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumStackFrames>(result__)
    }
    pub unsafe fn getEnumFrames2<'a, P0>(&self, cpuid: CV_CPU_TYPE_e, phelper: P0) -> ::windows::core::Result<IDiaEnumStackFrames>
    where
        P0: ::std::convert::Into<::windows::core::InParam<'a, IDiaStackWalkHelper>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.getEnumFrames2)(::windows::core::Vtable::as_raw(self), cpuid, phelper.into().abi(), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumStackFrames>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaStackWalker2, ::windows::core::IUnknown, IDiaStackWalker);
impl ::core::clone::Clone for IDiaStackWalker2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaStackWalker2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaStackWalker2 {}
impl ::core::fmt::Debug for IDiaStackWalker2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaStackWalker2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaStackWalker2 {
    type Vtable = IDiaStackWalker2_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaStackWalker2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7c185885_a015_4cac_9411_0f4fb39b1f3a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaStackWalker2_Vtbl {
    pub base__: IDiaStackWalker_Vtbl,
}
#[repr(transparent)]
pub struct IDiaSymbol(::windows::core::IUnknown);
impl IDiaSymbol {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol, ::windows::core::IUnknown);
impl ::core::clone::Clone for IDiaSymbol {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol {}
impl ::core::fmt::Debug for IDiaSymbol {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol {
    type Vtable = IDiaSymbol_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcb787b2f_bd6c_4635_ba52_933126bd2dcd);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub symIndexId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub symTag: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub name: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub lexicalParent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub classParent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub r#type: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub dataKind: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub locationType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub addressSection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub addressOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub relativeVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub virtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub registerId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub offset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub length: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub slot: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub volatileType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub constType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub unalignedType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub access: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub libraryName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub platform: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub language: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub editAndContinueEnabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub frontEndMajor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub frontEndMinor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub frontEndBuild: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub backEndMajor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub backEndMinor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub backEndBuild: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub sourceFileName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub unused: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub thunkOrdinal: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub thisAdjust: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub virtualBaseOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub r#virtual: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub intro: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub pure: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub callingConvention: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub value: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::Win32::System::Com::VARIANT>) -> ::windows::core::HRESULT,
    pub baseType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub token: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub timeStamp: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub guid: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub symbolsFileName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub reference: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub bitPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub arrayIndexType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub packed: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub constructor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub overloadedOperator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub nested: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasNestedTypes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasAssignmentOperator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasCastOperator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub scoped: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub virtualBaseClass: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub indirectVirtualBaseClass: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub virtualBasePointerOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub virtualTableShape: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub lexicalParentId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub classParentId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub typeId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub arrayIndexTypeId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub virtualTableShapeId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub code: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub function: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub managed: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub msil: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub virtualBaseDispIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub undecoratedName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub age: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub signature: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub compilerGenerated: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub addressTaken: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub rank: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub lowerBound: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub upperBound: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub lowerBoundId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub upperBoundId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub get_dataBytes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT,
    pub findChildren: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findChildrenEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findChildrenExByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, isect: u32, offset: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findChildrenExByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, va: u64, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findChildrenExByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub targetSection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub targetOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub targetRelativeVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub targetVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub machineType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub oemId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub oemSymbolId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub get_types: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ctypes: u32, pctypes: *mut u32, ptypes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub get_typeIds: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ctypeids: u32, pctypeids: *mut u32, pdwtypeids: *mut u32) -> ::windows::core::HRESULT,
    pub objectPointerType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub udtKind: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub get_undecoratedNameEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, undecorateoptions: u32, name: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub noReturn: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub customCallingConvention: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub noInline: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub optimizedCodeDebugInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub notReached: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub interruptReturn: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub farReturn: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isStatic: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasDebugInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isLTCG: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isDataAligned: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasSecurityChecks: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub compilerName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub hasAlloca: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasSetJump: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasLongJump: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasInlAsm: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasEH: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasSEH: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasEHa: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isNaked: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isAggregated: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isSplitted: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub container: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub inlSpec: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub noStackOrdering: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub virtualBaseTableType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub hasManagedCode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isHotpatchable: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isCVTCIL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isMSILNetmodule: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isCTypes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isStripped: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub frontEndQFE: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub backEndQFE: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub wasInlined: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub strictGSCheck: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isCxxReturnUdt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isConstructorVirtualBase: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub RValueReference: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub unmodifiedType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub framePointerPresent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isSafeBuffers: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub intrinsic: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub sealed: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hfaFloat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hfaDouble: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub liveRangeStartAddressSection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub liveRangeStartAddressOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub liveRangeStartRelativeVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub countLiveRanges: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub liveRangeLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub offsetInUdt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub paramBasePointerRegisterId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub localBasePointerRegisterId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub isLocationControlFlowDependent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub stride: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub numberOfRows: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub numberOfColumns: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub isMatrixRowMajor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub get_numericProperties: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cnt: u32, pcnt: *mut u32, pproperties: *mut u32) -> ::windows::core::HRESULT,
    pub get_modifierValues: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cnt: u32, pcnt: *mut u32, pmodifiers: *mut u16) -> ::windows::core::HRESULT,
    pub isReturnValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isOptimizedAway: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub builtInKind: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub registerType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub baseDataSlot: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub baseDataOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub textureSlot: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub samplerSlot: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub uavSlot: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub sizeInUdt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub memorySpaceKind: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub unmodifiedTypeId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub subTypeId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub subType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub numberOfModifiers: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub numberOfRegisterIndices: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub isHLSLData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isPointerToDataMember: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isPointerToMemberFunction: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isSingleInheritance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isMultipleInheritance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isVirtualInheritance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub restrictedType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isPointerBasedOnSymbolValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub baseSymbol: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub baseSymbolId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub objectFileName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub isAcceleratorGroupSharedLocal: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isAcceleratorPointerTagLiveRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isAcceleratorStubFunction: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub numberOfAcceleratorPointerTags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub isSdl: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isWinRTPointer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isRefUdt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isValueUdt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isInterfaceUdt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub findInlineFramesByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineFramesByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineFramesByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineeLines: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineeLinesByAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineeLinesByRVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rva: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findInlineeLinesByVA: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, va: u64, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findSymbolsForAcceleratorPointerTag: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, tagvalue: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub findSymbolsByRVAForAcceleratorPointerTag: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, tagvalue: u32, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub get_acceleratorPointerTags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cnt: u32, pcnt: *mut u32, ppointertags: *mut u32) -> ::windows::core::HRESULT,
    pub getSrcLineOnTypeDefn: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub isPGO: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub hasValidPGOCounts: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isOptimizedForSpeed: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub PGOEntryCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub PGOEdgeCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub PGODynamicInstructionCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub staticSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub finalLiveStaticSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub phaseName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub hasControlFlowCheck: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub constantExport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub dataExport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub privateExport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub noNameExport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub exportHasExplicitlyAssignedOrdinal: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub exportIsForwarder: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub ordinal: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub frameSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub exceptionHandlerAddressSection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub exceptionHandlerAddressOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub exceptionHandlerRelativeVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub exceptionHandlerVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
    pub findInputAssemblyFile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub characteristics: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub coffGroup: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub bindID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub bindSpace: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub bindSlot: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSymbol10(::windows::core::IUnknown);
impl IDiaSymbol10 {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.base__.bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isObjCClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isObjCCategory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isObjCProtocol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn inlinee(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.inlinee)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlineeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.inlineeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn noexcept(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.noexcept)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAbsoluteAddress(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasAbsoluteAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStaticMemberFunc(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isStaticMemberFunc)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSignRet(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isSignRet)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn coroutineKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.coroutineKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.associatedSymbolKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.associatedSymbolSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.associatedSymbolOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolRva(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.associatedSymbolRva)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolAddr(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.associatedSymbolAddr)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn framePadSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.framePadSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn framePadOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.framePadOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isRTCs(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isRTCs)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_sourceLink(&self, pcb: *mut u32, pb: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).get_sourceLink)(::windows::core::Vtable::as_raw(self), pb.len() as _, ::core::mem::transmute(pcb), ::core::mem::transmute(pb.as_ptr())).ok()
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol10, ::windows::core::IUnknown, IDiaSymbol, IDiaSymbol2, IDiaSymbol3, IDiaSymbol4, IDiaSymbol5, IDiaSymbol6, IDiaSymbol7, IDiaSymbol8, IDiaSymbol9);
impl ::core::clone::Clone for IDiaSymbol10 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol10 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol10 {}
impl ::core::fmt::Debug for IDiaSymbol10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol10").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol10 {
    type Vtable = IDiaSymbol10_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol10 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9034a70b_b0b7_4605_8a97_33772f3a7b8c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol10_Vtbl {
    pub base__: IDiaSymbol9_Vtbl,
    pub get_sourceLink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cb: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSymbol2(::windows::core::IUnknown);
impl IDiaSymbol2 {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isObjCClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isObjCCategory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isObjCProtocol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol2, ::windows::core::IUnknown, IDiaSymbol);
impl ::core::clone::Clone for IDiaSymbol2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol2 {}
impl ::core::fmt::Debug for IDiaSymbol2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol2 {
    type Vtable = IDiaSymbol2_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x611e86cd_b7d1_4546_8a15_070e2b07a427);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol2_Vtbl {
    pub base__: IDiaSymbol_Vtbl,
    pub isObjCClass: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isObjCCategory: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
    pub isObjCProtocol: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSymbol3(::windows::core::IUnknown);
impl IDiaSymbol3 {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isObjCClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isObjCCategory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isObjCProtocol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn inlinee(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).inlinee)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlineeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).inlineeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol3, ::windows::core::IUnknown, IDiaSymbol, IDiaSymbol2);
impl ::core::clone::Clone for IDiaSymbol3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol3 {}
impl ::core::fmt::Debug for IDiaSymbol3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol3").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol3 {
    type Vtable = IDiaSymbol3_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol3 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x99b665f7_c1b2_49d3_89b2_a384361acab5);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol3_Vtbl {
    pub base__: IDiaSymbol2_Vtbl,
    pub inlinee: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub inlineeId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSymbol4(::windows::core::IUnknown);
impl IDiaSymbol4 {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isObjCClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isObjCCategory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isObjCProtocol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn inlinee(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.inlinee)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlineeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.inlineeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn noexcept(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).noexcept)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol4, ::windows::core::IUnknown, IDiaSymbol, IDiaSymbol2, IDiaSymbol3);
impl ::core::clone::Clone for IDiaSymbol4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol4 {}
impl ::core::fmt::Debug for IDiaSymbol4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol4").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol4 {
    type Vtable = IDiaSymbol4_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol4 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbf6c88a7_e9d6_4346_99a1_d053de5a7808);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol4_Vtbl {
    pub base__: IDiaSymbol3_Vtbl,
    pub noexcept: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSymbol5(::windows::core::IUnknown);
impl IDiaSymbol5 {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isObjCClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isObjCCategory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isObjCProtocol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn inlinee(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.inlinee)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlineeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.inlineeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn noexcept(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.noexcept)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAbsoluteAddress(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).hasAbsoluteAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol5, ::windows::core::IUnknown, IDiaSymbol, IDiaSymbol2, IDiaSymbol3, IDiaSymbol4);
impl ::core::clone::Clone for IDiaSymbol5 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol5 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol5 {}
impl ::core::fmt::Debug for IDiaSymbol5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol5").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol5 {
    type Vtable = IDiaSymbol5_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol5 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xabe2de00_dc2d_4793_af9a_ef1d90832644);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol5_Vtbl {
    pub base__: IDiaSymbol4_Vtbl,
    pub hasAbsoluteAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSymbol6(::windows::core::IUnknown);
impl IDiaSymbol6 {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isObjCClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isObjCCategory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.isObjCProtocol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn inlinee(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.inlinee)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlineeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.inlineeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn noexcept(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.noexcept)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAbsoluteAddress(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.hasAbsoluteAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStaticMemberFunc(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isStaticMemberFunc)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol6, ::windows::core::IUnknown, IDiaSymbol, IDiaSymbol2, IDiaSymbol3, IDiaSymbol4, IDiaSymbol5);
impl ::core::clone::Clone for IDiaSymbol6 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol6 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol6 {}
impl ::core::fmt::Debug for IDiaSymbol6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol6").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol6 {
    type Vtable = IDiaSymbol6_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol6 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8133dad3_75fe_4234_ac7e_f8e7a1d3cbb3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol6_Vtbl {
    pub base__: IDiaSymbol5_Vtbl,
    pub isStaticMemberFunc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSymbol7(::windows::core::IUnknown);
impl IDiaSymbol7 {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isObjCClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isObjCCategory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.isObjCProtocol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn inlinee(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.inlinee)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlineeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.inlineeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn noexcept(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.noexcept)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAbsoluteAddress(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.hasAbsoluteAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStaticMemberFunc(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isStaticMemberFunc)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSignRet(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isSignRet)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol7, ::windows::core::IUnknown, IDiaSymbol, IDiaSymbol2, IDiaSymbol3, IDiaSymbol4, IDiaSymbol5, IDiaSymbol6);
impl ::core::clone::Clone for IDiaSymbol7 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol7 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol7 {}
impl ::core::fmt::Debug for IDiaSymbol7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol7").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol7 {
    type Vtable = IDiaSymbol7_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol7 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x64ce6cd5_7315_4328_86d6_10e303e010b4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol7_Vtbl {
    pub base__: IDiaSymbol6_Vtbl,
    pub isSignRet: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSymbol8(::windows::core::IUnknown);
impl IDiaSymbol8 {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isObjCClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isObjCCategory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.isObjCProtocol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn inlinee(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.inlinee)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlineeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.inlineeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn noexcept(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.noexcept)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAbsoluteAddress(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.hasAbsoluteAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStaticMemberFunc(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isStaticMemberFunc)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSignRet(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.isSignRet)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn coroutineKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).coroutineKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).associatedSymbolKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).associatedSymbolSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).associatedSymbolOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolRva(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).associatedSymbolRva)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolAddr(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).associatedSymbolAddr)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol8, ::windows::core::IUnknown, IDiaSymbol, IDiaSymbol2, IDiaSymbol3, IDiaSymbol4, IDiaSymbol5, IDiaSymbol6, IDiaSymbol7);
impl ::core::clone::Clone for IDiaSymbol8 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol8 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol8 {}
impl ::core::fmt::Debug for IDiaSymbol8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol8").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol8 {
    type Vtable = IDiaSymbol8_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol8 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7f2e041f_1294_41bd_b83a_e715972d2ce3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol8_Vtbl {
    pub base__: IDiaSymbol7_Vtbl,
    pub coroutineKind: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub associatedSymbolKind: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub associatedSymbolSection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub associatedSymbolOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub associatedSymbolRva: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub associatedSymbolAddr: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaSymbol9(::windows::core::IUnknown);
impl IDiaSymbol9 {
    pub unsafe fn symIndexId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.symIndexId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn symTag(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.symTag)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.lexicalParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn classParent(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.classParent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn r#type(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.r#type)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn dataKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.dataKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn locationType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.locationType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.addressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn addressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.addressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.relativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.virtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn registerId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.registerId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn offset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.offset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn length(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.length)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn slot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.slot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.volatileType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.constType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.unalignedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn access(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.access)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.libraryName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn platform(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.platform)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn language(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.language)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.editAndContinueEnabled)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.frontEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.frontEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frontEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.frontEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMajor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.backEndMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndMinor(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.backEndMinor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndBuild(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.backEndBuild)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.sourceFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.unused)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn thunkOrdinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.thunkOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn thisAdjust(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.thisAdjust)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualBaseOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.virtualBaseOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.r#virtual)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.intro)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.pure)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn callingConvention(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.callingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.value)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::VARIANT>(result__)
    }
    pub unsafe fn baseType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.baseType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn token(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.token)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn timeStamp(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.timeStamp)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn guid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.guid)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::GUID>(result__)
    }
    pub unsafe fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.symbolsFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.reference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn count(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bitPosition(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.bitPosition)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.arrayIndexType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.packed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.constructor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.overloadedOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.nested)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasNestedTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasAssignmentOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasCastOperator)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.scoped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.virtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.indirectVirtualBaseClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.virtualBasePointerOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.virtualTableShape)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lexicalParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.lexicalParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn classParentId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.classParentId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn typeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.typeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.arrayIndexTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn virtualTableShapeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.virtualTableShapeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.code)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.function)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.managed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.msil)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.virtualBaseDispIndex)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.undecoratedName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn age(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.age)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn signature(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.signature)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.compilerGenerated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.addressTaken)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn rank(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.rank)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.lowerBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.upperBound)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn lowerBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.lowerBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn upperBoundId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.upperBoundId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_dataBytes(&self, pcbdata: *mut u32, pbdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.get_dataBytes)(::windows::core::Vtable::as_raw(self), pbdata.len() as _, ::core::mem::transmute(pcbdata), ::core::mem::transmute(pbdata.as_ptr())).ok()
    }
    pub unsafe fn findChildren<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findChildren)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenEx<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findChildrenEx)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByAddr<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findChildrenExByAddr)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findChildrenExByVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findChildrenExByRVA<'a, P0>(&self, symtag: SymTag, name: P0, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>
    where
        P0: ::std::convert::Into<::windows::core::PCWSTR>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findChildrenExByRVA)(::windows::core::Vtable::as_raw(self), symtag, name.into(), compareflags, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn targetSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.targetSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.targetOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.targetRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn targetVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.targetVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn machineType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.machineType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.oemId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn oemSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.oemSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_types(&self, pctypes: *mut u32, ptypes: &mut [::core::option::Option<IDiaSymbol>]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.get_types)(::windows::core::Vtable::as_raw(self), ptypes.len() as _, ::core::mem::transmute(pctypes), ::core::mem::transmute(ptypes.as_ptr())).ok()
    }
    pub unsafe fn get_typeIds(&self, pctypeids: *mut u32, pdwtypeids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.get_typeIds)(::windows::core::Vtable::as_raw(self), pdwtypeids.len() as _, ::core::mem::transmute(pctypeids), ::core::mem::transmute(pdwtypeids.as_ptr())).ok()
    }
    pub unsafe fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.objectPointerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn udtKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.udtKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.get_undecoratedNameEx)(::windows::core::Vtable::as_raw(self), undecorateoptions, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.noReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.customCallingConvention)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.noInline)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.optimizedCodeDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.notReached)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.interruptReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.farReturn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isStatic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasDebugInfo)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isLTCG)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isDataAligned)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasSecurityChecks)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.compilerName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasAlloca)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasSetJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasLongJump)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasInlAsm)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasSEH)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasEHa)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isNaked)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isAggregated)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isSplitted)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn container(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.container)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.inlSpec)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.noStackOrdering)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.virtualBaseTableType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasManagedCode)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isHotpatchable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isCVTCIL)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isMSILNetmodule)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isCTypes)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isStripped)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn frontEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.frontEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn backEndQFE(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.backEndQFE)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.wasInlined)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.strictGSCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isCxxReturnUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isConstructorVirtualBase)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.RValueReference)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.unmodifiedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.framePointerPresent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isSafeBuffers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.intrinsic)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.sealed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hfaFloat)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hfaDouble)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.liveRangeStartAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.liveRangeStartAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.liveRangeStartRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn countLiveRanges(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.countLiveRanges)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn liveRangeLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.liveRangeLength)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn offsetInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.offsetInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.paramBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.localBasePointerRegisterId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isLocationControlFlowDependent)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn stride(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.stride)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRows(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.numberOfRows)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfColumns(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.numberOfColumns)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isMatrixRowMajor)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn get_numericProperties(&self, pcnt: *mut u32, pproperties: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.get_numericProperties)(::windows::core::Vtable::as_raw(self), pproperties.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pproperties.as_ptr())).ok()
    }
    pub unsafe fn get_modifierValues(&self, pcnt: *mut u32, pmodifiers: &mut [u16]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.get_modifierValues)(::windows::core::Vtable::as_raw(self), pmodifiers.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(pmodifiers.as_ptr())).ok()
    }
    pub unsafe fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isReturnValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isOptimizedAway)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn builtInKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.builtInKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn registerType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.registerType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.baseDataSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn baseDataOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.baseDataOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn textureSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.textureSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn samplerSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.samplerSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn uavSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.uavSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn sizeInUdt(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.sizeInUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn memorySpaceKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.memorySpaceKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.unmodifiedTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subTypeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.subTypeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn subType(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.subType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn numberOfModifiers(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.numberOfModifiers)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.numberOfRegisterIndices)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isHLSLData)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isPointerToDataMember)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isPointerToMemberFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isSingleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isMultipleInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isVirtualInheritance)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.restrictedType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isPointerBasedOnSymbolValue)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.baseSymbol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn baseSymbolId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.baseSymbolId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.objectFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isAcceleratorGroupSharedLocal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isAcceleratorPointerTagLiveRange)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isAcceleratorStubFunction)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.numberOfAcceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isSdl)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isWinRTPointer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isRefUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isValueUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isInterfaceUdt)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findInlineFramesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findInlineFramesByRVA)(::windows::core::Vtable::as_raw(self), rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findInlineFramesByVA)(::windows::core::Vtable::as_raw(self), va, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findInlineeLines)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findInlineeLinesByAddr)(::windows::core::Vtable::as_raw(self), isect, offset, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findInlineeLinesByRVA)(::windows::core::Vtable::as_raw(self), rva, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findInlineeLinesByVA)(::windows::core::Vtable::as_raw(self), va, length, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumLineNumbers>(result__)
    }
    pub unsafe fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findSymbolsForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findSymbolsByRVAForAcceleratorPointerTag)(::windows::core::Vtable::as_raw(self), tagvalue, rva, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaEnumSymbols>(result__)
    }
    pub unsafe fn get_acceleratorPointerTags(&self, pcnt: *mut u32, ppointertags: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.get_acceleratorPointerTags)(::windows::core::Vtable::as_raw(self), ppointertags.len() as _, ::core::mem::transmute(pcnt), ::core::mem::transmute(ppointertags.as_ptr())).ok()
    }
    pub unsafe fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.getSrcLineOnTypeDefn)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaLineNumber>(result__)
    }
    pub unsafe fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isPGO)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasValidPGOCounts)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.isOptimizedForSpeed)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn PGOEntryCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.PGOEntryCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGOEdgeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.PGOEdgeCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.PGODynamicInstructionCount)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn staticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.staticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.finalLiveStaticSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.phaseName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.hasControlFlowCheck)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.constantExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.dataExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.privateExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.noNameExport)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.exportHasExplicitlyAssignedOrdinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.exportIsForwarder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn ordinal(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.ordinal)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn frameSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.frameSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.exceptionHandlerAddressSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.exceptionHandlerAddressOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.exceptionHandlerRelativeVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.exceptionHandlerVirtualAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.findInputAssemblyFile)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaInputAssemblyFile>(result__)
    }
    pub unsafe fn characteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.characteristics)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.coffGroup)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn bindID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.bindID)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSpace(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.bindSpace)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn bindSlot(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.base__.bindSlot)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isObjCClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isObjCCategory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.base__.isObjCProtocol)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn inlinee(&self) -> ::windows::core::Result<IDiaSymbol> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.inlinee)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<IDiaSymbol>(result__)
    }
    pub unsafe fn inlineeId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.base__.inlineeId)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn noexcept(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.noexcept)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn hasAbsoluteAddress(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.hasAbsoluteAddress)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isStaticMemberFunc(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.isStaticMemberFunc)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn isSignRet(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.isSignRet)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
    pub unsafe fn coroutineKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.coroutineKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolKind(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.associatedSymbolKind)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolSection(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.associatedSymbolSection)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.associatedSymbolOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolRva(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.associatedSymbolRva)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn associatedSymbolAddr(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.associatedSymbolAddr)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u64>(result__)
    }
    pub unsafe fn framePadSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).framePadSize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn framePadOffset(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).framePadOffset)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<u32>(result__)
    }
    pub unsafe fn isRTCs(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).isRTCs)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::Foundation::BOOL>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaSymbol9, ::windows::core::IUnknown, IDiaSymbol, IDiaSymbol2, IDiaSymbol3, IDiaSymbol4, IDiaSymbol5, IDiaSymbol6, IDiaSymbol7, IDiaSymbol8);
impl ::core::clone::Clone for IDiaSymbol9 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaSymbol9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaSymbol9 {}
impl ::core::fmt::Debug for IDiaSymbol9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaSymbol9").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaSymbol9 {
    type Vtable = IDiaSymbol9_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaSymbol9 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa89e5969_92a1_4f8a_b704_00121c37abbb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaSymbol9_Vtbl {
    pub base__: IDiaSymbol8_Vtbl,
    pub framePadSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub framePadOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT,
    pub isRTCs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct IDiaTable(::windows::core::IUnknown);
impl IDiaTable {
    pub unsafe fn Next(&self, rgelt: &mut [::core::option::Option<::windows::core::IUnknown>], pceltfetched: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Next)(::windows::core::Vtable::as_raw(self), rgelt.len() as _, ::core::mem::transmute(rgelt.as_ptr()), ::core::mem::transmute(pceltfetched.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Skip(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Skip)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Reset)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<::windows::Win32::System::Com::IEnumUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::IEnumUnknown>(result__)
    }
    pub unsafe fn Skip2(&self, celt: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Skip2)(::windows::core::Vtable::as_raw(self), celt).ok()
    }
    pub unsafe fn Reset2(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).Reset2)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Clone2(&self) -> ::windows::core::Result<::windows::Win32::System::Com::IEnumUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Clone2)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::Win32::System::Com::IEnumUnknown>(result__)
    }
    pub unsafe fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self)._NewEnum)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
    pub unsafe fn name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).name)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::BSTR>(result__)
    }
    pub unsafe fn Count(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Count)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<i32>(result__)
    }
    pub unsafe fn Item(&self, index: u32) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).Item)(::windows::core::Vtable::as_raw(self), index, ::core::mem::transmute(result__.as_mut_ptr())).from_abi::<::windows::core::IUnknown>(result__)
    }
}
::windows::core::interface_hierarchy!(IDiaTable, ::windows::core::IUnknown, ::windows::Win32::System::Com::IEnumUnknown);
impl ::core::clone::Clone for IDiaTable {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::cmp::PartialEq for IDiaTable {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDiaTable {}
impl ::core::fmt::Debug for IDiaTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDiaTable").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Vtable for IDiaTable {
    type Vtable = IDiaTable_Vtbl;
}
unsafe impl ::windows::core::Interface for IDiaTable {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a59fb77_abac_469b_a30b_9ecc85bfef14);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDiaTable_Vtbl {
    pub base__: ::windows::Win32::System::Com::IEnumUnknown_Vtbl,
    pub Skip2: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT,
    pub Reset2: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone2: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub _NewEnum: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub name: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub Count: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT,
    pub Item: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, element: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
pub const DiaSource: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe6756135_1e65_4d17_8576_610761398c3c);
pub const DiaSourceAlt: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x91904831_49ca_4766_b95c_25397e2dd6dc);
pub const DiaStackWalker: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xce4a85db_5768_475b_a4e1_c0bca2112a6b);
pub const E_PDB_ACCESS_DENIED: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340208i32);
pub const E_PDB_CORRUPT: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340210i32);
pub const E_PDB_DBG_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340205i32);
pub const E_PDB_DEBUG_INFO_NOT_IN_PDB: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340201i32);
pub const E_PDB_FILE_SYSTEM: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340220i32);
pub const E_PDB_FORMAT: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340212i32);
pub const E_PDB_ILLEGAL_TYPE_EDIT: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340207i32);
pub const E_PDB_INVALID_AGE: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340217i32);
pub const E_PDB_INVALID_EXECUTABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340206i32);
pub const E_PDB_INVALID_EXE_TIMESTAMP: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340203i32);
pub const E_PDB_INVALID_SIG: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340218i32);
pub const E_PDB_LIMIT: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340211i32);
pub const E_PDB_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340219i32);
pub const E_PDB_NOT_IMPLEMENTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340214i32);
pub const E_PDB_NO_DEBUG_INFO: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340204i32);
pub const E_PDB_OBJECT_DISPOSED: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340198i32);
pub const E_PDB_OK: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340223i32);
pub const E_PDB_OUT_OF_MEMORY: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340221i32);
pub const E_PDB_OUT_OF_TI: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340215i32);
pub const E_PDB_PRECOMP_REQUIRED: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340216i32);
pub const E_PDB_RESERVED: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340202i32);
pub const E_PDB_SYMSRV_BAD_CACHE_PATH: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340200i32);
pub const E_PDB_SYMSRV_CACHE_FULL: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340199i32);
pub const E_PDB_TI16: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340209i32);
pub const E_PDB_USAGE: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340222i32);
pub const E_PDB_V1_PDB: ::windows::core::HRESULT = ::windows::core::HRESULT(-2140340213i32);
pub const NAMEHASH_BUILD_COMPLETE: i32 = 3i32;
pub const NAMEHASH_BUILD_ERROR: i32 = 4i32;
pub const NAMEHASH_BUILD_FAIL_TO_OPEN_MOD: i32 = 5i32;
pub const NAMEHASH_BUILD_OOM: i32 = 4i32;
pub const NAMEHASH_BUILD_PAUSE: i32 = 1i32;
pub const NAMEHASH_BUILD_RESUME: i32 = 2i32;
pub const NAMEHASH_BUILD_START: i32 = 0i32;
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct BasicType(pub i32);
pub const btNoType: BasicType = BasicType(0i32);
pub const btVoid: BasicType = BasicType(1i32);
pub const btChar: BasicType = BasicType(2i32);
pub const btWChar: BasicType = BasicType(3i32);
pub const btInt: BasicType = BasicType(6i32);
pub const btUInt: BasicType = BasicType(7i32);
pub const btFloat: BasicType = BasicType(8i32);
pub const btBCD: BasicType = BasicType(9i32);
pub const btBool: BasicType = BasicType(10i32);
pub const btLong: BasicType = BasicType(13i32);
pub const btULong: BasicType = BasicType(14i32);
pub const btCurrency: BasicType = BasicType(25i32);
pub const btDate: BasicType = BasicType(26i32);
pub const btVariant: BasicType = BasicType(27i32);
pub const btComplex: BasicType = BasicType(28i32);
pub const btBit: BasicType = BasicType(29i32);
pub const btBSTR: BasicType = BasicType(30i32);
pub const btHresult: BasicType = BasicType(31i32);
pub const btChar16: BasicType = BasicType(32i32);
pub const btChar32: BasicType = BasicType(33i32);
pub const btChar8: BasicType = BasicType(34i32);
impl ::core::marker::Copy for BasicType {}
impl ::core::clone::Clone for BasicType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for BasicType {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for BasicType {
    type Abi = Self;
}
impl ::core::fmt::Debug for BasicType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BasicType").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_AssociationKind_e(pub i32);
pub const CV_ASSOCIATIONKIND_NONE: CV_AssociationKind_e = CV_AssociationKind_e(0i32);
pub const CV_ASSOCIATIONKIND_COROUTINE: CV_AssociationKind_e = CV_AssociationKind_e(1i32);
impl ::core::marker::Copy for CV_AssociationKind_e {}
impl ::core::clone::Clone for CV_AssociationKind_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_AssociationKind_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_AssociationKind_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_AssociationKind_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_AssociationKind_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_CFL_LANG(pub i32);
pub const CV_CFL_C: CV_CFL_LANG = CV_CFL_LANG(0i32);
pub const CV_CFL_CXX: CV_CFL_LANG = CV_CFL_LANG(1i32);
pub const CV_CFL_FORTRAN: CV_CFL_LANG = CV_CFL_LANG(2i32);
pub const CV_CFL_MASM: CV_CFL_LANG = CV_CFL_LANG(3i32);
pub const CV_CFL_PASCAL: CV_CFL_LANG = CV_CFL_LANG(4i32);
pub const CV_CFL_BASIC: CV_CFL_LANG = CV_CFL_LANG(5i32);
pub const CV_CFL_COBOL: CV_CFL_LANG = CV_CFL_LANG(6i32);
pub const CV_CFL_LINK: CV_CFL_LANG = CV_CFL_LANG(7i32);
pub const CV_CFL_CVTRES: CV_CFL_LANG = CV_CFL_LANG(8i32);
pub const CV_CFL_CVTPGD: CV_CFL_LANG = CV_CFL_LANG(9i32);
pub const CV_CFL_CSHARP: CV_CFL_LANG = CV_CFL_LANG(10i32);
pub const CV_CFL_VB: CV_CFL_LANG = CV_CFL_LANG(11i32);
pub const CV_CFL_ILASM: CV_CFL_LANG = CV_CFL_LANG(12i32);
pub const CV_CFL_JAVA: CV_CFL_LANG = CV_CFL_LANG(13i32);
pub const CV_CFL_JSCRIPT: CV_CFL_LANG = CV_CFL_LANG(14i32);
pub const CV_CFL_MSIL: CV_CFL_LANG = CV_CFL_LANG(15i32);
pub const CV_CFL_HLSL: CV_CFL_LANG = CV_CFL_LANG(16i32);
pub const CV_CFL_OBJC: CV_CFL_LANG = CV_CFL_LANG(17i32);
pub const CV_CFL_OBJCXX: CV_CFL_LANG = CV_CFL_LANG(18i32);
pub const CV_CFL_SWIFT: CV_CFL_LANG = CV_CFL_LANG(19i32);
pub const CV_CFL_ALIASOBJ: CV_CFL_LANG = CV_CFL_LANG(20i32);
pub const CV_CFL_RUST: CV_CFL_LANG = CV_CFL_LANG(21i32);
impl ::core::marker::Copy for CV_CFL_LANG {}
impl ::core::clone::Clone for CV_CFL_LANG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_CFL_LANG {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_CFL_LANG {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_CFL_LANG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_CFL_LANG").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_CPU_TYPE_e(pub i32);
pub const CV_CFL_8080: CV_CPU_TYPE_e = CV_CPU_TYPE_e(0i32);
pub const CV_CFL_8086: CV_CPU_TYPE_e = CV_CPU_TYPE_e(1i32);
pub const CV_CFL_80286: CV_CPU_TYPE_e = CV_CPU_TYPE_e(2i32);
pub const CV_CFL_80386: CV_CPU_TYPE_e = CV_CPU_TYPE_e(3i32);
pub const CV_CFL_80486: CV_CPU_TYPE_e = CV_CPU_TYPE_e(4i32);
pub const CV_CFL_PENTIUM: CV_CPU_TYPE_e = CV_CPU_TYPE_e(5i32);
pub const CV_CFL_PENTIUMII: CV_CPU_TYPE_e = CV_CPU_TYPE_e(6i32);
pub const CV_CFL_PENTIUMPRO: CV_CPU_TYPE_e = CV_CPU_TYPE_e(6i32);
pub const CV_CFL_PENTIUMIII: CV_CPU_TYPE_e = CV_CPU_TYPE_e(7i32);
pub const CV_CFL_MIPS: CV_CPU_TYPE_e = CV_CPU_TYPE_e(16i32);
pub const CV_CFL_MIPSR4000: CV_CPU_TYPE_e = CV_CPU_TYPE_e(16i32);
pub const CV_CFL_MIPS16: CV_CPU_TYPE_e = CV_CPU_TYPE_e(17i32);
pub const CV_CFL_MIPS32: CV_CPU_TYPE_e = CV_CPU_TYPE_e(18i32);
pub const CV_CFL_MIPS64: CV_CPU_TYPE_e = CV_CPU_TYPE_e(19i32);
pub const CV_CFL_MIPSI: CV_CPU_TYPE_e = CV_CPU_TYPE_e(20i32);
pub const CV_CFL_MIPSII: CV_CPU_TYPE_e = CV_CPU_TYPE_e(21i32);
pub const CV_CFL_MIPSIII: CV_CPU_TYPE_e = CV_CPU_TYPE_e(22i32);
pub const CV_CFL_MIPSIV: CV_CPU_TYPE_e = CV_CPU_TYPE_e(23i32);
pub const CV_CFL_MIPSV: CV_CPU_TYPE_e = CV_CPU_TYPE_e(24i32);
pub const CV_CFL_M68000: CV_CPU_TYPE_e = CV_CPU_TYPE_e(32i32);
pub const CV_CFL_M68010: CV_CPU_TYPE_e = CV_CPU_TYPE_e(33i32);
pub const CV_CFL_M68020: CV_CPU_TYPE_e = CV_CPU_TYPE_e(34i32);
pub const CV_CFL_M68030: CV_CPU_TYPE_e = CV_CPU_TYPE_e(35i32);
pub const CV_CFL_M68040: CV_CPU_TYPE_e = CV_CPU_TYPE_e(36i32);
pub const CV_CFL_ALPHA: CV_CPU_TYPE_e = CV_CPU_TYPE_e(48i32);
pub const CV_CFL_ALPHA_21064: CV_CPU_TYPE_e = CV_CPU_TYPE_e(48i32);
pub const CV_CFL_ALPHA_21164: CV_CPU_TYPE_e = CV_CPU_TYPE_e(49i32);
pub const CV_CFL_ALPHA_21164A: CV_CPU_TYPE_e = CV_CPU_TYPE_e(50i32);
pub const CV_CFL_ALPHA_21264: CV_CPU_TYPE_e = CV_CPU_TYPE_e(51i32);
pub const CV_CFL_ALPHA_21364: CV_CPU_TYPE_e = CV_CPU_TYPE_e(52i32);
pub const CV_CFL_PPC601: CV_CPU_TYPE_e = CV_CPU_TYPE_e(64i32);
pub const CV_CFL_PPC603: CV_CPU_TYPE_e = CV_CPU_TYPE_e(65i32);
pub const CV_CFL_PPC604: CV_CPU_TYPE_e = CV_CPU_TYPE_e(66i32);
pub const CV_CFL_PPC620: CV_CPU_TYPE_e = CV_CPU_TYPE_e(67i32);
pub const CV_CFL_PPCFP: CV_CPU_TYPE_e = CV_CPU_TYPE_e(68i32);
pub const CV_CFL_PPCBE: CV_CPU_TYPE_e = CV_CPU_TYPE_e(69i32);
pub const CV_CFL_SH3: CV_CPU_TYPE_e = CV_CPU_TYPE_e(80i32);
pub const CV_CFL_SH3E: CV_CPU_TYPE_e = CV_CPU_TYPE_e(81i32);
pub const CV_CFL_SH3DSP: CV_CPU_TYPE_e = CV_CPU_TYPE_e(82i32);
pub const CV_CFL_SH4: CV_CPU_TYPE_e = CV_CPU_TYPE_e(83i32);
pub const CV_CFL_SHMEDIA: CV_CPU_TYPE_e = CV_CPU_TYPE_e(84i32);
pub const CV_CFL_ARM3: CV_CPU_TYPE_e = CV_CPU_TYPE_e(96i32);
pub const CV_CFL_ARM4: CV_CPU_TYPE_e = CV_CPU_TYPE_e(97i32);
pub const CV_CFL_ARM4T: CV_CPU_TYPE_e = CV_CPU_TYPE_e(98i32);
pub const CV_CFL_ARM5: CV_CPU_TYPE_e = CV_CPU_TYPE_e(99i32);
pub const CV_CFL_ARM5T: CV_CPU_TYPE_e = CV_CPU_TYPE_e(100i32);
pub const CV_CFL_ARM6: CV_CPU_TYPE_e = CV_CPU_TYPE_e(101i32);
pub const CV_CFL_ARM_XMAC: CV_CPU_TYPE_e = CV_CPU_TYPE_e(102i32);
pub const CV_CFL_ARM_WMMX: CV_CPU_TYPE_e = CV_CPU_TYPE_e(103i32);
pub const CV_CFL_ARM7: CV_CPU_TYPE_e = CV_CPU_TYPE_e(104i32);
pub const CV_CFL_OMNI: CV_CPU_TYPE_e = CV_CPU_TYPE_e(112i32);
pub const CV_CFL_IA64: CV_CPU_TYPE_e = CV_CPU_TYPE_e(128i32);
pub const CV_CFL_IA64_1: CV_CPU_TYPE_e = CV_CPU_TYPE_e(128i32);
pub const CV_CFL_IA64_2: CV_CPU_TYPE_e = CV_CPU_TYPE_e(129i32);
pub const CV_CFL_CEE: CV_CPU_TYPE_e = CV_CPU_TYPE_e(144i32);
pub const CV_CFL_AM33: CV_CPU_TYPE_e = CV_CPU_TYPE_e(160i32);
pub const CV_CFL_M32R: CV_CPU_TYPE_e = CV_CPU_TYPE_e(176i32);
pub const CV_CFL_TRICORE: CV_CPU_TYPE_e = CV_CPU_TYPE_e(192i32);
pub const CV_CFL_X64: CV_CPU_TYPE_e = CV_CPU_TYPE_e(208i32);
pub const CV_CFL_AMD64: CV_CPU_TYPE_e = CV_CPU_TYPE_e(208i32);
pub const CV_CFL_EBC: CV_CPU_TYPE_e = CV_CPU_TYPE_e(224i32);
pub const CV_CFL_THUMB: CV_CPU_TYPE_e = CV_CPU_TYPE_e(240i32);
pub const CV_CFL_ARMNT: CV_CPU_TYPE_e = CV_CPU_TYPE_e(244i32);
pub const CV_CFL_ARM64: CV_CPU_TYPE_e = CV_CPU_TYPE_e(246i32);
pub const CV_CFL_HYBRID_X86_ARM64: CV_CPU_TYPE_e = CV_CPU_TYPE_e(247i32);
pub const CV_CFL_ARM64EC: CV_CPU_TYPE_e = CV_CPU_TYPE_e(248i32);
pub const CV_CFL_ARM64X: CV_CPU_TYPE_e = CV_CPU_TYPE_e(249i32);
pub const CV_CFL_UNKNOWN: CV_CPU_TYPE_e = CV_CPU_TYPE_e(255i32);
pub const CV_CFL_D3D11_SHADER: CV_CPU_TYPE_e = CV_CPU_TYPE_e(256i32);
impl ::core::marker::Copy for CV_CPU_TYPE_e {}
impl ::core::clone::Clone for CV_CPU_TYPE_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_CPU_TYPE_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_CPU_TYPE_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_CPU_TYPE_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_CPU_TYPE_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_CoroutineKind_e(pub i32);
pub const CV_COROUTINEKIND_NONE: CV_CoroutineKind_e = CV_CoroutineKind_e(0i32);
pub const CV_COROUTINEKIND_PRIMARY: CV_CoroutineKind_e = CV_CoroutineKind_e(1i32);
pub const CV_COROUTINEKIND_INIT: CV_CoroutineKind_e = CV_CoroutineKind_e(2i32);
pub const CV_COROUTINEKIND_RESUME: CV_CoroutineKind_e = CV_CoroutineKind_e(3i32);
pub const CV_COROUTINEKIND_DESTROY: CV_CoroutineKind_e = CV_CoroutineKind_e(4i32);
impl ::core::marker::Copy for CV_CoroutineKind_e {}
impl ::core::clone::Clone for CV_CoroutineKind_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_CoroutineKind_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_CoroutineKind_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_CoroutineKind_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_CoroutineKind_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_HLSLMemorySpace_e(pub i32);
pub const CV_HLSL_MEMSPACE_DATA: CV_HLSLMemorySpace_e = CV_HLSLMemorySpace_e(0i32);
pub const CV_HLSL_MEMSPACE_SAMPLER: CV_HLSLMemorySpace_e = CV_HLSLMemorySpace_e(1i32);
pub const CV_HLSL_MEMSPACE_RESOURCE: CV_HLSLMemorySpace_e = CV_HLSLMemorySpace_e(2i32);
pub const CV_HLSL_MEMSPACE_RWRESOURCE: CV_HLSLMemorySpace_e = CV_HLSLMemorySpace_e(3i32);
pub const CV_HLSL_MEMSPACE_MAX: CV_HLSLMemorySpace_e = CV_HLSLMemorySpace_e(15i32);
impl ::core::marker::Copy for CV_HLSLMemorySpace_e {}
impl ::core::clone::Clone for CV_HLSLMemorySpace_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_HLSLMemorySpace_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_HLSLMemorySpace_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_HLSLMemorySpace_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_HLSLMemorySpace_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_HLSLREG_e(pub i32);
pub const CV_HLSLREG_TEMP: CV_HLSLREG_e = CV_HLSLREG_e(0i32);
pub const CV_HLSLREG_INPUT: CV_HLSLREG_e = CV_HLSLREG_e(1i32);
pub const CV_HLSLREG_OUTPUT: CV_HLSLREG_e = CV_HLSLREG_e(2i32);
pub const CV_HLSLREG_INDEXABLE_TEMP: CV_HLSLREG_e = CV_HLSLREG_e(3i32);
pub const CV_HLSLREG_IMMEDIATE32: CV_HLSLREG_e = CV_HLSLREG_e(4i32);
pub const CV_HLSLREG_IMMEDIATE64: CV_HLSLREG_e = CV_HLSLREG_e(5i32);
pub const CV_HLSLREG_SAMPLER: CV_HLSLREG_e = CV_HLSLREG_e(6i32);
pub const CV_HLSLREG_RESOURCE: CV_HLSLREG_e = CV_HLSLREG_e(7i32);
pub const CV_HLSLREG_CONSTANT_BUFFER: CV_HLSLREG_e = CV_HLSLREG_e(8i32);
pub const CV_HLSLREG_IMMEDIATE_CONSTANT_BUFFER: CV_HLSLREG_e = CV_HLSLREG_e(9i32);
pub const CV_HLSLREG_LABEL: CV_HLSLREG_e = CV_HLSLREG_e(10i32);
pub const CV_HLSLREG_INPUT_PRIMITIVEID: CV_HLSLREG_e = CV_HLSLREG_e(11i32);
pub const CV_HLSLREG_OUTPUT_DEPTH: CV_HLSLREG_e = CV_HLSLREG_e(12i32);
pub const CV_HLSLREG_NULL: CV_HLSLREG_e = CV_HLSLREG_e(13i32);
pub const CV_HLSLREG_RASTERIZER: CV_HLSLREG_e = CV_HLSLREG_e(14i32);
pub const CV_HLSLREG_OUTPUT_COVERAGE_MASK: CV_HLSLREG_e = CV_HLSLREG_e(15i32);
pub const CV_HLSLREG_STREAM: CV_HLSLREG_e = CV_HLSLREG_e(16i32);
pub const CV_HLSLREG_FUNCTION_BODY: CV_HLSLREG_e = CV_HLSLREG_e(17i32);
pub const CV_HLSLREG_FUNCTION_TABLE: CV_HLSLREG_e = CV_HLSLREG_e(18i32);
pub const CV_HLSLREG_INTERFACE: CV_HLSLREG_e = CV_HLSLREG_e(19i32);
pub const CV_HLSLREG_FUNCTION_INPUT: CV_HLSLREG_e = CV_HLSLREG_e(20i32);
pub const CV_HLSLREG_FUNCTION_OUTPUT: CV_HLSLREG_e = CV_HLSLREG_e(21i32);
pub const CV_HLSLREG_OUTPUT_CONTROL_POINT_ID: CV_HLSLREG_e = CV_HLSLREG_e(22i32);
pub const CV_HLSLREG_INPUT_FORK_INSTANCE_ID: CV_HLSLREG_e = CV_HLSLREG_e(23i32);
pub const CV_HLSLREG_INPUT_JOIN_INSTANCE_ID: CV_HLSLREG_e = CV_HLSLREG_e(24i32);
pub const CV_HLSLREG_INPUT_CONTROL_POINT: CV_HLSLREG_e = CV_HLSLREG_e(25i32);
pub const CV_HLSLREG_OUTPUT_CONTROL_POINT: CV_HLSLREG_e = CV_HLSLREG_e(26i32);
pub const CV_HLSLREG_INPUT_PATCH_CONSTANT: CV_HLSLREG_e = CV_HLSLREG_e(27i32);
pub const CV_HLSLREG_INPUT_DOMAIN_POINT: CV_HLSLREG_e = CV_HLSLREG_e(28i32);
pub const CV_HLSLREG_THIS_POINTER: CV_HLSLREG_e = CV_HLSLREG_e(29i32);
pub const CV_HLSLREG_UNORDERED_ACCESS_VIEW: CV_HLSLREG_e = CV_HLSLREG_e(30i32);
pub const CV_HLSLREG_THREAD_GROUP_SHARED_MEMORY: CV_HLSLREG_e = CV_HLSLREG_e(31i32);
pub const CV_HLSLREG_INPUT_THREAD_ID: CV_HLSLREG_e = CV_HLSLREG_e(32i32);
pub const CV_HLSLREG_INPUT_THREAD_GROUP_ID: CV_HLSLREG_e = CV_HLSLREG_e(33i32);
pub const CV_HLSLREG_INPUT_THREAD_ID_IN_GROUP: CV_HLSLREG_e = CV_HLSLREG_e(34i32);
pub const CV_HLSLREG_INPUT_COVERAGE_MASK: CV_HLSLREG_e = CV_HLSLREG_e(35i32);
pub const CV_HLSLREG_INPUT_THREAD_ID_IN_GROUP_FLATTENED: CV_HLSLREG_e = CV_HLSLREG_e(36i32);
pub const CV_HLSLREG_INPUT_GS_INSTANCE_ID: CV_HLSLREG_e = CV_HLSLREG_e(37i32);
pub const CV_HLSLREG_OUTPUT_DEPTH_GREATER_EQUAL: CV_HLSLREG_e = CV_HLSLREG_e(38i32);
pub const CV_HLSLREG_OUTPUT_DEPTH_LESS_EQUAL: CV_HLSLREG_e = CV_HLSLREG_e(39i32);
pub const CV_HLSLREG_CYCLE_COUNTER: CV_HLSLREG_e = CV_HLSLREG_e(40i32);
impl ::core::marker::Copy for CV_HLSLREG_e {}
impl ::core::clone::Clone for CV_HLSLREG_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_HLSLREG_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_HLSLREG_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_HLSLREG_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_HLSLREG_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_HREG_e(pub i32);
pub const CV_ALLREG_ERR: CV_HREG_e = CV_HREG_e(30000i32);
pub const CV_ALLREG_TEB: CV_HREG_e = CV_HREG_e(30001i32);
pub const CV_ALLREG_TIMER: CV_HREG_e = CV_HREG_e(30002i32);
pub const CV_ALLREG_EFAD1: CV_HREG_e = CV_HREG_e(30003i32);
pub const CV_ALLREG_EFAD2: CV_HREG_e = CV_HREG_e(30004i32);
pub const CV_ALLREG_EFAD3: CV_HREG_e = CV_HREG_e(30005i32);
pub const CV_ALLREG_VFRAME: CV_HREG_e = CV_HREG_e(30006i32);
pub const CV_ALLREG_HANDLE: CV_HREG_e = CV_HREG_e(30007i32);
pub const CV_ALLREG_PARAMS: CV_HREG_e = CV_HREG_e(30008i32);
pub const CV_ALLREG_LOCALS: CV_HREG_e = CV_HREG_e(30009i32);
pub const CV_ALLREG_TID: CV_HREG_e = CV_HREG_e(30010i32);
pub const CV_ALLREG_ENV: CV_HREG_e = CV_HREG_e(30011i32);
pub const CV_ALLREG_CMDLN: CV_HREG_e = CV_HREG_e(30012i32);
pub const CV_REG_NONE: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_REG_AL: CV_HREG_e = CV_HREG_e(1i32);
pub const CV_REG_CL: CV_HREG_e = CV_HREG_e(2i32);
pub const CV_REG_DL: CV_HREG_e = CV_HREG_e(3i32);
pub const CV_REG_BL: CV_HREG_e = CV_HREG_e(4i32);
pub const CV_REG_AH: CV_HREG_e = CV_HREG_e(5i32);
pub const CV_REG_CH: CV_HREG_e = CV_HREG_e(6i32);
pub const CV_REG_DH: CV_HREG_e = CV_HREG_e(7i32);
pub const CV_REG_BH: CV_HREG_e = CV_HREG_e(8i32);
pub const CV_REG_AX: CV_HREG_e = CV_HREG_e(9i32);
pub const CV_REG_CX: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_REG_DX: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_REG_BX: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_REG_SP: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_REG_BP: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_REG_SI: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_REG_DI: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_REG_EAX: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_REG_ECX: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_REG_EDX: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_REG_EBX: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_REG_ESP: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_REG_EBP: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_REG_ESI: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_REG_EDI: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_REG_ES: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_REG_CS: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_REG_SS: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_REG_DS: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_REG_FS: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_REG_GS: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_REG_IP: CV_HREG_e = CV_HREG_e(31i32);
pub const CV_REG_FLAGS: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_REG_EIP: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_REG_EFLAGS: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_REG_TEMP: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_REG_TEMPH: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_REG_QUOTE: CV_HREG_e = CV_HREG_e(42i32);
pub const CV_REG_PCDR3: CV_HREG_e = CV_HREG_e(43i32);
pub const CV_REG_PCDR4: CV_HREG_e = CV_HREG_e(44i32);
pub const CV_REG_PCDR5: CV_HREG_e = CV_HREG_e(45i32);
pub const CV_REG_PCDR6: CV_HREG_e = CV_HREG_e(46i32);
pub const CV_REG_PCDR7: CV_HREG_e = CV_HREG_e(47i32);
pub const CV_REG_CR0: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_REG_CR1: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_REG_CR2: CV_HREG_e = CV_HREG_e(82i32);
pub const CV_REG_CR3: CV_HREG_e = CV_HREG_e(83i32);
pub const CV_REG_CR4: CV_HREG_e = CV_HREG_e(84i32);
pub const CV_REG_DR0: CV_HREG_e = CV_HREG_e(90i32);
pub const CV_REG_DR1: CV_HREG_e = CV_HREG_e(91i32);
pub const CV_REG_DR2: CV_HREG_e = CV_HREG_e(92i32);
pub const CV_REG_DR3: CV_HREG_e = CV_HREG_e(93i32);
pub const CV_REG_DR4: CV_HREG_e = CV_HREG_e(94i32);
pub const CV_REG_DR5: CV_HREG_e = CV_HREG_e(95i32);
pub const CV_REG_DR6: CV_HREG_e = CV_HREG_e(96i32);
pub const CV_REG_DR7: CV_HREG_e = CV_HREG_e(97i32);
pub const CV_REG_GDTR: CV_HREG_e = CV_HREG_e(110i32);
pub const CV_REG_GDTL: CV_HREG_e = CV_HREG_e(111i32);
pub const CV_REG_IDTR: CV_HREG_e = CV_HREG_e(112i32);
pub const CV_REG_IDTL: CV_HREG_e = CV_HREG_e(113i32);
pub const CV_REG_LDTR: CV_HREG_e = CV_HREG_e(114i32);
pub const CV_REG_TR: CV_HREG_e = CV_HREG_e(115i32);
pub const CV_REG_PSEUDO1: CV_HREG_e = CV_HREG_e(116i32);
pub const CV_REG_PSEUDO2: CV_HREG_e = CV_HREG_e(117i32);
pub const CV_REG_PSEUDO3: CV_HREG_e = CV_HREG_e(118i32);
pub const CV_REG_PSEUDO4: CV_HREG_e = CV_HREG_e(119i32);
pub const CV_REG_PSEUDO5: CV_HREG_e = CV_HREG_e(120i32);
pub const CV_REG_PSEUDO6: CV_HREG_e = CV_HREG_e(121i32);
pub const CV_REG_PSEUDO7: CV_HREG_e = CV_HREG_e(122i32);
pub const CV_REG_PSEUDO8: CV_HREG_e = CV_HREG_e(123i32);
pub const CV_REG_PSEUDO9: CV_HREG_e = CV_HREG_e(124i32);
pub const CV_REG_ST0: CV_HREG_e = CV_HREG_e(128i32);
pub const CV_REG_ST1: CV_HREG_e = CV_HREG_e(129i32);
pub const CV_REG_ST2: CV_HREG_e = CV_HREG_e(130i32);
pub const CV_REG_ST3: CV_HREG_e = CV_HREG_e(131i32);
pub const CV_REG_ST4: CV_HREG_e = CV_HREG_e(132i32);
pub const CV_REG_ST5: CV_HREG_e = CV_HREG_e(133i32);
pub const CV_REG_ST6: CV_HREG_e = CV_HREG_e(134i32);
pub const CV_REG_ST7: CV_HREG_e = CV_HREG_e(135i32);
pub const CV_REG_CTRL: CV_HREG_e = CV_HREG_e(136i32);
pub const CV_REG_STAT: CV_HREG_e = CV_HREG_e(137i32);
pub const CV_REG_TAG: CV_HREG_e = CV_HREG_e(138i32);
pub const CV_REG_FPIP: CV_HREG_e = CV_HREG_e(139i32);
pub const CV_REG_FPCS: CV_HREG_e = CV_HREG_e(140i32);
pub const CV_REG_FPDO: CV_HREG_e = CV_HREG_e(141i32);
pub const CV_REG_FPDS: CV_HREG_e = CV_HREG_e(142i32);
pub const CV_REG_ISEM: CV_HREG_e = CV_HREG_e(143i32);
pub const CV_REG_FPEIP: CV_HREG_e = CV_HREG_e(144i32);
pub const CV_REG_FPEDO: CV_HREG_e = CV_HREG_e(145i32);
pub const CV_REG_MM0: CV_HREG_e = CV_HREG_e(146i32);
pub const CV_REG_MM1: CV_HREG_e = CV_HREG_e(147i32);
pub const CV_REG_MM2: CV_HREG_e = CV_HREG_e(148i32);
pub const CV_REG_MM3: CV_HREG_e = CV_HREG_e(149i32);
pub const CV_REG_MM4: CV_HREG_e = CV_HREG_e(150i32);
pub const CV_REG_MM5: CV_HREG_e = CV_HREG_e(151i32);
pub const CV_REG_MM6: CV_HREG_e = CV_HREG_e(152i32);
pub const CV_REG_MM7: CV_HREG_e = CV_HREG_e(153i32);
pub const CV_REG_XMM0: CV_HREG_e = CV_HREG_e(154i32);
pub const CV_REG_XMM1: CV_HREG_e = CV_HREG_e(155i32);
pub const CV_REG_XMM2: CV_HREG_e = CV_HREG_e(156i32);
pub const CV_REG_XMM3: CV_HREG_e = CV_HREG_e(157i32);
pub const CV_REG_XMM4: CV_HREG_e = CV_HREG_e(158i32);
pub const CV_REG_XMM5: CV_HREG_e = CV_HREG_e(159i32);
pub const CV_REG_XMM6: CV_HREG_e = CV_HREG_e(160i32);
pub const CV_REG_XMM7: CV_HREG_e = CV_HREG_e(161i32);
pub const CV_REG_XMM00: CV_HREG_e = CV_HREG_e(162i32);
pub const CV_REG_XMM01: CV_HREG_e = CV_HREG_e(163i32);
pub const CV_REG_XMM02: CV_HREG_e = CV_HREG_e(164i32);
pub const CV_REG_XMM03: CV_HREG_e = CV_HREG_e(165i32);
pub const CV_REG_XMM10: CV_HREG_e = CV_HREG_e(166i32);
pub const CV_REG_XMM11: CV_HREG_e = CV_HREG_e(167i32);
pub const CV_REG_XMM12: CV_HREG_e = CV_HREG_e(168i32);
pub const CV_REG_XMM13: CV_HREG_e = CV_HREG_e(169i32);
pub const CV_REG_XMM20: CV_HREG_e = CV_HREG_e(170i32);
pub const CV_REG_XMM21: CV_HREG_e = CV_HREG_e(171i32);
pub const CV_REG_XMM22: CV_HREG_e = CV_HREG_e(172i32);
pub const CV_REG_XMM23: CV_HREG_e = CV_HREG_e(173i32);
pub const CV_REG_XMM30: CV_HREG_e = CV_HREG_e(174i32);
pub const CV_REG_XMM31: CV_HREG_e = CV_HREG_e(175i32);
pub const CV_REG_XMM32: CV_HREG_e = CV_HREG_e(176i32);
pub const CV_REG_XMM33: CV_HREG_e = CV_HREG_e(177i32);
pub const CV_REG_XMM40: CV_HREG_e = CV_HREG_e(178i32);
pub const CV_REG_XMM41: CV_HREG_e = CV_HREG_e(179i32);
pub const CV_REG_XMM42: CV_HREG_e = CV_HREG_e(180i32);
pub const CV_REG_XMM43: CV_HREG_e = CV_HREG_e(181i32);
pub const CV_REG_XMM50: CV_HREG_e = CV_HREG_e(182i32);
pub const CV_REG_XMM51: CV_HREG_e = CV_HREG_e(183i32);
pub const CV_REG_XMM52: CV_HREG_e = CV_HREG_e(184i32);
pub const CV_REG_XMM53: CV_HREG_e = CV_HREG_e(185i32);
pub const CV_REG_XMM60: CV_HREG_e = CV_HREG_e(186i32);
pub const CV_REG_XMM61: CV_HREG_e = CV_HREG_e(187i32);
pub const CV_REG_XMM62: CV_HREG_e = CV_HREG_e(188i32);
pub const CV_REG_XMM63: CV_HREG_e = CV_HREG_e(189i32);
pub const CV_REG_XMM70: CV_HREG_e = CV_HREG_e(190i32);
pub const CV_REG_XMM71: CV_HREG_e = CV_HREG_e(191i32);
pub const CV_REG_XMM72: CV_HREG_e = CV_HREG_e(192i32);
pub const CV_REG_XMM73: CV_HREG_e = CV_HREG_e(193i32);
pub const CV_REG_XMM0L: CV_HREG_e = CV_HREG_e(194i32);
pub const CV_REG_XMM1L: CV_HREG_e = CV_HREG_e(195i32);
pub const CV_REG_XMM2L: CV_HREG_e = CV_HREG_e(196i32);
pub const CV_REG_XMM3L: CV_HREG_e = CV_HREG_e(197i32);
pub const CV_REG_XMM4L: CV_HREG_e = CV_HREG_e(198i32);
pub const CV_REG_XMM5L: CV_HREG_e = CV_HREG_e(199i32);
pub const CV_REG_XMM6L: CV_HREG_e = CV_HREG_e(200i32);
pub const CV_REG_XMM7L: CV_HREG_e = CV_HREG_e(201i32);
pub const CV_REG_XMM0H: CV_HREG_e = CV_HREG_e(202i32);
pub const CV_REG_XMM1H: CV_HREG_e = CV_HREG_e(203i32);
pub const CV_REG_XMM2H: CV_HREG_e = CV_HREG_e(204i32);
pub const CV_REG_XMM3H: CV_HREG_e = CV_HREG_e(205i32);
pub const CV_REG_XMM4H: CV_HREG_e = CV_HREG_e(206i32);
pub const CV_REG_XMM5H: CV_HREG_e = CV_HREG_e(207i32);
pub const CV_REG_XMM6H: CV_HREG_e = CV_HREG_e(208i32);
pub const CV_REG_XMM7H: CV_HREG_e = CV_HREG_e(209i32);
pub const CV_REG_MXCSR: CV_HREG_e = CV_HREG_e(211i32);
pub const CV_REG_EDXEAX: CV_HREG_e = CV_HREG_e(212i32);
pub const CV_REG_EMM0L: CV_HREG_e = CV_HREG_e(220i32);
pub const CV_REG_EMM1L: CV_HREG_e = CV_HREG_e(221i32);
pub const CV_REG_EMM2L: CV_HREG_e = CV_HREG_e(222i32);
pub const CV_REG_EMM3L: CV_HREG_e = CV_HREG_e(223i32);
pub const CV_REG_EMM4L: CV_HREG_e = CV_HREG_e(224i32);
pub const CV_REG_EMM5L: CV_HREG_e = CV_HREG_e(225i32);
pub const CV_REG_EMM6L: CV_HREG_e = CV_HREG_e(226i32);
pub const CV_REG_EMM7L: CV_HREG_e = CV_HREG_e(227i32);
pub const CV_REG_EMM0H: CV_HREG_e = CV_HREG_e(228i32);
pub const CV_REG_EMM1H: CV_HREG_e = CV_HREG_e(229i32);
pub const CV_REG_EMM2H: CV_HREG_e = CV_HREG_e(230i32);
pub const CV_REG_EMM3H: CV_HREG_e = CV_HREG_e(231i32);
pub const CV_REG_EMM4H: CV_HREG_e = CV_HREG_e(232i32);
pub const CV_REG_EMM5H: CV_HREG_e = CV_HREG_e(233i32);
pub const CV_REG_EMM6H: CV_HREG_e = CV_HREG_e(234i32);
pub const CV_REG_EMM7H: CV_HREG_e = CV_HREG_e(235i32);
pub const CV_REG_MM00: CV_HREG_e = CV_HREG_e(236i32);
pub const CV_REG_MM01: CV_HREG_e = CV_HREG_e(237i32);
pub const CV_REG_MM10: CV_HREG_e = CV_HREG_e(238i32);
pub const CV_REG_MM11: CV_HREG_e = CV_HREG_e(239i32);
pub const CV_REG_MM20: CV_HREG_e = CV_HREG_e(240i32);
pub const CV_REG_MM21: CV_HREG_e = CV_HREG_e(241i32);
pub const CV_REG_MM30: CV_HREG_e = CV_HREG_e(242i32);
pub const CV_REG_MM31: CV_HREG_e = CV_HREG_e(243i32);
pub const CV_REG_MM40: CV_HREG_e = CV_HREG_e(244i32);
pub const CV_REG_MM41: CV_HREG_e = CV_HREG_e(245i32);
pub const CV_REG_MM50: CV_HREG_e = CV_HREG_e(246i32);
pub const CV_REG_MM51: CV_HREG_e = CV_HREG_e(247i32);
pub const CV_REG_MM60: CV_HREG_e = CV_HREG_e(248i32);
pub const CV_REG_MM61: CV_HREG_e = CV_HREG_e(249i32);
pub const CV_REG_MM70: CV_HREG_e = CV_HREG_e(250i32);
pub const CV_REG_MM71: CV_HREG_e = CV_HREG_e(251i32);
pub const CV_REG_YMM0: CV_HREG_e = CV_HREG_e(252i32);
pub const CV_REG_YMM1: CV_HREG_e = CV_HREG_e(253i32);
pub const CV_REG_YMM2: CV_HREG_e = CV_HREG_e(254i32);
pub const CV_REG_YMM3: CV_HREG_e = CV_HREG_e(255i32);
pub const CV_REG_YMM4: CV_HREG_e = CV_HREG_e(256i32);
pub const CV_REG_YMM5: CV_HREG_e = CV_HREG_e(257i32);
pub const CV_REG_YMM6: CV_HREG_e = CV_HREG_e(258i32);
pub const CV_REG_YMM7: CV_HREG_e = CV_HREG_e(259i32);
pub const CV_REG_YMM0H: CV_HREG_e = CV_HREG_e(260i32);
pub const CV_REG_YMM1H: CV_HREG_e = CV_HREG_e(261i32);
pub const CV_REG_YMM2H: CV_HREG_e = CV_HREG_e(262i32);
pub const CV_REG_YMM3H: CV_HREG_e = CV_HREG_e(263i32);
pub const CV_REG_YMM4H: CV_HREG_e = CV_HREG_e(264i32);
pub const CV_REG_YMM5H: CV_HREG_e = CV_HREG_e(265i32);
pub const CV_REG_YMM6H: CV_HREG_e = CV_HREG_e(266i32);
pub const CV_REG_YMM7H: CV_HREG_e = CV_HREG_e(267i32);
pub const CV_REG_YMM0I0: CV_HREG_e = CV_HREG_e(268i32);
pub const CV_REG_YMM0I1: CV_HREG_e = CV_HREG_e(269i32);
pub const CV_REG_YMM0I2: CV_HREG_e = CV_HREG_e(270i32);
pub const CV_REG_YMM0I3: CV_HREG_e = CV_HREG_e(271i32);
pub const CV_REG_YMM1I0: CV_HREG_e = CV_HREG_e(272i32);
pub const CV_REG_YMM1I1: CV_HREG_e = CV_HREG_e(273i32);
pub const CV_REG_YMM1I2: CV_HREG_e = CV_HREG_e(274i32);
pub const CV_REG_YMM1I3: CV_HREG_e = CV_HREG_e(275i32);
pub const CV_REG_YMM2I0: CV_HREG_e = CV_HREG_e(276i32);
pub const CV_REG_YMM2I1: CV_HREG_e = CV_HREG_e(277i32);
pub const CV_REG_YMM2I2: CV_HREG_e = CV_HREG_e(278i32);
pub const CV_REG_YMM2I3: CV_HREG_e = CV_HREG_e(279i32);
pub const CV_REG_YMM3I0: CV_HREG_e = CV_HREG_e(280i32);
pub const CV_REG_YMM3I1: CV_HREG_e = CV_HREG_e(281i32);
pub const CV_REG_YMM3I2: CV_HREG_e = CV_HREG_e(282i32);
pub const CV_REG_YMM3I3: CV_HREG_e = CV_HREG_e(283i32);
pub const CV_REG_YMM4I0: CV_HREG_e = CV_HREG_e(284i32);
pub const CV_REG_YMM4I1: CV_HREG_e = CV_HREG_e(285i32);
pub const CV_REG_YMM4I2: CV_HREG_e = CV_HREG_e(286i32);
pub const CV_REG_YMM4I3: CV_HREG_e = CV_HREG_e(287i32);
pub const CV_REG_YMM5I0: CV_HREG_e = CV_HREG_e(288i32);
pub const CV_REG_YMM5I1: CV_HREG_e = CV_HREG_e(289i32);
pub const CV_REG_YMM5I2: CV_HREG_e = CV_HREG_e(290i32);
pub const CV_REG_YMM5I3: CV_HREG_e = CV_HREG_e(291i32);
pub const CV_REG_YMM6I0: CV_HREG_e = CV_HREG_e(292i32);
pub const CV_REG_YMM6I1: CV_HREG_e = CV_HREG_e(293i32);
pub const CV_REG_YMM6I2: CV_HREG_e = CV_HREG_e(294i32);
pub const CV_REG_YMM6I3: CV_HREG_e = CV_HREG_e(295i32);
pub const CV_REG_YMM7I0: CV_HREG_e = CV_HREG_e(296i32);
pub const CV_REG_YMM7I1: CV_HREG_e = CV_HREG_e(297i32);
pub const CV_REG_YMM7I2: CV_HREG_e = CV_HREG_e(298i32);
pub const CV_REG_YMM7I3: CV_HREG_e = CV_HREG_e(299i32);
pub const CV_REG_YMM0F0: CV_HREG_e = CV_HREG_e(300i32);
pub const CV_REG_YMM0F1: CV_HREG_e = CV_HREG_e(301i32);
pub const CV_REG_YMM0F2: CV_HREG_e = CV_HREG_e(302i32);
pub const CV_REG_YMM0F3: CV_HREG_e = CV_HREG_e(303i32);
pub const CV_REG_YMM0F4: CV_HREG_e = CV_HREG_e(304i32);
pub const CV_REG_YMM0F5: CV_HREG_e = CV_HREG_e(305i32);
pub const CV_REG_YMM0F6: CV_HREG_e = CV_HREG_e(306i32);
pub const CV_REG_YMM0F7: CV_HREG_e = CV_HREG_e(307i32);
pub const CV_REG_YMM1F0: CV_HREG_e = CV_HREG_e(308i32);
pub const CV_REG_YMM1F1: CV_HREG_e = CV_HREG_e(309i32);
pub const CV_REG_YMM1F2: CV_HREG_e = CV_HREG_e(310i32);
pub const CV_REG_YMM1F3: CV_HREG_e = CV_HREG_e(311i32);
pub const CV_REG_YMM1F4: CV_HREG_e = CV_HREG_e(312i32);
pub const CV_REG_YMM1F5: CV_HREG_e = CV_HREG_e(313i32);
pub const CV_REG_YMM1F6: CV_HREG_e = CV_HREG_e(314i32);
pub const CV_REG_YMM1F7: CV_HREG_e = CV_HREG_e(315i32);
pub const CV_REG_YMM2F0: CV_HREG_e = CV_HREG_e(316i32);
pub const CV_REG_YMM2F1: CV_HREG_e = CV_HREG_e(317i32);
pub const CV_REG_YMM2F2: CV_HREG_e = CV_HREG_e(318i32);
pub const CV_REG_YMM2F3: CV_HREG_e = CV_HREG_e(319i32);
pub const CV_REG_YMM2F4: CV_HREG_e = CV_HREG_e(320i32);
pub const CV_REG_YMM2F5: CV_HREG_e = CV_HREG_e(321i32);
pub const CV_REG_YMM2F6: CV_HREG_e = CV_HREG_e(322i32);
pub const CV_REG_YMM2F7: CV_HREG_e = CV_HREG_e(323i32);
pub const CV_REG_YMM3F0: CV_HREG_e = CV_HREG_e(324i32);
pub const CV_REG_YMM3F1: CV_HREG_e = CV_HREG_e(325i32);
pub const CV_REG_YMM3F2: CV_HREG_e = CV_HREG_e(326i32);
pub const CV_REG_YMM3F3: CV_HREG_e = CV_HREG_e(327i32);
pub const CV_REG_YMM3F4: CV_HREG_e = CV_HREG_e(328i32);
pub const CV_REG_YMM3F5: CV_HREG_e = CV_HREG_e(329i32);
pub const CV_REG_YMM3F6: CV_HREG_e = CV_HREG_e(330i32);
pub const CV_REG_YMM3F7: CV_HREG_e = CV_HREG_e(331i32);
pub const CV_REG_YMM4F0: CV_HREG_e = CV_HREG_e(332i32);
pub const CV_REG_YMM4F1: CV_HREG_e = CV_HREG_e(333i32);
pub const CV_REG_YMM4F2: CV_HREG_e = CV_HREG_e(334i32);
pub const CV_REG_YMM4F3: CV_HREG_e = CV_HREG_e(335i32);
pub const CV_REG_YMM4F4: CV_HREG_e = CV_HREG_e(336i32);
pub const CV_REG_YMM4F5: CV_HREG_e = CV_HREG_e(337i32);
pub const CV_REG_YMM4F6: CV_HREG_e = CV_HREG_e(338i32);
pub const CV_REG_YMM4F7: CV_HREG_e = CV_HREG_e(339i32);
pub const CV_REG_YMM5F0: CV_HREG_e = CV_HREG_e(340i32);
pub const CV_REG_YMM5F1: CV_HREG_e = CV_HREG_e(341i32);
pub const CV_REG_YMM5F2: CV_HREG_e = CV_HREG_e(342i32);
pub const CV_REG_YMM5F3: CV_HREG_e = CV_HREG_e(343i32);
pub const CV_REG_YMM5F4: CV_HREG_e = CV_HREG_e(344i32);
pub const CV_REG_YMM5F5: CV_HREG_e = CV_HREG_e(345i32);
pub const CV_REG_YMM5F6: CV_HREG_e = CV_HREG_e(346i32);
pub const CV_REG_YMM5F7: CV_HREG_e = CV_HREG_e(347i32);
pub const CV_REG_YMM6F0: CV_HREG_e = CV_HREG_e(348i32);
pub const CV_REG_YMM6F1: CV_HREG_e = CV_HREG_e(349i32);
pub const CV_REG_YMM6F2: CV_HREG_e = CV_HREG_e(350i32);
pub const CV_REG_YMM6F3: CV_HREG_e = CV_HREG_e(351i32);
pub const CV_REG_YMM6F4: CV_HREG_e = CV_HREG_e(352i32);
pub const CV_REG_YMM6F5: CV_HREG_e = CV_HREG_e(353i32);
pub const CV_REG_YMM6F6: CV_HREG_e = CV_HREG_e(354i32);
pub const CV_REG_YMM6F7: CV_HREG_e = CV_HREG_e(355i32);
pub const CV_REG_YMM7F0: CV_HREG_e = CV_HREG_e(356i32);
pub const CV_REG_YMM7F1: CV_HREG_e = CV_HREG_e(357i32);
pub const CV_REG_YMM7F2: CV_HREG_e = CV_HREG_e(358i32);
pub const CV_REG_YMM7F3: CV_HREG_e = CV_HREG_e(359i32);
pub const CV_REG_YMM7F4: CV_HREG_e = CV_HREG_e(360i32);
pub const CV_REG_YMM7F5: CV_HREG_e = CV_HREG_e(361i32);
pub const CV_REG_YMM7F6: CV_HREG_e = CV_HREG_e(362i32);
pub const CV_REG_YMM7F7: CV_HREG_e = CV_HREG_e(363i32);
pub const CV_REG_YMM0D0: CV_HREG_e = CV_HREG_e(364i32);
pub const CV_REG_YMM0D1: CV_HREG_e = CV_HREG_e(365i32);
pub const CV_REG_YMM0D2: CV_HREG_e = CV_HREG_e(366i32);
pub const CV_REG_YMM0D3: CV_HREG_e = CV_HREG_e(367i32);
pub const CV_REG_YMM1D0: CV_HREG_e = CV_HREG_e(368i32);
pub const CV_REG_YMM1D1: CV_HREG_e = CV_HREG_e(369i32);
pub const CV_REG_YMM1D2: CV_HREG_e = CV_HREG_e(370i32);
pub const CV_REG_YMM1D3: CV_HREG_e = CV_HREG_e(371i32);
pub const CV_REG_YMM2D0: CV_HREG_e = CV_HREG_e(372i32);
pub const CV_REG_YMM2D1: CV_HREG_e = CV_HREG_e(373i32);
pub const CV_REG_YMM2D2: CV_HREG_e = CV_HREG_e(374i32);
pub const CV_REG_YMM2D3: CV_HREG_e = CV_HREG_e(375i32);
pub const CV_REG_YMM3D0: CV_HREG_e = CV_HREG_e(376i32);
pub const CV_REG_YMM3D1: CV_HREG_e = CV_HREG_e(377i32);
pub const CV_REG_YMM3D2: CV_HREG_e = CV_HREG_e(378i32);
pub const CV_REG_YMM3D3: CV_HREG_e = CV_HREG_e(379i32);
pub const CV_REG_YMM4D0: CV_HREG_e = CV_HREG_e(380i32);
pub const CV_REG_YMM4D1: CV_HREG_e = CV_HREG_e(381i32);
pub const CV_REG_YMM4D2: CV_HREG_e = CV_HREG_e(382i32);
pub const CV_REG_YMM4D3: CV_HREG_e = CV_HREG_e(383i32);
pub const CV_REG_YMM5D0: CV_HREG_e = CV_HREG_e(384i32);
pub const CV_REG_YMM5D1: CV_HREG_e = CV_HREG_e(385i32);
pub const CV_REG_YMM5D2: CV_HREG_e = CV_HREG_e(386i32);
pub const CV_REG_YMM5D3: CV_HREG_e = CV_HREG_e(387i32);
pub const CV_REG_YMM6D0: CV_HREG_e = CV_HREG_e(388i32);
pub const CV_REG_YMM6D1: CV_HREG_e = CV_HREG_e(389i32);
pub const CV_REG_YMM6D2: CV_HREG_e = CV_HREG_e(390i32);
pub const CV_REG_YMM6D3: CV_HREG_e = CV_HREG_e(391i32);
pub const CV_REG_YMM7D0: CV_HREG_e = CV_HREG_e(392i32);
pub const CV_REG_YMM7D1: CV_HREG_e = CV_HREG_e(393i32);
pub const CV_REG_YMM7D2: CV_HREG_e = CV_HREG_e(394i32);
pub const CV_REG_YMM7D3: CV_HREG_e = CV_HREG_e(395i32);
pub const CV_REG_BND0: CV_HREG_e = CV_HREG_e(396i32);
pub const CV_REG_BND1: CV_HREG_e = CV_HREG_e(397i32);
pub const CV_REG_BND2: CV_HREG_e = CV_HREG_e(398i32);
pub const CV_REG_BND3: CV_HREG_e = CV_HREG_e(399i32);
pub const CV_REG_BNDCFGU: CV_HREG_e = CV_HREG_e(400i32);
pub const CV_REG_BNDSTATUS: CV_HREG_e = CV_HREG_e(401i32);
pub const CV_REG_ZMM0: CV_HREG_e = CV_HREG_e(402i32);
pub const CV_REG_ZMM1: CV_HREG_e = CV_HREG_e(403i32);
pub const CV_REG_ZMM2: CV_HREG_e = CV_HREG_e(404i32);
pub const CV_REG_ZMM3: CV_HREG_e = CV_HREG_e(405i32);
pub const CV_REG_ZMM4: CV_HREG_e = CV_HREG_e(406i32);
pub const CV_REG_ZMM5: CV_HREG_e = CV_HREG_e(407i32);
pub const CV_REG_ZMM6: CV_HREG_e = CV_HREG_e(408i32);
pub const CV_REG_ZMM7: CV_HREG_e = CV_HREG_e(409i32);
pub const CV_REG_ZMM0H: CV_HREG_e = CV_HREG_e(410i32);
pub const CV_REG_ZMM1H: CV_HREG_e = CV_HREG_e(411i32);
pub const CV_REG_ZMM2H: CV_HREG_e = CV_HREG_e(412i32);
pub const CV_REG_ZMM3H: CV_HREG_e = CV_HREG_e(413i32);
pub const CV_REG_ZMM4H: CV_HREG_e = CV_HREG_e(414i32);
pub const CV_REG_ZMM5H: CV_HREG_e = CV_HREG_e(415i32);
pub const CV_REG_ZMM6H: CV_HREG_e = CV_HREG_e(416i32);
pub const CV_REG_ZMM7H: CV_HREG_e = CV_HREG_e(417i32);
pub const CV_REG_K0: CV_HREG_e = CV_HREG_e(418i32);
pub const CV_REG_K1: CV_HREG_e = CV_HREG_e(419i32);
pub const CV_REG_K2: CV_HREG_e = CV_HREG_e(420i32);
pub const CV_REG_K3: CV_HREG_e = CV_HREG_e(421i32);
pub const CV_REG_K4: CV_HREG_e = CV_HREG_e(422i32);
pub const CV_REG_K5: CV_HREG_e = CV_HREG_e(423i32);
pub const CV_REG_K6: CV_HREG_e = CV_HREG_e(424i32);
pub const CV_REG_K7: CV_HREG_e = CV_HREG_e(425i32);
pub const CV_REG_SSP: CV_HREG_e = CV_HREG_e(426i32);
pub const CV_R68_D0: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_R68_D1: CV_HREG_e = CV_HREG_e(1i32);
pub const CV_R68_D2: CV_HREG_e = CV_HREG_e(2i32);
pub const CV_R68_D3: CV_HREG_e = CV_HREG_e(3i32);
pub const CV_R68_D4: CV_HREG_e = CV_HREG_e(4i32);
pub const CV_R68_D5: CV_HREG_e = CV_HREG_e(5i32);
pub const CV_R68_D6: CV_HREG_e = CV_HREG_e(6i32);
pub const CV_R68_D7: CV_HREG_e = CV_HREG_e(7i32);
pub const CV_R68_A0: CV_HREG_e = CV_HREG_e(8i32);
pub const CV_R68_A1: CV_HREG_e = CV_HREG_e(9i32);
pub const CV_R68_A2: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_R68_A3: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_R68_A4: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_R68_A5: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_R68_A6: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_R68_A7: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_R68_CCR: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_R68_SR: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_R68_USP: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_R68_MSP: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_R68_SFC: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_R68_DFC: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_R68_CACR: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_R68_VBR: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_R68_CAAR: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_R68_ISP: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_R68_PC: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_R68_FPCR: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_R68_FPSR: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_R68_FPIAR: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_R68_FP0: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_R68_FP1: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_R68_FP2: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_R68_FP3: CV_HREG_e = CV_HREG_e(35i32);
pub const CV_R68_FP4: CV_HREG_e = CV_HREG_e(36i32);
pub const CV_R68_FP5: CV_HREG_e = CV_HREG_e(37i32);
pub const CV_R68_FP6: CV_HREG_e = CV_HREG_e(38i32);
pub const CV_R68_FP7: CV_HREG_e = CV_HREG_e(39i32);
pub const CV_R68_MMUSR030: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_R68_MMUSR: CV_HREG_e = CV_HREG_e(42i32);
pub const CV_R68_URP: CV_HREG_e = CV_HREG_e(43i32);
pub const CV_R68_DTT0: CV_HREG_e = CV_HREG_e(44i32);
pub const CV_R68_DTT1: CV_HREG_e = CV_HREG_e(45i32);
pub const CV_R68_ITT0: CV_HREG_e = CV_HREG_e(46i32);
pub const CV_R68_ITT1: CV_HREG_e = CV_HREG_e(47i32);
pub const CV_R68_PSR: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_R68_PCSR: CV_HREG_e = CV_HREG_e(52i32);
pub const CV_R68_VAL: CV_HREG_e = CV_HREG_e(53i32);
pub const CV_R68_CRP: CV_HREG_e = CV_HREG_e(54i32);
pub const CV_R68_SRP: CV_HREG_e = CV_HREG_e(55i32);
pub const CV_R68_DRP: CV_HREG_e = CV_HREG_e(56i32);
pub const CV_R68_TC: CV_HREG_e = CV_HREG_e(57i32);
pub const CV_R68_AC: CV_HREG_e = CV_HREG_e(58i32);
pub const CV_R68_SCC: CV_HREG_e = CV_HREG_e(59i32);
pub const CV_R68_CAL: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_R68_TT0: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_R68_TT1: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_R68_BAD0: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_R68_BAD1: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_R68_BAD2: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_R68_BAD3: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_R68_BAD4: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_R68_BAD5: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_R68_BAD6: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_R68_BAD7: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_R68_BAC0: CV_HREG_e = CV_HREG_e(72i32);
pub const CV_R68_BAC1: CV_HREG_e = CV_HREG_e(73i32);
pub const CV_R68_BAC2: CV_HREG_e = CV_HREG_e(74i32);
pub const CV_R68_BAC3: CV_HREG_e = CV_HREG_e(75i32);
pub const CV_R68_BAC4: CV_HREG_e = CV_HREG_e(76i32);
pub const CV_R68_BAC5: CV_HREG_e = CV_HREG_e(77i32);
pub const CV_R68_BAC6: CV_HREG_e = CV_HREG_e(78i32);
pub const CV_R68_BAC7: CV_HREG_e = CV_HREG_e(79i32);
pub const CV_M4_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_M4_IntZERO: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_M4_IntAT: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_M4_IntV0: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_M4_IntV1: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_M4_IntA0: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_M4_IntA1: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_M4_IntA2: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_M4_IntA3: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_M4_IntT0: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_M4_IntT1: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_M4_IntT2: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_M4_IntT3: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_M4_IntT4: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_M4_IntT5: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_M4_IntT6: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_M4_IntT7: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_M4_IntS0: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_M4_IntS1: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_M4_IntS2: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_M4_IntS3: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_M4_IntS4: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_M4_IntS5: CV_HREG_e = CV_HREG_e(31i32);
pub const CV_M4_IntS6: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_M4_IntS7: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_M4_IntT8: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_M4_IntT9: CV_HREG_e = CV_HREG_e(35i32);
pub const CV_M4_IntKT0: CV_HREG_e = CV_HREG_e(36i32);
pub const CV_M4_IntKT1: CV_HREG_e = CV_HREG_e(37i32);
pub const CV_M4_IntGP: CV_HREG_e = CV_HREG_e(38i32);
pub const CV_M4_IntSP: CV_HREG_e = CV_HREG_e(39i32);
pub const CV_M4_IntS8: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_M4_IntRA: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_M4_IntLO: CV_HREG_e = CV_HREG_e(42i32);
pub const CV_M4_IntHI: CV_HREG_e = CV_HREG_e(43i32);
pub const CV_M4_Fir: CV_HREG_e = CV_HREG_e(50i32);
pub const CV_M4_Psr: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_M4_FltF0: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_M4_FltF1: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_M4_FltF2: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_M4_FltF3: CV_HREG_e = CV_HREG_e(63i32);
pub const CV_M4_FltF4: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_M4_FltF5: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_M4_FltF6: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_M4_FltF7: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_M4_FltF8: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_M4_FltF9: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_M4_FltF10: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_M4_FltF11: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_M4_FltF12: CV_HREG_e = CV_HREG_e(72i32);
pub const CV_M4_FltF13: CV_HREG_e = CV_HREG_e(73i32);
pub const CV_M4_FltF14: CV_HREG_e = CV_HREG_e(74i32);
pub const CV_M4_FltF15: CV_HREG_e = CV_HREG_e(75i32);
pub const CV_M4_FltF16: CV_HREG_e = CV_HREG_e(76i32);
pub const CV_M4_FltF17: CV_HREG_e = CV_HREG_e(77i32);
pub const CV_M4_FltF18: CV_HREG_e = CV_HREG_e(78i32);
pub const CV_M4_FltF19: CV_HREG_e = CV_HREG_e(79i32);
pub const CV_M4_FltF20: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_M4_FltF21: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_M4_FltF22: CV_HREG_e = CV_HREG_e(82i32);
pub const CV_M4_FltF23: CV_HREG_e = CV_HREG_e(83i32);
pub const CV_M4_FltF24: CV_HREG_e = CV_HREG_e(84i32);
pub const CV_M4_FltF25: CV_HREG_e = CV_HREG_e(85i32);
pub const CV_M4_FltF26: CV_HREG_e = CV_HREG_e(86i32);
pub const CV_M4_FltF27: CV_HREG_e = CV_HREG_e(87i32);
pub const CV_M4_FltF28: CV_HREG_e = CV_HREG_e(88i32);
pub const CV_M4_FltF29: CV_HREG_e = CV_HREG_e(89i32);
pub const CV_M4_FltF30: CV_HREG_e = CV_HREG_e(90i32);
pub const CV_M4_FltF31: CV_HREG_e = CV_HREG_e(91i32);
pub const CV_M4_FltFsr: CV_HREG_e = CV_HREG_e(92i32);
pub const CV_ALPHA_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_ALPHA_FltF0: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_ALPHA_FltF1: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_ALPHA_FltF2: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_ALPHA_FltF3: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_ALPHA_FltF4: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_ALPHA_FltF5: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_ALPHA_FltF6: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_ALPHA_FltF7: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_ALPHA_FltF8: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_ALPHA_FltF9: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_ALPHA_FltF10: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_ALPHA_FltF11: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_ALPHA_FltF12: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_ALPHA_FltF13: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_ALPHA_FltF14: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_ALPHA_FltF15: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_ALPHA_FltF16: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_ALPHA_FltF17: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_ALPHA_FltF18: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_ALPHA_FltF19: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_ALPHA_FltF20: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_ALPHA_FltF21: CV_HREG_e = CV_HREG_e(31i32);
pub const CV_ALPHA_FltF22: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_ALPHA_FltF23: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_ALPHA_FltF24: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_ALPHA_FltF25: CV_HREG_e = CV_HREG_e(35i32);
pub const CV_ALPHA_FltF26: CV_HREG_e = CV_HREG_e(36i32);
pub const CV_ALPHA_FltF27: CV_HREG_e = CV_HREG_e(37i32);
pub const CV_ALPHA_FltF28: CV_HREG_e = CV_HREG_e(38i32);
pub const CV_ALPHA_FltF29: CV_HREG_e = CV_HREG_e(39i32);
pub const CV_ALPHA_FltF30: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_ALPHA_FltF31: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_ALPHA_IntV0: CV_HREG_e = CV_HREG_e(42i32);
pub const CV_ALPHA_IntT0: CV_HREG_e = CV_HREG_e(43i32);
pub const CV_ALPHA_IntT1: CV_HREG_e = CV_HREG_e(44i32);
pub const CV_ALPHA_IntT2: CV_HREG_e = CV_HREG_e(45i32);
pub const CV_ALPHA_IntT3: CV_HREG_e = CV_HREG_e(46i32);
pub const CV_ALPHA_IntT4: CV_HREG_e = CV_HREG_e(47i32);
pub const CV_ALPHA_IntT5: CV_HREG_e = CV_HREG_e(48i32);
pub const CV_ALPHA_IntT6: CV_HREG_e = CV_HREG_e(49i32);
pub const CV_ALPHA_IntT7: CV_HREG_e = CV_HREG_e(50i32);
pub const CV_ALPHA_IntS0: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_ALPHA_IntS1: CV_HREG_e = CV_HREG_e(52i32);
pub const CV_ALPHA_IntS2: CV_HREG_e = CV_HREG_e(53i32);
pub const CV_ALPHA_IntS3: CV_HREG_e = CV_HREG_e(54i32);
pub const CV_ALPHA_IntS4: CV_HREG_e = CV_HREG_e(55i32);
pub const CV_ALPHA_IntS5: CV_HREG_e = CV_HREG_e(56i32);
pub const CV_ALPHA_IntFP: CV_HREG_e = CV_HREG_e(57i32);
pub const CV_ALPHA_IntA0: CV_HREG_e = CV_HREG_e(58i32);
pub const CV_ALPHA_IntA1: CV_HREG_e = CV_HREG_e(59i32);
pub const CV_ALPHA_IntA2: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_ALPHA_IntA3: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_ALPHA_IntA4: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_ALPHA_IntA5: CV_HREG_e = CV_HREG_e(63i32);
pub const CV_ALPHA_IntT8: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_ALPHA_IntT9: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_ALPHA_IntT10: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_ALPHA_IntT11: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_ALPHA_IntRA: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_ALPHA_IntT12: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_ALPHA_IntAT: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_ALPHA_IntGP: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_ALPHA_IntSP: CV_HREG_e = CV_HREG_e(72i32);
pub const CV_ALPHA_IntZERO: CV_HREG_e = CV_HREG_e(73i32);
pub const CV_ALPHA_Fpcr: CV_HREG_e = CV_HREG_e(74i32);
pub const CV_ALPHA_Fir: CV_HREG_e = CV_HREG_e(75i32);
pub const CV_ALPHA_Psr: CV_HREG_e = CV_HREG_e(76i32);
pub const CV_ALPHA_FltFsr: CV_HREG_e = CV_HREG_e(77i32);
pub const CV_ALPHA_SoftFpcr: CV_HREG_e = CV_HREG_e(78i32);
pub const CV_PPC_GPR0: CV_HREG_e = CV_HREG_e(1i32);
pub const CV_PPC_GPR1: CV_HREG_e = CV_HREG_e(2i32);
pub const CV_PPC_GPR2: CV_HREG_e = CV_HREG_e(3i32);
pub const CV_PPC_GPR3: CV_HREG_e = CV_HREG_e(4i32);
pub const CV_PPC_GPR4: CV_HREG_e = CV_HREG_e(5i32);
pub const CV_PPC_GPR5: CV_HREG_e = CV_HREG_e(6i32);
pub const CV_PPC_GPR6: CV_HREG_e = CV_HREG_e(7i32);
pub const CV_PPC_GPR7: CV_HREG_e = CV_HREG_e(8i32);
pub const CV_PPC_GPR8: CV_HREG_e = CV_HREG_e(9i32);
pub const CV_PPC_GPR9: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_PPC_GPR10: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_PPC_GPR11: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_PPC_GPR12: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_PPC_GPR13: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_PPC_GPR14: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_PPC_GPR15: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_PPC_GPR16: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_PPC_GPR17: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_PPC_GPR18: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_PPC_GPR19: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_PPC_GPR20: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_PPC_GPR21: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_PPC_GPR22: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_PPC_GPR23: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_PPC_GPR24: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_PPC_GPR25: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_PPC_GPR26: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_PPC_GPR27: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_PPC_GPR28: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_PPC_GPR29: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_PPC_GPR30: CV_HREG_e = CV_HREG_e(31i32);
pub const CV_PPC_GPR31: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_PPC_CR: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_PPC_CR0: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_PPC_CR1: CV_HREG_e = CV_HREG_e(35i32);
pub const CV_PPC_CR2: CV_HREG_e = CV_HREG_e(36i32);
pub const CV_PPC_CR3: CV_HREG_e = CV_HREG_e(37i32);
pub const CV_PPC_CR4: CV_HREG_e = CV_HREG_e(38i32);
pub const CV_PPC_CR5: CV_HREG_e = CV_HREG_e(39i32);
pub const CV_PPC_CR6: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_PPC_CR7: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_PPC_FPR0: CV_HREG_e = CV_HREG_e(42i32);
pub const CV_PPC_FPR1: CV_HREG_e = CV_HREG_e(43i32);
pub const CV_PPC_FPR2: CV_HREG_e = CV_HREG_e(44i32);
pub const CV_PPC_FPR3: CV_HREG_e = CV_HREG_e(45i32);
pub const CV_PPC_FPR4: CV_HREG_e = CV_HREG_e(46i32);
pub const CV_PPC_FPR5: CV_HREG_e = CV_HREG_e(47i32);
pub const CV_PPC_FPR6: CV_HREG_e = CV_HREG_e(48i32);
pub const CV_PPC_FPR7: CV_HREG_e = CV_HREG_e(49i32);
pub const CV_PPC_FPR8: CV_HREG_e = CV_HREG_e(50i32);
pub const CV_PPC_FPR9: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_PPC_FPR10: CV_HREG_e = CV_HREG_e(52i32);
pub const CV_PPC_FPR11: CV_HREG_e = CV_HREG_e(53i32);
pub const CV_PPC_FPR12: CV_HREG_e = CV_HREG_e(54i32);
pub const CV_PPC_FPR13: CV_HREG_e = CV_HREG_e(55i32);
pub const CV_PPC_FPR14: CV_HREG_e = CV_HREG_e(56i32);
pub const CV_PPC_FPR15: CV_HREG_e = CV_HREG_e(57i32);
pub const CV_PPC_FPR16: CV_HREG_e = CV_HREG_e(58i32);
pub const CV_PPC_FPR17: CV_HREG_e = CV_HREG_e(59i32);
pub const CV_PPC_FPR18: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_PPC_FPR19: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_PPC_FPR20: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_PPC_FPR21: CV_HREG_e = CV_HREG_e(63i32);
pub const CV_PPC_FPR22: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_PPC_FPR23: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_PPC_FPR24: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_PPC_FPR25: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_PPC_FPR26: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_PPC_FPR27: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_PPC_FPR28: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_PPC_FPR29: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_PPC_FPR30: CV_HREG_e = CV_HREG_e(72i32);
pub const CV_PPC_FPR31: CV_HREG_e = CV_HREG_e(73i32);
pub const CV_PPC_FPSCR: CV_HREG_e = CV_HREG_e(74i32);
pub const CV_PPC_MSR: CV_HREG_e = CV_HREG_e(75i32);
pub const CV_PPC_SR0: CV_HREG_e = CV_HREG_e(76i32);
pub const CV_PPC_SR1: CV_HREG_e = CV_HREG_e(77i32);
pub const CV_PPC_SR2: CV_HREG_e = CV_HREG_e(78i32);
pub const CV_PPC_SR3: CV_HREG_e = CV_HREG_e(79i32);
pub const CV_PPC_SR4: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_PPC_SR5: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_PPC_SR6: CV_HREG_e = CV_HREG_e(82i32);
pub const CV_PPC_SR7: CV_HREG_e = CV_HREG_e(83i32);
pub const CV_PPC_SR8: CV_HREG_e = CV_HREG_e(84i32);
pub const CV_PPC_SR9: CV_HREG_e = CV_HREG_e(85i32);
pub const CV_PPC_SR10: CV_HREG_e = CV_HREG_e(86i32);
pub const CV_PPC_SR11: CV_HREG_e = CV_HREG_e(87i32);
pub const CV_PPC_SR12: CV_HREG_e = CV_HREG_e(88i32);
pub const CV_PPC_SR13: CV_HREG_e = CV_HREG_e(89i32);
pub const CV_PPC_SR14: CV_HREG_e = CV_HREG_e(90i32);
pub const CV_PPC_SR15: CV_HREG_e = CV_HREG_e(91i32);
pub const CV_PPC_PC: CV_HREG_e = CV_HREG_e(99i32);
pub const CV_PPC_MQ: CV_HREG_e = CV_HREG_e(100i32);
pub const CV_PPC_XER: CV_HREG_e = CV_HREG_e(101i32);
pub const CV_PPC_RTCU: CV_HREG_e = CV_HREG_e(104i32);
pub const CV_PPC_RTCL: CV_HREG_e = CV_HREG_e(105i32);
pub const CV_PPC_LR: CV_HREG_e = CV_HREG_e(108i32);
pub const CV_PPC_CTR: CV_HREG_e = CV_HREG_e(109i32);
pub const CV_PPC_COMPARE: CV_HREG_e = CV_HREG_e(110i32);
pub const CV_PPC_COUNT: CV_HREG_e = CV_HREG_e(111i32);
pub const CV_PPC_DSISR: CV_HREG_e = CV_HREG_e(118i32);
pub const CV_PPC_DAR: CV_HREG_e = CV_HREG_e(119i32);
pub const CV_PPC_DEC: CV_HREG_e = CV_HREG_e(122i32);
pub const CV_PPC_SDR1: CV_HREG_e = CV_HREG_e(125i32);
pub const CV_PPC_SRR0: CV_HREG_e = CV_HREG_e(126i32);
pub const CV_PPC_SRR1: CV_HREG_e = CV_HREG_e(127i32);
pub const CV_PPC_SPRG0: CV_HREG_e = CV_HREG_e(372i32);
pub const CV_PPC_SPRG1: CV_HREG_e = CV_HREG_e(373i32);
pub const CV_PPC_SPRG2: CV_HREG_e = CV_HREG_e(374i32);
pub const CV_PPC_SPRG3: CV_HREG_e = CV_HREG_e(375i32);
pub const CV_PPC_ASR: CV_HREG_e = CV_HREG_e(280i32);
pub const CV_PPC_EAR: CV_HREG_e = CV_HREG_e(382i32);
pub const CV_PPC_PVR: CV_HREG_e = CV_HREG_e(287i32);
pub const CV_PPC_BAT0U: CV_HREG_e = CV_HREG_e(628i32);
pub const CV_PPC_BAT0L: CV_HREG_e = CV_HREG_e(629i32);
pub const CV_PPC_BAT1U: CV_HREG_e = CV_HREG_e(630i32);
pub const CV_PPC_BAT1L: CV_HREG_e = CV_HREG_e(631i32);
pub const CV_PPC_BAT2U: CV_HREG_e = CV_HREG_e(632i32);
pub const CV_PPC_BAT2L: CV_HREG_e = CV_HREG_e(633i32);
pub const CV_PPC_BAT3U: CV_HREG_e = CV_HREG_e(634i32);
pub const CV_PPC_BAT3L: CV_HREG_e = CV_HREG_e(635i32);
pub const CV_PPC_DBAT0U: CV_HREG_e = CV_HREG_e(636i32);
pub const CV_PPC_DBAT0L: CV_HREG_e = CV_HREG_e(637i32);
pub const CV_PPC_DBAT1U: CV_HREG_e = CV_HREG_e(638i32);
pub const CV_PPC_DBAT1L: CV_HREG_e = CV_HREG_e(639i32);
pub const CV_PPC_DBAT2U: CV_HREG_e = CV_HREG_e(640i32);
pub const CV_PPC_DBAT2L: CV_HREG_e = CV_HREG_e(641i32);
pub const CV_PPC_DBAT3U: CV_HREG_e = CV_HREG_e(642i32);
pub const CV_PPC_DBAT3L: CV_HREG_e = CV_HREG_e(643i32);
pub const CV_PPC_PMR0: CV_HREG_e = CV_HREG_e(1044i32);
pub const CV_PPC_PMR1: CV_HREG_e = CV_HREG_e(1045i32);
pub const CV_PPC_PMR2: CV_HREG_e = CV_HREG_e(1046i32);
pub const CV_PPC_PMR3: CV_HREG_e = CV_HREG_e(1047i32);
pub const CV_PPC_PMR4: CV_HREG_e = CV_HREG_e(1048i32);
pub const CV_PPC_PMR5: CV_HREG_e = CV_HREG_e(1049i32);
pub const CV_PPC_PMR6: CV_HREG_e = CV_HREG_e(1050i32);
pub const CV_PPC_PMR7: CV_HREG_e = CV_HREG_e(1051i32);
pub const CV_PPC_PMR8: CV_HREG_e = CV_HREG_e(1052i32);
pub const CV_PPC_PMR9: CV_HREG_e = CV_HREG_e(1053i32);
pub const CV_PPC_PMR10: CV_HREG_e = CV_HREG_e(1054i32);
pub const CV_PPC_PMR11: CV_HREG_e = CV_HREG_e(1055i32);
pub const CV_PPC_PMR12: CV_HREG_e = CV_HREG_e(1056i32);
pub const CV_PPC_PMR13: CV_HREG_e = CV_HREG_e(1057i32);
pub const CV_PPC_PMR14: CV_HREG_e = CV_HREG_e(1058i32);
pub const CV_PPC_PMR15: CV_HREG_e = CV_HREG_e(1059i32);
pub const CV_PPC_DMISS: CV_HREG_e = CV_HREG_e(1076i32);
pub const CV_PPC_DCMP: CV_HREG_e = CV_HREG_e(1077i32);
pub const CV_PPC_HASH1: CV_HREG_e = CV_HREG_e(1078i32);
pub const CV_PPC_HASH2: CV_HREG_e = CV_HREG_e(1079i32);
pub const CV_PPC_IMISS: CV_HREG_e = CV_HREG_e(1080i32);
pub const CV_PPC_ICMP: CV_HREG_e = CV_HREG_e(1081i32);
pub const CV_PPC_RPA: CV_HREG_e = CV_HREG_e(1082i32);
pub const CV_PPC_HID0: CV_HREG_e = CV_HREG_e(1108i32);
pub const CV_PPC_HID1: CV_HREG_e = CV_HREG_e(1109i32);
pub const CV_PPC_HID2: CV_HREG_e = CV_HREG_e(1110i32);
pub const CV_PPC_HID3: CV_HREG_e = CV_HREG_e(1111i32);
pub const CV_PPC_HID4: CV_HREG_e = CV_HREG_e(1112i32);
pub const CV_PPC_HID5: CV_HREG_e = CV_HREG_e(1113i32);
pub const CV_PPC_HID6: CV_HREG_e = CV_HREG_e(1114i32);
pub const CV_PPC_HID7: CV_HREG_e = CV_HREG_e(1115i32);
pub const CV_PPC_HID8: CV_HREG_e = CV_HREG_e(1116i32);
pub const CV_PPC_HID9: CV_HREG_e = CV_HREG_e(1117i32);
pub const CV_PPC_HID10: CV_HREG_e = CV_HREG_e(1118i32);
pub const CV_PPC_HID11: CV_HREG_e = CV_HREG_e(1119i32);
pub const CV_PPC_HID12: CV_HREG_e = CV_HREG_e(1120i32);
pub const CV_PPC_HID13: CV_HREG_e = CV_HREG_e(1121i32);
pub const CV_PPC_HID14: CV_HREG_e = CV_HREG_e(1122i32);
pub const CV_PPC_HID15: CV_HREG_e = CV_HREG_e(1123i32);
pub const CV_JAVA_PC: CV_HREG_e = CV_HREG_e(1i32);
pub const CV_SH3_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_SH3_IntR0: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_SH3_IntR1: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_SH3_IntR2: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_SH3_IntR3: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_SH3_IntR4: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_SH3_IntR5: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_SH3_IntR6: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_SH3_IntR7: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_SH3_IntR8: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_SH3_IntR9: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_SH3_IntR10: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_SH3_IntR11: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_SH3_IntR12: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_SH3_IntR13: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_SH3_IntFp: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_SH3_IntSp: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_SH3_Gbr: CV_HREG_e = CV_HREG_e(38i32);
pub const CV_SH3_Pr: CV_HREG_e = CV_HREG_e(39i32);
pub const CV_SH3_Mach: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_SH3_Macl: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_SH3_Pc: CV_HREG_e = CV_HREG_e(50i32);
pub const CV_SH3_Sr: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_SH3_BarA: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_SH3_BasrA: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_SH3_BamrA: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_SH3_BbrA: CV_HREG_e = CV_HREG_e(63i32);
pub const CV_SH3_BarB: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_SH3_BasrB: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_SH3_BamrB: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_SH3_BbrB: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_SH3_BdrB: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_SH3_BdmrB: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_SH3_Brcr: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_SH_Fpscr: CV_HREG_e = CV_HREG_e(75i32);
pub const CV_SH_Fpul: CV_HREG_e = CV_HREG_e(76i32);
pub const CV_SH_FpR0: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_SH_FpR1: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_SH_FpR2: CV_HREG_e = CV_HREG_e(82i32);
pub const CV_SH_FpR3: CV_HREG_e = CV_HREG_e(83i32);
pub const CV_SH_FpR4: CV_HREG_e = CV_HREG_e(84i32);
pub const CV_SH_FpR5: CV_HREG_e = CV_HREG_e(85i32);
pub const CV_SH_FpR6: CV_HREG_e = CV_HREG_e(86i32);
pub const CV_SH_FpR7: CV_HREG_e = CV_HREG_e(87i32);
pub const CV_SH_FpR8: CV_HREG_e = CV_HREG_e(88i32);
pub const CV_SH_FpR9: CV_HREG_e = CV_HREG_e(89i32);
pub const CV_SH_FpR10: CV_HREG_e = CV_HREG_e(90i32);
pub const CV_SH_FpR11: CV_HREG_e = CV_HREG_e(91i32);
pub const CV_SH_FpR12: CV_HREG_e = CV_HREG_e(92i32);
pub const CV_SH_FpR13: CV_HREG_e = CV_HREG_e(93i32);
pub const CV_SH_FpR14: CV_HREG_e = CV_HREG_e(94i32);
pub const CV_SH_FpR15: CV_HREG_e = CV_HREG_e(95i32);
pub const CV_SH_XFpR0: CV_HREG_e = CV_HREG_e(96i32);
pub const CV_SH_XFpR1: CV_HREG_e = CV_HREG_e(97i32);
pub const CV_SH_XFpR2: CV_HREG_e = CV_HREG_e(98i32);
pub const CV_SH_XFpR3: CV_HREG_e = CV_HREG_e(99i32);
pub const CV_SH_XFpR4: CV_HREG_e = CV_HREG_e(100i32);
pub const CV_SH_XFpR5: CV_HREG_e = CV_HREG_e(101i32);
pub const CV_SH_XFpR6: CV_HREG_e = CV_HREG_e(102i32);
pub const CV_SH_XFpR7: CV_HREG_e = CV_HREG_e(103i32);
pub const CV_SH_XFpR8: CV_HREG_e = CV_HREG_e(104i32);
pub const CV_SH_XFpR9: CV_HREG_e = CV_HREG_e(105i32);
pub const CV_SH_XFpR10: CV_HREG_e = CV_HREG_e(106i32);
pub const CV_SH_XFpR11: CV_HREG_e = CV_HREG_e(107i32);
pub const CV_SH_XFpR12: CV_HREG_e = CV_HREG_e(108i32);
pub const CV_SH_XFpR13: CV_HREG_e = CV_HREG_e(109i32);
pub const CV_SH_XFpR14: CV_HREG_e = CV_HREG_e(110i32);
pub const CV_SH_XFpR15: CV_HREG_e = CV_HREG_e(111i32);
pub const CV_ARM_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_ARM_R0: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_ARM_R1: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_ARM_R2: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_ARM_R3: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_ARM_R4: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_ARM_R5: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_ARM_R6: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_ARM_R7: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_ARM_R8: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_ARM_R9: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_ARM_R10: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_ARM_R11: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_ARM_R12: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_ARM_SP: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_ARM_LR: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_ARM_PC: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_ARM_CPSR: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_ARM_ACC0: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_ARM_FPSCR: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_ARM_FPEXC: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_ARM_FS0: CV_HREG_e = CV_HREG_e(50i32);
pub const CV_ARM_FS1: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_ARM_FS2: CV_HREG_e = CV_HREG_e(52i32);
pub const CV_ARM_FS3: CV_HREG_e = CV_HREG_e(53i32);
pub const CV_ARM_FS4: CV_HREG_e = CV_HREG_e(54i32);
pub const CV_ARM_FS5: CV_HREG_e = CV_HREG_e(55i32);
pub const CV_ARM_FS6: CV_HREG_e = CV_HREG_e(56i32);
pub const CV_ARM_FS7: CV_HREG_e = CV_HREG_e(57i32);
pub const CV_ARM_FS8: CV_HREG_e = CV_HREG_e(58i32);
pub const CV_ARM_FS9: CV_HREG_e = CV_HREG_e(59i32);
pub const CV_ARM_FS10: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_ARM_FS11: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_ARM_FS12: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_ARM_FS13: CV_HREG_e = CV_HREG_e(63i32);
pub const CV_ARM_FS14: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_ARM_FS15: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_ARM_FS16: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_ARM_FS17: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_ARM_FS18: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_ARM_FS19: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_ARM_FS20: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_ARM_FS21: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_ARM_FS22: CV_HREG_e = CV_HREG_e(72i32);
pub const CV_ARM_FS23: CV_HREG_e = CV_HREG_e(73i32);
pub const CV_ARM_FS24: CV_HREG_e = CV_HREG_e(74i32);
pub const CV_ARM_FS25: CV_HREG_e = CV_HREG_e(75i32);
pub const CV_ARM_FS26: CV_HREG_e = CV_HREG_e(76i32);
pub const CV_ARM_FS27: CV_HREG_e = CV_HREG_e(77i32);
pub const CV_ARM_FS28: CV_HREG_e = CV_HREG_e(78i32);
pub const CV_ARM_FS29: CV_HREG_e = CV_HREG_e(79i32);
pub const CV_ARM_FS30: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_ARM_FS31: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_ARM_FPEXTRA0: CV_HREG_e = CV_HREG_e(90i32);
pub const CV_ARM_FPEXTRA1: CV_HREG_e = CV_HREG_e(91i32);
pub const CV_ARM_FPEXTRA2: CV_HREG_e = CV_HREG_e(92i32);
pub const CV_ARM_FPEXTRA3: CV_HREG_e = CV_HREG_e(93i32);
pub const CV_ARM_FPEXTRA4: CV_HREG_e = CV_HREG_e(94i32);
pub const CV_ARM_FPEXTRA5: CV_HREG_e = CV_HREG_e(95i32);
pub const CV_ARM_FPEXTRA6: CV_HREG_e = CV_HREG_e(96i32);
pub const CV_ARM_FPEXTRA7: CV_HREG_e = CV_HREG_e(97i32);
pub const CV_ARM_WR0: CV_HREG_e = CV_HREG_e(128i32);
pub const CV_ARM_WR1: CV_HREG_e = CV_HREG_e(129i32);
pub const CV_ARM_WR2: CV_HREG_e = CV_HREG_e(130i32);
pub const CV_ARM_WR3: CV_HREG_e = CV_HREG_e(131i32);
pub const CV_ARM_WR4: CV_HREG_e = CV_HREG_e(132i32);
pub const CV_ARM_WR5: CV_HREG_e = CV_HREG_e(133i32);
pub const CV_ARM_WR6: CV_HREG_e = CV_HREG_e(134i32);
pub const CV_ARM_WR7: CV_HREG_e = CV_HREG_e(135i32);
pub const CV_ARM_WR8: CV_HREG_e = CV_HREG_e(136i32);
pub const CV_ARM_WR9: CV_HREG_e = CV_HREG_e(137i32);
pub const CV_ARM_WR10: CV_HREG_e = CV_HREG_e(138i32);
pub const CV_ARM_WR11: CV_HREG_e = CV_HREG_e(139i32);
pub const CV_ARM_WR12: CV_HREG_e = CV_HREG_e(140i32);
pub const CV_ARM_WR13: CV_HREG_e = CV_HREG_e(141i32);
pub const CV_ARM_WR14: CV_HREG_e = CV_HREG_e(142i32);
pub const CV_ARM_WR15: CV_HREG_e = CV_HREG_e(143i32);
pub const CV_ARM_WCID: CV_HREG_e = CV_HREG_e(144i32);
pub const CV_ARM_WCON: CV_HREG_e = CV_HREG_e(145i32);
pub const CV_ARM_WCSSF: CV_HREG_e = CV_HREG_e(146i32);
pub const CV_ARM_WCASF: CV_HREG_e = CV_HREG_e(147i32);
pub const CV_ARM_WC4: CV_HREG_e = CV_HREG_e(148i32);
pub const CV_ARM_WC5: CV_HREG_e = CV_HREG_e(149i32);
pub const CV_ARM_WC6: CV_HREG_e = CV_HREG_e(150i32);
pub const CV_ARM_WC7: CV_HREG_e = CV_HREG_e(151i32);
pub const CV_ARM_WCGR0: CV_HREG_e = CV_HREG_e(152i32);
pub const CV_ARM_WCGR1: CV_HREG_e = CV_HREG_e(153i32);
pub const CV_ARM_WCGR2: CV_HREG_e = CV_HREG_e(154i32);
pub const CV_ARM_WCGR3: CV_HREG_e = CV_HREG_e(155i32);
pub const CV_ARM_WC12: CV_HREG_e = CV_HREG_e(156i32);
pub const CV_ARM_WC13: CV_HREG_e = CV_HREG_e(157i32);
pub const CV_ARM_WC14: CV_HREG_e = CV_HREG_e(158i32);
pub const CV_ARM_WC15: CV_HREG_e = CV_HREG_e(159i32);
pub const CV_ARM_FS32: CV_HREG_e = CV_HREG_e(200i32);
pub const CV_ARM_FS33: CV_HREG_e = CV_HREG_e(201i32);
pub const CV_ARM_FS34: CV_HREG_e = CV_HREG_e(202i32);
pub const CV_ARM_FS35: CV_HREG_e = CV_HREG_e(203i32);
pub const CV_ARM_FS36: CV_HREG_e = CV_HREG_e(204i32);
pub const CV_ARM_FS37: CV_HREG_e = CV_HREG_e(205i32);
pub const CV_ARM_FS38: CV_HREG_e = CV_HREG_e(206i32);
pub const CV_ARM_FS39: CV_HREG_e = CV_HREG_e(207i32);
pub const CV_ARM_FS40: CV_HREG_e = CV_HREG_e(208i32);
pub const CV_ARM_FS41: CV_HREG_e = CV_HREG_e(209i32);
pub const CV_ARM_FS42: CV_HREG_e = CV_HREG_e(210i32);
pub const CV_ARM_FS43: CV_HREG_e = CV_HREG_e(211i32);
pub const CV_ARM_FS44: CV_HREG_e = CV_HREG_e(212i32);
pub const CV_ARM_FS45: CV_HREG_e = CV_HREG_e(213i32);
pub const CV_ARM_FS46: CV_HREG_e = CV_HREG_e(214i32);
pub const CV_ARM_FS47: CV_HREG_e = CV_HREG_e(215i32);
pub const CV_ARM_FS48: CV_HREG_e = CV_HREG_e(216i32);
pub const CV_ARM_FS49: CV_HREG_e = CV_HREG_e(217i32);
pub const CV_ARM_FS50: CV_HREG_e = CV_HREG_e(218i32);
pub const CV_ARM_FS51: CV_HREG_e = CV_HREG_e(219i32);
pub const CV_ARM_FS52: CV_HREG_e = CV_HREG_e(220i32);
pub const CV_ARM_FS53: CV_HREG_e = CV_HREG_e(221i32);
pub const CV_ARM_FS54: CV_HREG_e = CV_HREG_e(222i32);
pub const CV_ARM_FS55: CV_HREG_e = CV_HREG_e(223i32);
pub const CV_ARM_FS56: CV_HREG_e = CV_HREG_e(224i32);
pub const CV_ARM_FS57: CV_HREG_e = CV_HREG_e(225i32);
pub const CV_ARM_FS58: CV_HREG_e = CV_HREG_e(226i32);
pub const CV_ARM_FS59: CV_HREG_e = CV_HREG_e(227i32);
pub const CV_ARM_FS60: CV_HREG_e = CV_HREG_e(228i32);
pub const CV_ARM_FS61: CV_HREG_e = CV_HREG_e(229i32);
pub const CV_ARM_FS62: CV_HREG_e = CV_HREG_e(230i32);
pub const CV_ARM_FS63: CV_HREG_e = CV_HREG_e(231i32);
pub const CV_ARM_ND0: CV_HREG_e = CV_HREG_e(300i32);
pub const CV_ARM_ND1: CV_HREG_e = CV_HREG_e(301i32);
pub const CV_ARM_ND2: CV_HREG_e = CV_HREG_e(302i32);
pub const CV_ARM_ND3: CV_HREG_e = CV_HREG_e(303i32);
pub const CV_ARM_ND4: CV_HREG_e = CV_HREG_e(304i32);
pub const CV_ARM_ND5: CV_HREG_e = CV_HREG_e(305i32);
pub const CV_ARM_ND6: CV_HREG_e = CV_HREG_e(306i32);
pub const CV_ARM_ND7: CV_HREG_e = CV_HREG_e(307i32);
pub const CV_ARM_ND8: CV_HREG_e = CV_HREG_e(308i32);
pub const CV_ARM_ND9: CV_HREG_e = CV_HREG_e(309i32);
pub const CV_ARM_ND10: CV_HREG_e = CV_HREG_e(310i32);
pub const CV_ARM_ND11: CV_HREG_e = CV_HREG_e(311i32);
pub const CV_ARM_ND12: CV_HREG_e = CV_HREG_e(312i32);
pub const CV_ARM_ND13: CV_HREG_e = CV_HREG_e(313i32);
pub const CV_ARM_ND14: CV_HREG_e = CV_HREG_e(314i32);
pub const CV_ARM_ND15: CV_HREG_e = CV_HREG_e(315i32);
pub const CV_ARM_ND16: CV_HREG_e = CV_HREG_e(316i32);
pub const CV_ARM_ND17: CV_HREG_e = CV_HREG_e(317i32);
pub const CV_ARM_ND18: CV_HREG_e = CV_HREG_e(318i32);
pub const CV_ARM_ND19: CV_HREG_e = CV_HREG_e(319i32);
pub const CV_ARM_ND20: CV_HREG_e = CV_HREG_e(320i32);
pub const CV_ARM_ND21: CV_HREG_e = CV_HREG_e(321i32);
pub const CV_ARM_ND22: CV_HREG_e = CV_HREG_e(322i32);
pub const CV_ARM_ND23: CV_HREG_e = CV_HREG_e(323i32);
pub const CV_ARM_ND24: CV_HREG_e = CV_HREG_e(324i32);
pub const CV_ARM_ND25: CV_HREG_e = CV_HREG_e(325i32);
pub const CV_ARM_ND26: CV_HREG_e = CV_HREG_e(326i32);
pub const CV_ARM_ND27: CV_HREG_e = CV_HREG_e(327i32);
pub const CV_ARM_ND28: CV_HREG_e = CV_HREG_e(328i32);
pub const CV_ARM_ND29: CV_HREG_e = CV_HREG_e(329i32);
pub const CV_ARM_ND30: CV_HREG_e = CV_HREG_e(330i32);
pub const CV_ARM_ND31: CV_HREG_e = CV_HREG_e(331i32);
pub const CV_ARM_NQ0: CV_HREG_e = CV_HREG_e(400i32);
pub const CV_ARM_NQ1: CV_HREG_e = CV_HREG_e(401i32);
pub const CV_ARM_NQ2: CV_HREG_e = CV_HREG_e(402i32);
pub const CV_ARM_NQ3: CV_HREG_e = CV_HREG_e(403i32);
pub const CV_ARM_NQ4: CV_HREG_e = CV_HREG_e(404i32);
pub const CV_ARM_NQ5: CV_HREG_e = CV_HREG_e(405i32);
pub const CV_ARM_NQ6: CV_HREG_e = CV_HREG_e(406i32);
pub const CV_ARM_NQ7: CV_HREG_e = CV_HREG_e(407i32);
pub const CV_ARM_NQ8: CV_HREG_e = CV_HREG_e(408i32);
pub const CV_ARM_NQ9: CV_HREG_e = CV_HREG_e(409i32);
pub const CV_ARM_NQ10: CV_HREG_e = CV_HREG_e(410i32);
pub const CV_ARM_NQ11: CV_HREG_e = CV_HREG_e(411i32);
pub const CV_ARM_NQ12: CV_HREG_e = CV_HREG_e(412i32);
pub const CV_ARM_NQ13: CV_HREG_e = CV_HREG_e(413i32);
pub const CV_ARM_NQ14: CV_HREG_e = CV_HREG_e(414i32);
pub const CV_ARM_NQ15: CV_HREG_e = CV_HREG_e(415i32);
pub const CV_ARM64_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_ARM64_W0: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_ARM64_W1: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_ARM64_W2: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_ARM64_W3: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_ARM64_W4: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_ARM64_W5: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_ARM64_W6: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_ARM64_W7: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_ARM64_W8: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_ARM64_W9: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_ARM64_W10: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_ARM64_W11: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_ARM64_W12: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_ARM64_W13: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_ARM64_W14: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_ARM64_W15: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_ARM64_W16: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_ARM64_W17: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_ARM64_W18: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_ARM64_W19: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_ARM64_W20: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_ARM64_W21: CV_HREG_e = CV_HREG_e(31i32);
pub const CV_ARM64_W22: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_ARM64_W23: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_ARM64_W24: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_ARM64_W25: CV_HREG_e = CV_HREG_e(35i32);
pub const CV_ARM64_W26: CV_HREG_e = CV_HREG_e(36i32);
pub const CV_ARM64_W27: CV_HREG_e = CV_HREG_e(37i32);
pub const CV_ARM64_W28: CV_HREG_e = CV_HREG_e(38i32);
pub const CV_ARM64_W29: CV_HREG_e = CV_HREG_e(39i32);
pub const CV_ARM64_W30: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_ARM64_WZR: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_ARM64_X0: CV_HREG_e = CV_HREG_e(50i32);
pub const CV_ARM64_X1: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_ARM64_X2: CV_HREG_e = CV_HREG_e(52i32);
pub const CV_ARM64_X3: CV_HREG_e = CV_HREG_e(53i32);
pub const CV_ARM64_X4: CV_HREG_e = CV_HREG_e(54i32);
pub const CV_ARM64_X5: CV_HREG_e = CV_HREG_e(55i32);
pub const CV_ARM64_X6: CV_HREG_e = CV_HREG_e(56i32);
pub const CV_ARM64_X7: CV_HREG_e = CV_HREG_e(57i32);
pub const CV_ARM64_X8: CV_HREG_e = CV_HREG_e(58i32);
pub const CV_ARM64_X9: CV_HREG_e = CV_HREG_e(59i32);
pub const CV_ARM64_X10: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_ARM64_X11: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_ARM64_X12: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_ARM64_X13: CV_HREG_e = CV_HREG_e(63i32);
pub const CV_ARM64_X14: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_ARM64_X15: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_ARM64_IP0: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_ARM64_IP1: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_ARM64_X18: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_ARM64_X19: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_ARM64_X20: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_ARM64_X21: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_ARM64_X22: CV_HREG_e = CV_HREG_e(72i32);
pub const CV_ARM64_X23: CV_HREG_e = CV_HREG_e(73i32);
pub const CV_ARM64_X24: CV_HREG_e = CV_HREG_e(74i32);
pub const CV_ARM64_X25: CV_HREG_e = CV_HREG_e(75i32);
pub const CV_ARM64_X26: CV_HREG_e = CV_HREG_e(76i32);
pub const CV_ARM64_X27: CV_HREG_e = CV_HREG_e(77i32);
pub const CV_ARM64_X28: CV_HREG_e = CV_HREG_e(78i32);
pub const CV_ARM64_FP: CV_HREG_e = CV_HREG_e(79i32);
pub const CV_ARM64_LR: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_ARM64_SP: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_ARM64_ZR: CV_HREG_e = CV_HREG_e(82i32);
pub const CV_ARM64_PC: CV_HREG_e = CV_HREG_e(83i32);
pub const CV_ARM64_NZCV: CV_HREG_e = CV_HREG_e(90i32);
pub const CV_ARM64_CPSR: CV_HREG_e = CV_HREG_e(91i32);
pub const CV_ARM64_S0: CV_HREG_e = CV_HREG_e(100i32);
pub const CV_ARM64_S1: CV_HREG_e = CV_HREG_e(101i32);
pub const CV_ARM64_S2: CV_HREG_e = CV_HREG_e(102i32);
pub const CV_ARM64_S3: CV_HREG_e = CV_HREG_e(103i32);
pub const CV_ARM64_S4: CV_HREG_e = CV_HREG_e(104i32);
pub const CV_ARM64_S5: CV_HREG_e = CV_HREG_e(105i32);
pub const CV_ARM64_S6: CV_HREG_e = CV_HREG_e(106i32);
pub const CV_ARM64_S7: CV_HREG_e = CV_HREG_e(107i32);
pub const CV_ARM64_S8: CV_HREG_e = CV_HREG_e(108i32);
pub const CV_ARM64_S9: CV_HREG_e = CV_HREG_e(109i32);
pub const CV_ARM64_S10: CV_HREG_e = CV_HREG_e(110i32);
pub const CV_ARM64_S11: CV_HREG_e = CV_HREG_e(111i32);
pub const CV_ARM64_S12: CV_HREG_e = CV_HREG_e(112i32);
pub const CV_ARM64_S13: CV_HREG_e = CV_HREG_e(113i32);
pub const CV_ARM64_S14: CV_HREG_e = CV_HREG_e(114i32);
pub const CV_ARM64_S15: CV_HREG_e = CV_HREG_e(115i32);
pub const CV_ARM64_S16: CV_HREG_e = CV_HREG_e(116i32);
pub const CV_ARM64_S17: CV_HREG_e = CV_HREG_e(117i32);
pub const CV_ARM64_S18: CV_HREG_e = CV_HREG_e(118i32);
pub const CV_ARM64_S19: CV_HREG_e = CV_HREG_e(119i32);
pub const CV_ARM64_S20: CV_HREG_e = CV_HREG_e(120i32);
pub const CV_ARM64_S21: CV_HREG_e = CV_HREG_e(121i32);
pub const CV_ARM64_S22: CV_HREG_e = CV_HREG_e(122i32);
pub const CV_ARM64_S23: CV_HREG_e = CV_HREG_e(123i32);
pub const CV_ARM64_S24: CV_HREG_e = CV_HREG_e(124i32);
pub const CV_ARM64_S25: CV_HREG_e = CV_HREG_e(125i32);
pub const CV_ARM64_S26: CV_HREG_e = CV_HREG_e(126i32);
pub const CV_ARM64_S27: CV_HREG_e = CV_HREG_e(127i32);
pub const CV_ARM64_S28: CV_HREG_e = CV_HREG_e(128i32);
pub const CV_ARM64_S29: CV_HREG_e = CV_HREG_e(129i32);
pub const CV_ARM64_S30: CV_HREG_e = CV_HREG_e(130i32);
pub const CV_ARM64_S31: CV_HREG_e = CV_HREG_e(131i32);
pub const CV_ARM64_D0: CV_HREG_e = CV_HREG_e(140i32);
pub const CV_ARM64_D1: CV_HREG_e = CV_HREG_e(141i32);
pub const CV_ARM64_D2: CV_HREG_e = CV_HREG_e(142i32);
pub const CV_ARM64_D3: CV_HREG_e = CV_HREG_e(143i32);
pub const CV_ARM64_D4: CV_HREG_e = CV_HREG_e(144i32);
pub const CV_ARM64_D5: CV_HREG_e = CV_HREG_e(145i32);
pub const CV_ARM64_D6: CV_HREG_e = CV_HREG_e(146i32);
pub const CV_ARM64_D7: CV_HREG_e = CV_HREG_e(147i32);
pub const CV_ARM64_D8: CV_HREG_e = CV_HREG_e(148i32);
pub const CV_ARM64_D9: CV_HREG_e = CV_HREG_e(149i32);
pub const CV_ARM64_D10: CV_HREG_e = CV_HREG_e(150i32);
pub const CV_ARM64_D11: CV_HREG_e = CV_HREG_e(151i32);
pub const CV_ARM64_D12: CV_HREG_e = CV_HREG_e(152i32);
pub const CV_ARM64_D13: CV_HREG_e = CV_HREG_e(153i32);
pub const CV_ARM64_D14: CV_HREG_e = CV_HREG_e(154i32);
pub const CV_ARM64_D15: CV_HREG_e = CV_HREG_e(155i32);
pub const CV_ARM64_D16: CV_HREG_e = CV_HREG_e(156i32);
pub const CV_ARM64_D17: CV_HREG_e = CV_HREG_e(157i32);
pub const CV_ARM64_D18: CV_HREG_e = CV_HREG_e(158i32);
pub const CV_ARM64_D19: CV_HREG_e = CV_HREG_e(159i32);
pub const CV_ARM64_D20: CV_HREG_e = CV_HREG_e(160i32);
pub const CV_ARM64_D21: CV_HREG_e = CV_HREG_e(161i32);
pub const CV_ARM64_D22: CV_HREG_e = CV_HREG_e(162i32);
pub const CV_ARM64_D23: CV_HREG_e = CV_HREG_e(163i32);
pub const CV_ARM64_D24: CV_HREG_e = CV_HREG_e(164i32);
pub const CV_ARM64_D25: CV_HREG_e = CV_HREG_e(165i32);
pub const CV_ARM64_D26: CV_HREG_e = CV_HREG_e(166i32);
pub const CV_ARM64_D27: CV_HREG_e = CV_HREG_e(167i32);
pub const CV_ARM64_D28: CV_HREG_e = CV_HREG_e(168i32);
pub const CV_ARM64_D29: CV_HREG_e = CV_HREG_e(169i32);
pub const CV_ARM64_D30: CV_HREG_e = CV_HREG_e(170i32);
pub const CV_ARM64_D31: CV_HREG_e = CV_HREG_e(171i32);
pub const CV_ARM64_Q0: CV_HREG_e = CV_HREG_e(180i32);
pub const CV_ARM64_Q1: CV_HREG_e = CV_HREG_e(181i32);
pub const CV_ARM64_Q2: CV_HREG_e = CV_HREG_e(182i32);
pub const CV_ARM64_Q3: CV_HREG_e = CV_HREG_e(183i32);
pub const CV_ARM64_Q4: CV_HREG_e = CV_HREG_e(184i32);
pub const CV_ARM64_Q5: CV_HREG_e = CV_HREG_e(185i32);
pub const CV_ARM64_Q6: CV_HREG_e = CV_HREG_e(186i32);
pub const CV_ARM64_Q7: CV_HREG_e = CV_HREG_e(187i32);
pub const CV_ARM64_Q8: CV_HREG_e = CV_HREG_e(188i32);
pub const CV_ARM64_Q9: CV_HREG_e = CV_HREG_e(189i32);
pub const CV_ARM64_Q10: CV_HREG_e = CV_HREG_e(190i32);
pub const CV_ARM64_Q11: CV_HREG_e = CV_HREG_e(191i32);
pub const CV_ARM64_Q12: CV_HREG_e = CV_HREG_e(192i32);
pub const CV_ARM64_Q13: CV_HREG_e = CV_HREG_e(193i32);
pub const CV_ARM64_Q14: CV_HREG_e = CV_HREG_e(194i32);
pub const CV_ARM64_Q15: CV_HREG_e = CV_HREG_e(195i32);
pub const CV_ARM64_Q16: CV_HREG_e = CV_HREG_e(196i32);
pub const CV_ARM64_Q17: CV_HREG_e = CV_HREG_e(197i32);
pub const CV_ARM64_Q18: CV_HREG_e = CV_HREG_e(198i32);
pub const CV_ARM64_Q19: CV_HREG_e = CV_HREG_e(199i32);
pub const CV_ARM64_Q20: CV_HREG_e = CV_HREG_e(200i32);
pub const CV_ARM64_Q21: CV_HREG_e = CV_HREG_e(201i32);
pub const CV_ARM64_Q22: CV_HREG_e = CV_HREG_e(202i32);
pub const CV_ARM64_Q23: CV_HREG_e = CV_HREG_e(203i32);
pub const CV_ARM64_Q24: CV_HREG_e = CV_HREG_e(204i32);
pub const CV_ARM64_Q25: CV_HREG_e = CV_HREG_e(205i32);
pub const CV_ARM64_Q26: CV_HREG_e = CV_HREG_e(206i32);
pub const CV_ARM64_Q27: CV_HREG_e = CV_HREG_e(207i32);
pub const CV_ARM64_Q28: CV_HREG_e = CV_HREG_e(208i32);
pub const CV_ARM64_Q29: CV_HREG_e = CV_HREG_e(209i32);
pub const CV_ARM64_Q30: CV_HREG_e = CV_HREG_e(210i32);
pub const CV_ARM64_Q31: CV_HREG_e = CV_HREG_e(211i32);
pub const CV_ARM64_FPSR: CV_HREG_e = CV_HREG_e(220i32);
pub const CV_ARM64_FPCR: CV_HREG_e = CV_HREG_e(221i32);
pub const CV_ARM64_B0: CV_HREG_e = CV_HREG_e(230i32);
pub const CV_ARM64_B1: CV_HREG_e = CV_HREG_e(231i32);
pub const CV_ARM64_B2: CV_HREG_e = CV_HREG_e(232i32);
pub const CV_ARM64_B3: CV_HREG_e = CV_HREG_e(233i32);
pub const CV_ARM64_B4: CV_HREG_e = CV_HREG_e(234i32);
pub const CV_ARM64_B5: CV_HREG_e = CV_HREG_e(235i32);
pub const CV_ARM64_B6: CV_HREG_e = CV_HREG_e(236i32);
pub const CV_ARM64_B7: CV_HREG_e = CV_HREG_e(237i32);
pub const CV_ARM64_B8: CV_HREG_e = CV_HREG_e(238i32);
pub const CV_ARM64_B9: CV_HREG_e = CV_HREG_e(239i32);
pub const CV_ARM64_B10: CV_HREG_e = CV_HREG_e(240i32);
pub const CV_ARM64_B11: CV_HREG_e = CV_HREG_e(241i32);
pub const CV_ARM64_B12: CV_HREG_e = CV_HREG_e(242i32);
pub const CV_ARM64_B13: CV_HREG_e = CV_HREG_e(243i32);
pub const CV_ARM64_B14: CV_HREG_e = CV_HREG_e(244i32);
pub const CV_ARM64_B15: CV_HREG_e = CV_HREG_e(245i32);
pub const CV_ARM64_B16: CV_HREG_e = CV_HREG_e(246i32);
pub const CV_ARM64_B17: CV_HREG_e = CV_HREG_e(247i32);
pub const CV_ARM64_B18: CV_HREG_e = CV_HREG_e(248i32);
pub const CV_ARM64_B19: CV_HREG_e = CV_HREG_e(249i32);
pub const CV_ARM64_B20: CV_HREG_e = CV_HREG_e(250i32);
pub const CV_ARM64_B21: CV_HREG_e = CV_HREG_e(251i32);
pub const CV_ARM64_B22: CV_HREG_e = CV_HREG_e(252i32);
pub const CV_ARM64_B23: CV_HREG_e = CV_HREG_e(253i32);
pub const CV_ARM64_B24: CV_HREG_e = CV_HREG_e(254i32);
pub const CV_ARM64_B25: CV_HREG_e = CV_HREG_e(255i32);
pub const CV_ARM64_B26: CV_HREG_e = CV_HREG_e(256i32);
pub const CV_ARM64_B27: CV_HREG_e = CV_HREG_e(257i32);
pub const CV_ARM64_B28: CV_HREG_e = CV_HREG_e(258i32);
pub const CV_ARM64_B29: CV_HREG_e = CV_HREG_e(259i32);
pub const CV_ARM64_B30: CV_HREG_e = CV_HREG_e(260i32);
pub const CV_ARM64_B31: CV_HREG_e = CV_HREG_e(261i32);
pub const CV_ARM64_H0: CV_HREG_e = CV_HREG_e(270i32);
pub const CV_ARM64_H1: CV_HREG_e = CV_HREG_e(271i32);
pub const CV_ARM64_H2: CV_HREG_e = CV_HREG_e(272i32);
pub const CV_ARM64_H3: CV_HREG_e = CV_HREG_e(273i32);
pub const CV_ARM64_H4: CV_HREG_e = CV_HREG_e(274i32);
pub const CV_ARM64_H5: CV_HREG_e = CV_HREG_e(275i32);
pub const CV_ARM64_H6: CV_HREG_e = CV_HREG_e(276i32);
pub const CV_ARM64_H7: CV_HREG_e = CV_HREG_e(277i32);
pub const CV_ARM64_H8: CV_HREG_e = CV_HREG_e(278i32);
pub const CV_ARM64_H9: CV_HREG_e = CV_HREG_e(279i32);
pub const CV_ARM64_H10: CV_HREG_e = CV_HREG_e(280i32);
pub const CV_ARM64_H11: CV_HREG_e = CV_HREG_e(281i32);
pub const CV_ARM64_H12: CV_HREG_e = CV_HREG_e(282i32);
pub const CV_ARM64_H13: CV_HREG_e = CV_HREG_e(283i32);
pub const CV_ARM64_H14: CV_HREG_e = CV_HREG_e(284i32);
pub const CV_ARM64_H15: CV_HREG_e = CV_HREG_e(285i32);
pub const CV_ARM64_H16: CV_HREG_e = CV_HREG_e(286i32);
pub const CV_ARM64_H17: CV_HREG_e = CV_HREG_e(287i32);
pub const CV_ARM64_H18: CV_HREG_e = CV_HREG_e(288i32);
pub const CV_ARM64_H19: CV_HREG_e = CV_HREG_e(289i32);
pub const CV_ARM64_H20: CV_HREG_e = CV_HREG_e(290i32);
pub const CV_ARM64_H21: CV_HREG_e = CV_HREG_e(291i32);
pub const CV_ARM64_H22: CV_HREG_e = CV_HREG_e(292i32);
pub const CV_ARM64_H23: CV_HREG_e = CV_HREG_e(293i32);
pub const CV_ARM64_H24: CV_HREG_e = CV_HREG_e(294i32);
pub const CV_ARM64_H25: CV_HREG_e = CV_HREG_e(295i32);
pub const CV_ARM64_H26: CV_HREG_e = CV_HREG_e(296i32);
pub const CV_ARM64_H27: CV_HREG_e = CV_HREG_e(297i32);
pub const CV_ARM64_H28: CV_HREG_e = CV_HREG_e(298i32);
pub const CV_ARM64_H29: CV_HREG_e = CV_HREG_e(299i32);
pub const CV_ARM64_H30: CV_HREG_e = CV_HREG_e(300i32);
pub const CV_ARM64_H31: CV_HREG_e = CV_HREG_e(301i32);
pub const CV_ARM64_V0: CV_HREG_e = CV_HREG_e(310i32);
pub const CV_ARM64_V1: CV_HREG_e = CV_HREG_e(311i32);
pub const CV_ARM64_V2: CV_HREG_e = CV_HREG_e(312i32);
pub const CV_ARM64_V3: CV_HREG_e = CV_HREG_e(313i32);
pub const CV_ARM64_V4: CV_HREG_e = CV_HREG_e(314i32);
pub const CV_ARM64_V5: CV_HREG_e = CV_HREG_e(315i32);
pub const CV_ARM64_V6: CV_HREG_e = CV_HREG_e(316i32);
pub const CV_ARM64_V7: CV_HREG_e = CV_HREG_e(317i32);
pub const CV_ARM64_V8: CV_HREG_e = CV_HREG_e(318i32);
pub const CV_ARM64_V9: CV_HREG_e = CV_HREG_e(319i32);
pub const CV_ARM64_V10: CV_HREG_e = CV_HREG_e(320i32);
pub const CV_ARM64_V11: CV_HREG_e = CV_HREG_e(321i32);
pub const CV_ARM64_V12: CV_HREG_e = CV_HREG_e(322i32);
pub const CV_ARM64_V13: CV_HREG_e = CV_HREG_e(323i32);
pub const CV_ARM64_V14: CV_HREG_e = CV_HREG_e(324i32);
pub const CV_ARM64_V15: CV_HREG_e = CV_HREG_e(325i32);
pub const CV_ARM64_V16: CV_HREG_e = CV_HREG_e(326i32);
pub const CV_ARM64_V17: CV_HREG_e = CV_HREG_e(327i32);
pub const CV_ARM64_V18: CV_HREG_e = CV_HREG_e(328i32);
pub const CV_ARM64_V19: CV_HREG_e = CV_HREG_e(329i32);
pub const CV_ARM64_V20: CV_HREG_e = CV_HREG_e(330i32);
pub const CV_ARM64_V21: CV_HREG_e = CV_HREG_e(331i32);
pub const CV_ARM64_V22: CV_HREG_e = CV_HREG_e(332i32);
pub const CV_ARM64_V23: CV_HREG_e = CV_HREG_e(333i32);
pub const CV_ARM64_V24: CV_HREG_e = CV_HREG_e(334i32);
pub const CV_ARM64_V25: CV_HREG_e = CV_HREG_e(335i32);
pub const CV_ARM64_V26: CV_HREG_e = CV_HREG_e(336i32);
pub const CV_ARM64_V27: CV_HREG_e = CV_HREG_e(337i32);
pub const CV_ARM64_V28: CV_HREG_e = CV_HREG_e(338i32);
pub const CV_ARM64_V29: CV_HREG_e = CV_HREG_e(339i32);
pub const CV_ARM64_V30: CV_HREG_e = CV_HREG_e(340i32);
pub const CV_ARM64_V31: CV_HREG_e = CV_HREG_e(341i32);
pub const CV_ARM64_Q0H: CV_HREG_e = CV_HREG_e(350i32);
pub const CV_ARM64_Q1H: CV_HREG_e = CV_HREG_e(351i32);
pub const CV_ARM64_Q2H: CV_HREG_e = CV_HREG_e(352i32);
pub const CV_ARM64_Q3H: CV_HREG_e = CV_HREG_e(353i32);
pub const CV_ARM64_Q4H: CV_HREG_e = CV_HREG_e(354i32);
pub const CV_ARM64_Q5H: CV_HREG_e = CV_HREG_e(355i32);
pub const CV_ARM64_Q6H: CV_HREG_e = CV_HREG_e(356i32);
pub const CV_ARM64_Q7H: CV_HREG_e = CV_HREG_e(357i32);
pub const CV_ARM64_Q8H: CV_HREG_e = CV_HREG_e(358i32);
pub const CV_ARM64_Q9H: CV_HREG_e = CV_HREG_e(359i32);
pub const CV_ARM64_Q10H: CV_HREG_e = CV_HREG_e(360i32);
pub const CV_ARM64_Q11H: CV_HREG_e = CV_HREG_e(361i32);
pub const CV_ARM64_Q12H: CV_HREG_e = CV_HREG_e(362i32);
pub const CV_ARM64_Q13H: CV_HREG_e = CV_HREG_e(363i32);
pub const CV_ARM64_Q14H: CV_HREG_e = CV_HREG_e(364i32);
pub const CV_ARM64_Q15H: CV_HREG_e = CV_HREG_e(365i32);
pub const CV_ARM64_Q16H: CV_HREG_e = CV_HREG_e(366i32);
pub const CV_ARM64_Q17H: CV_HREG_e = CV_HREG_e(367i32);
pub const CV_ARM64_Q18H: CV_HREG_e = CV_HREG_e(368i32);
pub const CV_ARM64_Q19H: CV_HREG_e = CV_HREG_e(369i32);
pub const CV_ARM64_Q20H: CV_HREG_e = CV_HREG_e(370i32);
pub const CV_ARM64_Q21H: CV_HREG_e = CV_HREG_e(371i32);
pub const CV_ARM64_Q22H: CV_HREG_e = CV_HREG_e(372i32);
pub const CV_ARM64_Q23H: CV_HREG_e = CV_HREG_e(373i32);
pub const CV_ARM64_Q24H: CV_HREG_e = CV_HREG_e(374i32);
pub const CV_ARM64_Q25H: CV_HREG_e = CV_HREG_e(375i32);
pub const CV_ARM64_Q26H: CV_HREG_e = CV_HREG_e(376i32);
pub const CV_ARM64_Q27H: CV_HREG_e = CV_HREG_e(377i32);
pub const CV_ARM64_Q28H: CV_HREG_e = CV_HREG_e(378i32);
pub const CV_ARM64_Q29H: CV_HREG_e = CV_HREG_e(379i32);
pub const CV_ARM64_Q30H: CV_HREG_e = CV_HREG_e(380i32);
pub const CV_ARM64_Q31H: CV_HREG_e = CV_HREG_e(381i32);
pub const CV_IA64_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_IA64_Br0: CV_HREG_e = CV_HREG_e(512i32);
pub const CV_IA64_Br1: CV_HREG_e = CV_HREG_e(513i32);
pub const CV_IA64_Br2: CV_HREG_e = CV_HREG_e(514i32);
pub const CV_IA64_Br3: CV_HREG_e = CV_HREG_e(515i32);
pub const CV_IA64_Br4: CV_HREG_e = CV_HREG_e(516i32);
pub const CV_IA64_Br5: CV_HREG_e = CV_HREG_e(517i32);
pub const CV_IA64_Br6: CV_HREG_e = CV_HREG_e(518i32);
pub const CV_IA64_Br7: CV_HREG_e = CV_HREG_e(519i32);
pub const CV_IA64_P0: CV_HREG_e = CV_HREG_e(704i32);
pub const CV_IA64_P1: CV_HREG_e = CV_HREG_e(705i32);
pub const CV_IA64_P2: CV_HREG_e = CV_HREG_e(706i32);
pub const CV_IA64_P3: CV_HREG_e = CV_HREG_e(707i32);
pub const CV_IA64_P4: CV_HREG_e = CV_HREG_e(708i32);
pub const CV_IA64_P5: CV_HREG_e = CV_HREG_e(709i32);
pub const CV_IA64_P6: CV_HREG_e = CV_HREG_e(710i32);
pub const CV_IA64_P7: CV_HREG_e = CV_HREG_e(711i32);
pub const CV_IA64_P8: CV_HREG_e = CV_HREG_e(712i32);
pub const CV_IA64_P9: CV_HREG_e = CV_HREG_e(713i32);
pub const CV_IA64_P10: CV_HREG_e = CV_HREG_e(714i32);
pub const CV_IA64_P11: CV_HREG_e = CV_HREG_e(715i32);
pub const CV_IA64_P12: CV_HREG_e = CV_HREG_e(716i32);
pub const CV_IA64_P13: CV_HREG_e = CV_HREG_e(717i32);
pub const CV_IA64_P14: CV_HREG_e = CV_HREG_e(718i32);
pub const CV_IA64_P15: CV_HREG_e = CV_HREG_e(719i32);
pub const CV_IA64_P16: CV_HREG_e = CV_HREG_e(720i32);
pub const CV_IA64_P17: CV_HREG_e = CV_HREG_e(721i32);
pub const CV_IA64_P18: CV_HREG_e = CV_HREG_e(722i32);
pub const CV_IA64_P19: CV_HREG_e = CV_HREG_e(723i32);
pub const CV_IA64_P20: CV_HREG_e = CV_HREG_e(724i32);
pub const CV_IA64_P21: CV_HREG_e = CV_HREG_e(725i32);
pub const CV_IA64_P22: CV_HREG_e = CV_HREG_e(726i32);
pub const CV_IA64_P23: CV_HREG_e = CV_HREG_e(727i32);
pub const CV_IA64_P24: CV_HREG_e = CV_HREG_e(728i32);
pub const CV_IA64_P25: CV_HREG_e = CV_HREG_e(729i32);
pub const CV_IA64_P26: CV_HREG_e = CV_HREG_e(730i32);
pub const CV_IA64_P27: CV_HREG_e = CV_HREG_e(731i32);
pub const CV_IA64_P28: CV_HREG_e = CV_HREG_e(732i32);
pub const CV_IA64_P29: CV_HREG_e = CV_HREG_e(733i32);
pub const CV_IA64_P30: CV_HREG_e = CV_HREG_e(734i32);
pub const CV_IA64_P31: CV_HREG_e = CV_HREG_e(735i32);
pub const CV_IA64_P32: CV_HREG_e = CV_HREG_e(736i32);
pub const CV_IA64_P33: CV_HREG_e = CV_HREG_e(737i32);
pub const CV_IA64_P34: CV_HREG_e = CV_HREG_e(738i32);
pub const CV_IA64_P35: CV_HREG_e = CV_HREG_e(739i32);
pub const CV_IA64_P36: CV_HREG_e = CV_HREG_e(740i32);
pub const CV_IA64_P37: CV_HREG_e = CV_HREG_e(741i32);
pub const CV_IA64_P38: CV_HREG_e = CV_HREG_e(742i32);
pub const CV_IA64_P39: CV_HREG_e = CV_HREG_e(743i32);
pub const CV_IA64_P40: CV_HREG_e = CV_HREG_e(744i32);
pub const CV_IA64_P41: CV_HREG_e = CV_HREG_e(745i32);
pub const CV_IA64_P42: CV_HREG_e = CV_HREG_e(746i32);
pub const CV_IA64_P43: CV_HREG_e = CV_HREG_e(747i32);
pub const CV_IA64_P44: CV_HREG_e = CV_HREG_e(748i32);
pub const CV_IA64_P45: CV_HREG_e = CV_HREG_e(749i32);
pub const CV_IA64_P46: CV_HREG_e = CV_HREG_e(750i32);
pub const CV_IA64_P47: CV_HREG_e = CV_HREG_e(751i32);
pub const CV_IA64_P48: CV_HREG_e = CV_HREG_e(752i32);
pub const CV_IA64_P49: CV_HREG_e = CV_HREG_e(753i32);
pub const CV_IA64_P50: CV_HREG_e = CV_HREG_e(754i32);
pub const CV_IA64_P51: CV_HREG_e = CV_HREG_e(755i32);
pub const CV_IA64_P52: CV_HREG_e = CV_HREG_e(756i32);
pub const CV_IA64_P53: CV_HREG_e = CV_HREG_e(757i32);
pub const CV_IA64_P54: CV_HREG_e = CV_HREG_e(758i32);
pub const CV_IA64_P55: CV_HREG_e = CV_HREG_e(759i32);
pub const CV_IA64_P56: CV_HREG_e = CV_HREG_e(760i32);
pub const CV_IA64_P57: CV_HREG_e = CV_HREG_e(761i32);
pub const CV_IA64_P58: CV_HREG_e = CV_HREG_e(762i32);
pub const CV_IA64_P59: CV_HREG_e = CV_HREG_e(763i32);
pub const CV_IA64_P60: CV_HREG_e = CV_HREG_e(764i32);
pub const CV_IA64_P61: CV_HREG_e = CV_HREG_e(765i32);
pub const CV_IA64_P62: CV_HREG_e = CV_HREG_e(766i32);
pub const CV_IA64_P63: CV_HREG_e = CV_HREG_e(767i32);
pub const CV_IA64_Preds: CV_HREG_e = CV_HREG_e(768i32);
pub const CV_IA64_IntH0: CV_HREG_e = CV_HREG_e(832i32);
pub const CV_IA64_IntH1: CV_HREG_e = CV_HREG_e(833i32);
pub const CV_IA64_IntH2: CV_HREG_e = CV_HREG_e(834i32);
pub const CV_IA64_IntH3: CV_HREG_e = CV_HREG_e(835i32);
pub const CV_IA64_IntH4: CV_HREG_e = CV_HREG_e(836i32);
pub const CV_IA64_IntH5: CV_HREG_e = CV_HREG_e(837i32);
pub const CV_IA64_IntH6: CV_HREG_e = CV_HREG_e(838i32);
pub const CV_IA64_IntH7: CV_HREG_e = CV_HREG_e(839i32);
pub const CV_IA64_IntH8: CV_HREG_e = CV_HREG_e(840i32);
pub const CV_IA64_IntH9: CV_HREG_e = CV_HREG_e(841i32);
pub const CV_IA64_IntH10: CV_HREG_e = CV_HREG_e(842i32);
pub const CV_IA64_IntH11: CV_HREG_e = CV_HREG_e(843i32);
pub const CV_IA64_IntH12: CV_HREG_e = CV_HREG_e(844i32);
pub const CV_IA64_IntH13: CV_HREG_e = CV_HREG_e(845i32);
pub const CV_IA64_IntH14: CV_HREG_e = CV_HREG_e(846i32);
pub const CV_IA64_IntH15: CV_HREG_e = CV_HREG_e(847i32);
pub const CV_IA64_Ip: CV_HREG_e = CV_HREG_e(1016i32);
pub const CV_IA64_Umask: CV_HREG_e = CV_HREG_e(1017i32);
pub const CV_IA64_Cfm: CV_HREG_e = CV_HREG_e(1018i32);
pub const CV_IA64_Psr: CV_HREG_e = CV_HREG_e(1019i32);
pub const CV_IA64_Nats: CV_HREG_e = CV_HREG_e(1020i32);
pub const CV_IA64_Nats2: CV_HREG_e = CV_HREG_e(1021i32);
pub const CV_IA64_Nats3: CV_HREG_e = CV_HREG_e(1022i32);
pub const CV_IA64_IntR0: CV_HREG_e = CV_HREG_e(1024i32);
pub const CV_IA64_IntR1: CV_HREG_e = CV_HREG_e(1025i32);
pub const CV_IA64_IntR2: CV_HREG_e = CV_HREG_e(1026i32);
pub const CV_IA64_IntR3: CV_HREG_e = CV_HREG_e(1027i32);
pub const CV_IA64_IntR4: CV_HREG_e = CV_HREG_e(1028i32);
pub const CV_IA64_IntR5: CV_HREG_e = CV_HREG_e(1029i32);
pub const CV_IA64_IntR6: CV_HREG_e = CV_HREG_e(1030i32);
pub const CV_IA64_IntR7: CV_HREG_e = CV_HREG_e(1031i32);
pub const CV_IA64_IntR8: CV_HREG_e = CV_HREG_e(1032i32);
pub const CV_IA64_IntR9: CV_HREG_e = CV_HREG_e(1033i32);
pub const CV_IA64_IntR10: CV_HREG_e = CV_HREG_e(1034i32);
pub const CV_IA64_IntR11: CV_HREG_e = CV_HREG_e(1035i32);
pub const CV_IA64_IntR12: CV_HREG_e = CV_HREG_e(1036i32);
pub const CV_IA64_IntR13: CV_HREG_e = CV_HREG_e(1037i32);
pub const CV_IA64_IntR14: CV_HREG_e = CV_HREG_e(1038i32);
pub const CV_IA64_IntR15: CV_HREG_e = CV_HREG_e(1039i32);
pub const CV_IA64_IntR16: CV_HREG_e = CV_HREG_e(1040i32);
pub const CV_IA64_IntR17: CV_HREG_e = CV_HREG_e(1041i32);
pub const CV_IA64_IntR18: CV_HREG_e = CV_HREG_e(1042i32);
pub const CV_IA64_IntR19: CV_HREG_e = CV_HREG_e(1043i32);
pub const CV_IA64_IntR20: CV_HREG_e = CV_HREG_e(1044i32);
pub const CV_IA64_IntR21: CV_HREG_e = CV_HREG_e(1045i32);
pub const CV_IA64_IntR22: CV_HREG_e = CV_HREG_e(1046i32);
pub const CV_IA64_IntR23: CV_HREG_e = CV_HREG_e(1047i32);
pub const CV_IA64_IntR24: CV_HREG_e = CV_HREG_e(1048i32);
pub const CV_IA64_IntR25: CV_HREG_e = CV_HREG_e(1049i32);
pub const CV_IA64_IntR26: CV_HREG_e = CV_HREG_e(1050i32);
pub const CV_IA64_IntR27: CV_HREG_e = CV_HREG_e(1051i32);
pub const CV_IA64_IntR28: CV_HREG_e = CV_HREG_e(1052i32);
pub const CV_IA64_IntR29: CV_HREG_e = CV_HREG_e(1053i32);
pub const CV_IA64_IntR30: CV_HREG_e = CV_HREG_e(1054i32);
pub const CV_IA64_IntR31: CV_HREG_e = CV_HREG_e(1055i32);
pub const CV_IA64_IntR32: CV_HREG_e = CV_HREG_e(1056i32);
pub const CV_IA64_IntR33: CV_HREG_e = CV_HREG_e(1057i32);
pub const CV_IA64_IntR34: CV_HREG_e = CV_HREG_e(1058i32);
pub const CV_IA64_IntR35: CV_HREG_e = CV_HREG_e(1059i32);
pub const CV_IA64_IntR36: CV_HREG_e = CV_HREG_e(1060i32);
pub const CV_IA64_IntR37: CV_HREG_e = CV_HREG_e(1061i32);
pub const CV_IA64_IntR38: CV_HREG_e = CV_HREG_e(1062i32);
pub const CV_IA64_IntR39: CV_HREG_e = CV_HREG_e(1063i32);
pub const CV_IA64_IntR40: CV_HREG_e = CV_HREG_e(1064i32);
pub const CV_IA64_IntR41: CV_HREG_e = CV_HREG_e(1065i32);
pub const CV_IA64_IntR42: CV_HREG_e = CV_HREG_e(1066i32);
pub const CV_IA64_IntR43: CV_HREG_e = CV_HREG_e(1067i32);
pub const CV_IA64_IntR44: CV_HREG_e = CV_HREG_e(1068i32);
pub const CV_IA64_IntR45: CV_HREG_e = CV_HREG_e(1069i32);
pub const CV_IA64_IntR46: CV_HREG_e = CV_HREG_e(1070i32);
pub const CV_IA64_IntR47: CV_HREG_e = CV_HREG_e(1071i32);
pub const CV_IA64_IntR48: CV_HREG_e = CV_HREG_e(1072i32);
pub const CV_IA64_IntR49: CV_HREG_e = CV_HREG_e(1073i32);
pub const CV_IA64_IntR50: CV_HREG_e = CV_HREG_e(1074i32);
pub const CV_IA64_IntR51: CV_HREG_e = CV_HREG_e(1075i32);
pub const CV_IA64_IntR52: CV_HREG_e = CV_HREG_e(1076i32);
pub const CV_IA64_IntR53: CV_HREG_e = CV_HREG_e(1077i32);
pub const CV_IA64_IntR54: CV_HREG_e = CV_HREG_e(1078i32);
pub const CV_IA64_IntR55: CV_HREG_e = CV_HREG_e(1079i32);
pub const CV_IA64_IntR56: CV_HREG_e = CV_HREG_e(1080i32);
pub const CV_IA64_IntR57: CV_HREG_e = CV_HREG_e(1081i32);
pub const CV_IA64_IntR58: CV_HREG_e = CV_HREG_e(1082i32);
pub const CV_IA64_IntR59: CV_HREG_e = CV_HREG_e(1083i32);
pub const CV_IA64_IntR60: CV_HREG_e = CV_HREG_e(1084i32);
pub const CV_IA64_IntR61: CV_HREG_e = CV_HREG_e(1085i32);
pub const CV_IA64_IntR62: CV_HREG_e = CV_HREG_e(1086i32);
pub const CV_IA64_IntR63: CV_HREG_e = CV_HREG_e(1087i32);
pub const CV_IA64_IntR64: CV_HREG_e = CV_HREG_e(1088i32);
pub const CV_IA64_IntR65: CV_HREG_e = CV_HREG_e(1089i32);
pub const CV_IA64_IntR66: CV_HREG_e = CV_HREG_e(1090i32);
pub const CV_IA64_IntR67: CV_HREG_e = CV_HREG_e(1091i32);
pub const CV_IA64_IntR68: CV_HREG_e = CV_HREG_e(1092i32);
pub const CV_IA64_IntR69: CV_HREG_e = CV_HREG_e(1093i32);
pub const CV_IA64_IntR70: CV_HREG_e = CV_HREG_e(1094i32);
pub const CV_IA64_IntR71: CV_HREG_e = CV_HREG_e(1095i32);
pub const CV_IA64_IntR72: CV_HREG_e = CV_HREG_e(1096i32);
pub const CV_IA64_IntR73: CV_HREG_e = CV_HREG_e(1097i32);
pub const CV_IA64_IntR74: CV_HREG_e = CV_HREG_e(1098i32);
pub const CV_IA64_IntR75: CV_HREG_e = CV_HREG_e(1099i32);
pub const CV_IA64_IntR76: CV_HREG_e = CV_HREG_e(1100i32);
pub const CV_IA64_IntR77: CV_HREG_e = CV_HREG_e(1101i32);
pub const CV_IA64_IntR78: CV_HREG_e = CV_HREG_e(1102i32);
pub const CV_IA64_IntR79: CV_HREG_e = CV_HREG_e(1103i32);
pub const CV_IA64_IntR80: CV_HREG_e = CV_HREG_e(1104i32);
pub const CV_IA64_IntR81: CV_HREG_e = CV_HREG_e(1105i32);
pub const CV_IA64_IntR82: CV_HREG_e = CV_HREG_e(1106i32);
pub const CV_IA64_IntR83: CV_HREG_e = CV_HREG_e(1107i32);
pub const CV_IA64_IntR84: CV_HREG_e = CV_HREG_e(1108i32);
pub const CV_IA64_IntR85: CV_HREG_e = CV_HREG_e(1109i32);
pub const CV_IA64_IntR86: CV_HREG_e = CV_HREG_e(1110i32);
pub const CV_IA64_IntR87: CV_HREG_e = CV_HREG_e(1111i32);
pub const CV_IA64_IntR88: CV_HREG_e = CV_HREG_e(1112i32);
pub const CV_IA64_IntR89: CV_HREG_e = CV_HREG_e(1113i32);
pub const CV_IA64_IntR90: CV_HREG_e = CV_HREG_e(1114i32);
pub const CV_IA64_IntR91: CV_HREG_e = CV_HREG_e(1115i32);
pub const CV_IA64_IntR92: CV_HREG_e = CV_HREG_e(1116i32);
pub const CV_IA64_IntR93: CV_HREG_e = CV_HREG_e(1117i32);
pub const CV_IA64_IntR94: CV_HREG_e = CV_HREG_e(1118i32);
pub const CV_IA64_IntR95: CV_HREG_e = CV_HREG_e(1119i32);
pub const CV_IA64_IntR96: CV_HREG_e = CV_HREG_e(1120i32);
pub const CV_IA64_IntR97: CV_HREG_e = CV_HREG_e(1121i32);
pub const CV_IA64_IntR98: CV_HREG_e = CV_HREG_e(1122i32);
pub const CV_IA64_IntR99: CV_HREG_e = CV_HREG_e(1123i32);
pub const CV_IA64_IntR100: CV_HREG_e = CV_HREG_e(1124i32);
pub const CV_IA64_IntR101: CV_HREG_e = CV_HREG_e(1125i32);
pub const CV_IA64_IntR102: CV_HREG_e = CV_HREG_e(1126i32);
pub const CV_IA64_IntR103: CV_HREG_e = CV_HREG_e(1127i32);
pub const CV_IA64_IntR104: CV_HREG_e = CV_HREG_e(1128i32);
pub const CV_IA64_IntR105: CV_HREG_e = CV_HREG_e(1129i32);
pub const CV_IA64_IntR106: CV_HREG_e = CV_HREG_e(1130i32);
pub const CV_IA64_IntR107: CV_HREG_e = CV_HREG_e(1131i32);
pub const CV_IA64_IntR108: CV_HREG_e = CV_HREG_e(1132i32);
pub const CV_IA64_IntR109: CV_HREG_e = CV_HREG_e(1133i32);
pub const CV_IA64_IntR110: CV_HREG_e = CV_HREG_e(1134i32);
pub const CV_IA64_IntR111: CV_HREG_e = CV_HREG_e(1135i32);
pub const CV_IA64_IntR112: CV_HREG_e = CV_HREG_e(1136i32);
pub const CV_IA64_IntR113: CV_HREG_e = CV_HREG_e(1137i32);
pub const CV_IA64_IntR114: CV_HREG_e = CV_HREG_e(1138i32);
pub const CV_IA64_IntR115: CV_HREG_e = CV_HREG_e(1139i32);
pub const CV_IA64_IntR116: CV_HREG_e = CV_HREG_e(1140i32);
pub const CV_IA64_IntR117: CV_HREG_e = CV_HREG_e(1141i32);
pub const CV_IA64_IntR118: CV_HREG_e = CV_HREG_e(1142i32);
pub const CV_IA64_IntR119: CV_HREG_e = CV_HREG_e(1143i32);
pub const CV_IA64_IntR120: CV_HREG_e = CV_HREG_e(1144i32);
pub const CV_IA64_IntR121: CV_HREG_e = CV_HREG_e(1145i32);
pub const CV_IA64_IntR122: CV_HREG_e = CV_HREG_e(1146i32);
pub const CV_IA64_IntR123: CV_HREG_e = CV_HREG_e(1147i32);
pub const CV_IA64_IntR124: CV_HREG_e = CV_HREG_e(1148i32);
pub const CV_IA64_IntR125: CV_HREG_e = CV_HREG_e(1149i32);
pub const CV_IA64_IntR126: CV_HREG_e = CV_HREG_e(1150i32);
pub const CV_IA64_IntR127: CV_HREG_e = CV_HREG_e(1151i32);
pub const CV_IA64_FltF0: CV_HREG_e = CV_HREG_e(2048i32);
pub const CV_IA64_FltF1: CV_HREG_e = CV_HREG_e(2049i32);
pub const CV_IA64_FltF2: CV_HREG_e = CV_HREG_e(2050i32);
pub const CV_IA64_FltF3: CV_HREG_e = CV_HREG_e(2051i32);
pub const CV_IA64_FltF4: CV_HREG_e = CV_HREG_e(2052i32);
pub const CV_IA64_FltF5: CV_HREG_e = CV_HREG_e(2053i32);
pub const CV_IA64_FltF6: CV_HREG_e = CV_HREG_e(2054i32);
pub const CV_IA64_FltF7: CV_HREG_e = CV_HREG_e(2055i32);
pub const CV_IA64_FltF8: CV_HREG_e = CV_HREG_e(2056i32);
pub const CV_IA64_FltF9: CV_HREG_e = CV_HREG_e(2057i32);
pub const CV_IA64_FltF10: CV_HREG_e = CV_HREG_e(2058i32);
pub const CV_IA64_FltF11: CV_HREG_e = CV_HREG_e(2059i32);
pub const CV_IA64_FltF12: CV_HREG_e = CV_HREG_e(2060i32);
pub const CV_IA64_FltF13: CV_HREG_e = CV_HREG_e(2061i32);
pub const CV_IA64_FltF14: CV_HREG_e = CV_HREG_e(2062i32);
pub const CV_IA64_FltF15: CV_HREG_e = CV_HREG_e(2063i32);
pub const CV_IA64_FltF16: CV_HREG_e = CV_HREG_e(2064i32);
pub const CV_IA64_FltF17: CV_HREG_e = CV_HREG_e(2065i32);
pub const CV_IA64_FltF18: CV_HREG_e = CV_HREG_e(2066i32);
pub const CV_IA64_FltF19: CV_HREG_e = CV_HREG_e(2067i32);
pub const CV_IA64_FltF20: CV_HREG_e = CV_HREG_e(2068i32);
pub const CV_IA64_FltF21: CV_HREG_e = CV_HREG_e(2069i32);
pub const CV_IA64_FltF22: CV_HREG_e = CV_HREG_e(2070i32);
pub const CV_IA64_FltF23: CV_HREG_e = CV_HREG_e(2071i32);
pub const CV_IA64_FltF24: CV_HREG_e = CV_HREG_e(2072i32);
pub const CV_IA64_FltF25: CV_HREG_e = CV_HREG_e(2073i32);
pub const CV_IA64_FltF26: CV_HREG_e = CV_HREG_e(2074i32);
pub const CV_IA64_FltF27: CV_HREG_e = CV_HREG_e(2075i32);
pub const CV_IA64_FltF28: CV_HREG_e = CV_HREG_e(2076i32);
pub const CV_IA64_FltF29: CV_HREG_e = CV_HREG_e(2077i32);
pub const CV_IA64_FltF30: CV_HREG_e = CV_HREG_e(2078i32);
pub const CV_IA64_FltF31: CV_HREG_e = CV_HREG_e(2079i32);
pub const CV_IA64_FltF32: CV_HREG_e = CV_HREG_e(2080i32);
pub const CV_IA64_FltF33: CV_HREG_e = CV_HREG_e(2081i32);
pub const CV_IA64_FltF34: CV_HREG_e = CV_HREG_e(2082i32);
pub const CV_IA64_FltF35: CV_HREG_e = CV_HREG_e(2083i32);
pub const CV_IA64_FltF36: CV_HREG_e = CV_HREG_e(2084i32);
pub const CV_IA64_FltF37: CV_HREG_e = CV_HREG_e(2085i32);
pub const CV_IA64_FltF38: CV_HREG_e = CV_HREG_e(2086i32);
pub const CV_IA64_FltF39: CV_HREG_e = CV_HREG_e(2087i32);
pub const CV_IA64_FltF40: CV_HREG_e = CV_HREG_e(2088i32);
pub const CV_IA64_FltF41: CV_HREG_e = CV_HREG_e(2089i32);
pub const CV_IA64_FltF42: CV_HREG_e = CV_HREG_e(2090i32);
pub const CV_IA64_FltF43: CV_HREG_e = CV_HREG_e(2091i32);
pub const CV_IA64_FltF44: CV_HREG_e = CV_HREG_e(2092i32);
pub const CV_IA64_FltF45: CV_HREG_e = CV_HREG_e(2093i32);
pub const CV_IA64_FltF46: CV_HREG_e = CV_HREG_e(2094i32);
pub const CV_IA64_FltF47: CV_HREG_e = CV_HREG_e(2095i32);
pub const CV_IA64_FltF48: CV_HREG_e = CV_HREG_e(2096i32);
pub const CV_IA64_FltF49: CV_HREG_e = CV_HREG_e(2097i32);
pub const CV_IA64_FltF50: CV_HREG_e = CV_HREG_e(2098i32);
pub const CV_IA64_FltF51: CV_HREG_e = CV_HREG_e(2099i32);
pub const CV_IA64_FltF52: CV_HREG_e = CV_HREG_e(2100i32);
pub const CV_IA64_FltF53: CV_HREG_e = CV_HREG_e(2101i32);
pub const CV_IA64_FltF54: CV_HREG_e = CV_HREG_e(2102i32);
pub const CV_IA64_FltF55: CV_HREG_e = CV_HREG_e(2103i32);
pub const CV_IA64_FltF56: CV_HREG_e = CV_HREG_e(2104i32);
pub const CV_IA64_FltF57: CV_HREG_e = CV_HREG_e(2105i32);
pub const CV_IA64_FltF58: CV_HREG_e = CV_HREG_e(2106i32);
pub const CV_IA64_FltF59: CV_HREG_e = CV_HREG_e(2107i32);
pub const CV_IA64_FltF60: CV_HREG_e = CV_HREG_e(2108i32);
pub const CV_IA64_FltF61: CV_HREG_e = CV_HREG_e(2109i32);
pub const CV_IA64_FltF62: CV_HREG_e = CV_HREG_e(2110i32);
pub const CV_IA64_FltF63: CV_HREG_e = CV_HREG_e(2111i32);
pub const CV_IA64_FltF64: CV_HREG_e = CV_HREG_e(2112i32);
pub const CV_IA64_FltF65: CV_HREG_e = CV_HREG_e(2113i32);
pub const CV_IA64_FltF66: CV_HREG_e = CV_HREG_e(2114i32);
pub const CV_IA64_FltF67: CV_HREG_e = CV_HREG_e(2115i32);
pub const CV_IA64_FltF68: CV_HREG_e = CV_HREG_e(2116i32);
pub const CV_IA64_FltF69: CV_HREG_e = CV_HREG_e(2117i32);
pub const CV_IA64_FltF70: CV_HREG_e = CV_HREG_e(2118i32);
pub const CV_IA64_FltF71: CV_HREG_e = CV_HREG_e(2119i32);
pub const CV_IA64_FltF72: CV_HREG_e = CV_HREG_e(2120i32);
pub const CV_IA64_FltF73: CV_HREG_e = CV_HREG_e(2121i32);
pub const CV_IA64_FltF74: CV_HREG_e = CV_HREG_e(2122i32);
pub const CV_IA64_FltF75: CV_HREG_e = CV_HREG_e(2123i32);
pub const CV_IA64_FltF76: CV_HREG_e = CV_HREG_e(2124i32);
pub const CV_IA64_FltF77: CV_HREG_e = CV_HREG_e(2125i32);
pub const CV_IA64_FltF78: CV_HREG_e = CV_HREG_e(2126i32);
pub const CV_IA64_FltF79: CV_HREG_e = CV_HREG_e(2127i32);
pub const CV_IA64_FltF80: CV_HREG_e = CV_HREG_e(2128i32);
pub const CV_IA64_FltF81: CV_HREG_e = CV_HREG_e(2129i32);
pub const CV_IA64_FltF82: CV_HREG_e = CV_HREG_e(2130i32);
pub const CV_IA64_FltF83: CV_HREG_e = CV_HREG_e(2131i32);
pub const CV_IA64_FltF84: CV_HREG_e = CV_HREG_e(2132i32);
pub const CV_IA64_FltF85: CV_HREG_e = CV_HREG_e(2133i32);
pub const CV_IA64_FltF86: CV_HREG_e = CV_HREG_e(2134i32);
pub const CV_IA64_FltF87: CV_HREG_e = CV_HREG_e(2135i32);
pub const CV_IA64_FltF88: CV_HREG_e = CV_HREG_e(2136i32);
pub const CV_IA64_FltF89: CV_HREG_e = CV_HREG_e(2137i32);
pub const CV_IA64_FltF90: CV_HREG_e = CV_HREG_e(2138i32);
pub const CV_IA64_FltF91: CV_HREG_e = CV_HREG_e(2139i32);
pub const CV_IA64_FltF92: CV_HREG_e = CV_HREG_e(2140i32);
pub const CV_IA64_FltF93: CV_HREG_e = CV_HREG_e(2141i32);
pub const CV_IA64_FltF94: CV_HREG_e = CV_HREG_e(2142i32);
pub const CV_IA64_FltF95: CV_HREG_e = CV_HREG_e(2143i32);
pub const CV_IA64_FltF96: CV_HREG_e = CV_HREG_e(2144i32);
pub const CV_IA64_FltF97: CV_HREG_e = CV_HREG_e(2145i32);
pub const CV_IA64_FltF98: CV_HREG_e = CV_HREG_e(2146i32);
pub const CV_IA64_FltF99: CV_HREG_e = CV_HREG_e(2147i32);
pub const CV_IA64_FltF100: CV_HREG_e = CV_HREG_e(2148i32);
pub const CV_IA64_FltF101: CV_HREG_e = CV_HREG_e(2149i32);
pub const CV_IA64_FltF102: CV_HREG_e = CV_HREG_e(2150i32);
pub const CV_IA64_FltF103: CV_HREG_e = CV_HREG_e(2151i32);
pub const CV_IA64_FltF104: CV_HREG_e = CV_HREG_e(2152i32);
pub const CV_IA64_FltF105: CV_HREG_e = CV_HREG_e(2153i32);
pub const CV_IA64_FltF106: CV_HREG_e = CV_HREG_e(2154i32);
pub const CV_IA64_FltF107: CV_HREG_e = CV_HREG_e(2155i32);
pub const CV_IA64_FltF108: CV_HREG_e = CV_HREG_e(2156i32);
pub const CV_IA64_FltF109: CV_HREG_e = CV_HREG_e(2157i32);
pub const CV_IA64_FltF110: CV_HREG_e = CV_HREG_e(2158i32);
pub const CV_IA64_FltF111: CV_HREG_e = CV_HREG_e(2159i32);
pub const CV_IA64_FltF112: CV_HREG_e = CV_HREG_e(2160i32);
pub const CV_IA64_FltF113: CV_HREG_e = CV_HREG_e(2161i32);
pub const CV_IA64_FltF114: CV_HREG_e = CV_HREG_e(2162i32);
pub const CV_IA64_FltF115: CV_HREG_e = CV_HREG_e(2163i32);
pub const CV_IA64_FltF116: CV_HREG_e = CV_HREG_e(2164i32);
pub const CV_IA64_FltF117: CV_HREG_e = CV_HREG_e(2165i32);
pub const CV_IA64_FltF118: CV_HREG_e = CV_HREG_e(2166i32);
pub const CV_IA64_FltF119: CV_HREG_e = CV_HREG_e(2167i32);
pub const CV_IA64_FltF120: CV_HREG_e = CV_HREG_e(2168i32);
pub const CV_IA64_FltF121: CV_HREG_e = CV_HREG_e(2169i32);
pub const CV_IA64_FltF122: CV_HREG_e = CV_HREG_e(2170i32);
pub const CV_IA64_FltF123: CV_HREG_e = CV_HREG_e(2171i32);
pub const CV_IA64_FltF124: CV_HREG_e = CV_HREG_e(2172i32);
pub const CV_IA64_FltF125: CV_HREG_e = CV_HREG_e(2173i32);
pub const CV_IA64_FltF126: CV_HREG_e = CV_HREG_e(2174i32);
pub const CV_IA64_FltF127: CV_HREG_e = CV_HREG_e(2175i32);
pub const CV_IA64_ApKR0: CV_HREG_e = CV_HREG_e(3072i32);
pub const CV_IA64_ApKR1: CV_HREG_e = CV_HREG_e(3073i32);
pub const CV_IA64_ApKR2: CV_HREG_e = CV_HREG_e(3074i32);
pub const CV_IA64_ApKR3: CV_HREG_e = CV_HREG_e(3075i32);
pub const CV_IA64_ApKR4: CV_HREG_e = CV_HREG_e(3076i32);
pub const CV_IA64_ApKR5: CV_HREG_e = CV_HREG_e(3077i32);
pub const CV_IA64_ApKR6: CV_HREG_e = CV_HREG_e(3078i32);
pub const CV_IA64_ApKR7: CV_HREG_e = CV_HREG_e(3079i32);
pub const CV_IA64_AR8: CV_HREG_e = CV_HREG_e(3080i32);
pub const CV_IA64_AR9: CV_HREG_e = CV_HREG_e(3081i32);
pub const CV_IA64_AR10: CV_HREG_e = CV_HREG_e(3082i32);
pub const CV_IA64_AR11: CV_HREG_e = CV_HREG_e(3083i32);
pub const CV_IA64_AR12: CV_HREG_e = CV_HREG_e(3084i32);
pub const CV_IA64_AR13: CV_HREG_e = CV_HREG_e(3085i32);
pub const CV_IA64_AR14: CV_HREG_e = CV_HREG_e(3086i32);
pub const CV_IA64_AR15: CV_HREG_e = CV_HREG_e(3087i32);
pub const CV_IA64_RsRSC: CV_HREG_e = CV_HREG_e(3088i32);
pub const CV_IA64_RsBSP: CV_HREG_e = CV_HREG_e(3089i32);
pub const CV_IA64_RsBSPSTORE: CV_HREG_e = CV_HREG_e(3090i32);
pub const CV_IA64_RsRNAT: CV_HREG_e = CV_HREG_e(3091i32);
pub const CV_IA64_AR20: CV_HREG_e = CV_HREG_e(3092i32);
pub const CV_IA64_StFCR: CV_HREG_e = CV_HREG_e(3093i32);
pub const CV_IA64_AR22: CV_HREG_e = CV_HREG_e(3094i32);
pub const CV_IA64_AR23: CV_HREG_e = CV_HREG_e(3095i32);
pub const CV_IA64_EFLAG: CV_HREG_e = CV_HREG_e(3096i32);
pub const CV_IA64_CSD: CV_HREG_e = CV_HREG_e(3097i32);
pub const CV_IA64_SSD: CV_HREG_e = CV_HREG_e(3098i32);
pub const CV_IA64_CFLG: CV_HREG_e = CV_HREG_e(3099i32);
pub const CV_IA64_StFSR: CV_HREG_e = CV_HREG_e(3100i32);
pub const CV_IA64_StFIR: CV_HREG_e = CV_HREG_e(3101i32);
pub const CV_IA64_StFDR: CV_HREG_e = CV_HREG_e(3102i32);
pub const CV_IA64_AR31: CV_HREG_e = CV_HREG_e(3103i32);
pub const CV_IA64_ApCCV: CV_HREG_e = CV_HREG_e(3104i32);
pub const CV_IA64_AR33: CV_HREG_e = CV_HREG_e(3105i32);
pub const CV_IA64_AR34: CV_HREG_e = CV_HREG_e(3106i32);
pub const CV_IA64_AR35: CV_HREG_e = CV_HREG_e(3107i32);
pub const CV_IA64_ApUNAT: CV_HREG_e = CV_HREG_e(3108i32);
pub const CV_IA64_AR37: CV_HREG_e = CV_HREG_e(3109i32);
pub const CV_IA64_AR38: CV_HREG_e = CV_HREG_e(3110i32);
pub const CV_IA64_AR39: CV_HREG_e = CV_HREG_e(3111i32);
pub const CV_IA64_StFPSR: CV_HREG_e = CV_HREG_e(3112i32);
pub const CV_IA64_AR41: CV_HREG_e = CV_HREG_e(3113i32);
pub const CV_IA64_AR42: CV_HREG_e = CV_HREG_e(3114i32);
pub const CV_IA64_AR43: CV_HREG_e = CV_HREG_e(3115i32);
pub const CV_IA64_ApITC: CV_HREG_e = CV_HREG_e(3116i32);
pub const CV_IA64_AR45: CV_HREG_e = CV_HREG_e(3117i32);
pub const CV_IA64_AR46: CV_HREG_e = CV_HREG_e(3118i32);
pub const CV_IA64_AR47: CV_HREG_e = CV_HREG_e(3119i32);
pub const CV_IA64_AR48: CV_HREG_e = CV_HREG_e(3120i32);
pub const CV_IA64_AR49: CV_HREG_e = CV_HREG_e(3121i32);
pub const CV_IA64_AR50: CV_HREG_e = CV_HREG_e(3122i32);
pub const CV_IA64_AR51: CV_HREG_e = CV_HREG_e(3123i32);
pub const CV_IA64_AR52: CV_HREG_e = CV_HREG_e(3124i32);
pub const CV_IA64_AR53: CV_HREG_e = CV_HREG_e(3125i32);
pub const CV_IA64_AR54: CV_HREG_e = CV_HREG_e(3126i32);
pub const CV_IA64_AR55: CV_HREG_e = CV_HREG_e(3127i32);
pub const CV_IA64_AR56: CV_HREG_e = CV_HREG_e(3128i32);
pub const CV_IA64_AR57: CV_HREG_e = CV_HREG_e(3129i32);
pub const CV_IA64_AR58: CV_HREG_e = CV_HREG_e(3130i32);
pub const CV_IA64_AR59: CV_HREG_e = CV_HREG_e(3131i32);
pub const CV_IA64_AR60: CV_HREG_e = CV_HREG_e(3132i32);
pub const CV_IA64_AR61: CV_HREG_e = CV_HREG_e(3133i32);
pub const CV_IA64_AR62: CV_HREG_e = CV_HREG_e(3134i32);
pub const CV_IA64_AR63: CV_HREG_e = CV_HREG_e(3135i32);
pub const CV_IA64_RsPFS: CV_HREG_e = CV_HREG_e(3136i32);
pub const CV_IA64_ApLC: CV_HREG_e = CV_HREG_e(3137i32);
pub const CV_IA64_ApEC: CV_HREG_e = CV_HREG_e(3138i32);
pub const CV_IA64_AR67: CV_HREG_e = CV_HREG_e(3139i32);
pub const CV_IA64_AR68: CV_HREG_e = CV_HREG_e(3140i32);
pub const CV_IA64_AR69: CV_HREG_e = CV_HREG_e(3141i32);
pub const CV_IA64_AR70: CV_HREG_e = CV_HREG_e(3142i32);
pub const CV_IA64_AR71: CV_HREG_e = CV_HREG_e(3143i32);
pub const CV_IA64_AR72: CV_HREG_e = CV_HREG_e(3144i32);
pub const CV_IA64_AR73: CV_HREG_e = CV_HREG_e(3145i32);
pub const CV_IA64_AR74: CV_HREG_e = CV_HREG_e(3146i32);
pub const CV_IA64_AR75: CV_HREG_e = CV_HREG_e(3147i32);
pub const CV_IA64_AR76: CV_HREG_e = CV_HREG_e(3148i32);
pub const CV_IA64_AR77: CV_HREG_e = CV_HREG_e(3149i32);
pub const CV_IA64_AR78: CV_HREG_e = CV_HREG_e(3150i32);
pub const CV_IA64_AR79: CV_HREG_e = CV_HREG_e(3151i32);
pub const CV_IA64_AR80: CV_HREG_e = CV_HREG_e(3152i32);
pub const CV_IA64_AR81: CV_HREG_e = CV_HREG_e(3153i32);
pub const CV_IA64_AR82: CV_HREG_e = CV_HREG_e(3154i32);
pub const CV_IA64_AR83: CV_HREG_e = CV_HREG_e(3155i32);
pub const CV_IA64_AR84: CV_HREG_e = CV_HREG_e(3156i32);
pub const CV_IA64_AR85: CV_HREG_e = CV_HREG_e(3157i32);
pub const CV_IA64_AR86: CV_HREG_e = CV_HREG_e(3158i32);
pub const CV_IA64_AR87: CV_HREG_e = CV_HREG_e(3159i32);
pub const CV_IA64_AR88: CV_HREG_e = CV_HREG_e(3160i32);
pub const CV_IA64_AR89: CV_HREG_e = CV_HREG_e(3161i32);
pub const CV_IA64_AR90: CV_HREG_e = CV_HREG_e(3162i32);
pub const CV_IA64_AR91: CV_HREG_e = CV_HREG_e(3163i32);
pub const CV_IA64_AR92: CV_HREG_e = CV_HREG_e(3164i32);
pub const CV_IA64_AR93: CV_HREG_e = CV_HREG_e(3165i32);
pub const CV_IA64_AR94: CV_HREG_e = CV_HREG_e(3166i32);
pub const CV_IA64_AR95: CV_HREG_e = CV_HREG_e(3167i32);
pub const CV_IA64_AR96: CV_HREG_e = CV_HREG_e(3168i32);
pub const CV_IA64_AR97: CV_HREG_e = CV_HREG_e(3169i32);
pub const CV_IA64_AR98: CV_HREG_e = CV_HREG_e(3170i32);
pub const CV_IA64_AR99: CV_HREG_e = CV_HREG_e(3171i32);
pub const CV_IA64_AR100: CV_HREG_e = CV_HREG_e(3172i32);
pub const CV_IA64_AR101: CV_HREG_e = CV_HREG_e(3173i32);
pub const CV_IA64_AR102: CV_HREG_e = CV_HREG_e(3174i32);
pub const CV_IA64_AR103: CV_HREG_e = CV_HREG_e(3175i32);
pub const CV_IA64_AR104: CV_HREG_e = CV_HREG_e(3176i32);
pub const CV_IA64_AR105: CV_HREG_e = CV_HREG_e(3177i32);
pub const CV_IA64_AR106: CV_HREG_e = CV_HREG_e(3178i32);
pub const CV_IA64_AR107: CV_HREG_e = CV_HREG_e(3179i32);
pub const CV_IA64_AR108: CV_HREG_e = CV_HREG_e(3180i32);
pub const CV_IA64_AR109: CV_HREG_e = CV_HREG_e(3181i32);
pub const CV_IA64_AR110: CV_HREG_e = CV_HREG_e(3182i32);
pub const CV_IA64_AR111: CV_HREG_e = CV_HREG_e(3183i32);
pub const CV_IA64_AR112: CV_HREG_e = CV_HREG_e(3184i32);
pub const CV_IA64_AR113: CV_HREG_e = CV_HREG_e(3185i32);
pub const CV_IA64_AR114: CV_HREG_e = CV_HREG_e(3186i32);
pub const CV_IA64_AR115: CV_HREG_e = CV_HREG_e(3187i32);
pub const CV_IA64_AR116: CV_HREG_e = CV_HREG_e(3188i32);
pub const CV_IA64_AR117: CV_HREG_e = CV_HREG_e(3189i32);
pub const CV_IA64_AR118: CV_HREG_e = CV_HREG_e(3190i32);
pub const CV_IA64_AR119: CV_HREG_e = CV_HREG_e(3191i32);
pub const CV_IA64_AR120: CV_HREG_e = CV_HREG_e(3192i32);
pub const CV_IA64_AR121: CV_HREG_e = CV_HREG_e(3193i32);
pub const CV_IA64_AR122: CV_HREG_e = CV_HREG_e(3194i32);
pub const CV_IA64_AR123: CV_HREG_e = CV_HREG_e(3195i32);
pub const CV_IA64_AR124: CV_HREG_e = CV_HREG_e(3196i32);
pub const CV_IA64_AR125: CV_HREG_e = CV_HREG_e(3197i32);
pub const CV_IA64_AR126: CV_HREG_e = CV_HREG_e(3198i32);
pub const CV_IA64_AR127: CV_HREG_e = CV_HREG_e(3199i32);
pub const CV_IA64_CPUID0: CV_HREG_e = CV_HREG_e(3328i32);
pub const CV_IA64_CPUID1: CV_HREG_e = CV_HREG_e(3329i32);
pub const CV_IA64_CPUID2: CV_HREG_e = CV_HREG_e(3330i32);
pub const CV_IA64_CPUID3: CV_HREG_e = CV_HREG_e(3331i32);
pub const CV_IA64_CPUID4: CV_HREG_e = CV_HREG_e(3332i32);
pub const CV_IA64_ApDCR: CV_HREG_e = CV_HREG_e(4096i32);
pub const CV_IA64_ApITM: CV_HREG_e = CV_HREG_e(4097i32);
pub const CV_IA64_ApIVA: CV_HREG_e = CV_HREG_e(4098i32);
pub const CV_IA64_CR3: CV_HREG_e = CV_HREG_e(4099i32);
pub const CV_IA64_CR4: CV_HREG_e = CV_HREG_e(4100i32);
pub const CV_IA64_CR5: CV_HREG_e = CV_HREG_e(4101i32);
pub const CV_IA64_CR6: CV_HREG_e = CV_HREG_e(4102i32);
pub const CV_IA64_CR7: CV_HREG_e = CV_HREG_e(4103i32);
pub const CV_IA64_ApPTA: CV_HREG_e = CV_HREG_e(4104i32);
pub const CV_IA64_ApGPTA: CV_HREG_e = CV_HREG_e(4105i32);
pub const CV_IA64_CR10: CV_HREG_e = CV_HREG_e(4106i32);
pub const CV_IA64_CR11: CV_HREG_e = CV_HREG_e(4107i32);
pub const CV_IA64_CR12: CV_HREG_e = CV_HREG_e(4108i32);
pub const CV_IA64_CR13: CV_HREG_e = CV_HREG_e(4109i32);
pub const CV_IA64_CR14: CV_HREG_e = CV_HREG_e(4110i32);
pub const CV_IA64_CR15: CV_HREG_e = CV_HREG_e(4111i32);
pub const CV_IA64_StIPSR: CV_HREG_e = CV_HREG_e(4112i32);
pub const CV_IA64_StISR: CV_HREG_e = CV_HREG_e(4113i32);
pub const CV_IA64_CR18: CV_HREG_e = CV_HREG_e(4114i32);
pub const CV_IA64_StIIP: CV_HREG_e = CV_HREG_e(4115i32);
pub const CV_IA64_StIFA: CV_HREG_e = CV_HREG_e(4116i32);
pub const CV_IA64_StITIR: CV_HREG_e = CV_HREG_e(4117i32);
pub const CV_IA64_StIIPA: CV_HREG_e = CV_HREG_e(4118i32);
pub const CV_IA64_StIFS: CV_HREG_e = CV_HREG_e(4119i32);
pub const CV_IA64_StIIM: CV_HREG_e = CV_HREG_e(4120i32);
pub const CV_IA64_StIHA: CV_HREG_e = CV_HREG_e(4121i32);
pub const CV_IA64_CR26: CV_HREG_e = CV_HREG_e(4122i32);
pub const CV_IA64_CR27: CV_HREG_e = CV_HREG_e(4123i32);
pub const CV_IA64_CR28: CV_HREG_e = CV_HREG_e(4124i32);
pub const CV_IA64_CR29: CV_HREG_e = CV_HREG_e(4125i32);
pub const CV_IA64_CR30: CV_HREG_e = CV_HREG_e(4126i32);
pub const CV_IA64_CR31: CV_HREG_e = CV_HREG_e(4127i32);
pub const CV_IA64_CR32: CV_HREG_e = CV_HREG_e(4128i32);
pub const CV_IA64_CR33: CV_HREG_e = CV_HREG_e(4129i32);
pub const CV_IA64_CR34: CV_HREG_e = CV_HREG_e(4130i32);
pub const CV_IA64_CR35: CV_HREG_e = CV_HREG_e(4131i32);
pub const CV_IA64_CR36: CV_HREG_e = CV_HREG_e(4132i32);
pub const CV_IA64_CR37: CV_HREG_e = CV_HREG_e(4133i32);
pub const CV_IA64_CR38: CV_HREG_e = CV_HREG_e(4134i32);
pub const CV_IA64_CR39: CV_HREG_e = CV_HREG_e(4135i32);
pub const CV_IA64_CR40: CV_HREG_e = CV_HREG_e(4136i32);
pub const CV_IA64_CR41: CV_HREG_e = CV_HREG_e(4137i32);
pub const CV_IA64_CR42: CV_HREG_e = CV_HREG_e(4138i32);
pub const CV_IA64_CR43: CV_HREG_e = CV_HREG_e(4139i32);
pub const CV_IA64_CR44: CV_HREG_e = CV_HREG_e(4140i32);
pub const CV_IA64_CR45: CV_HREG_e = CV_HREG_e(4141i32);
pub const CV_IA64_CR46: CV_HREG_e = CV_HREG_e(4142i32);
pub const CV_IA64_CR47: CV_HREG_e = CV_HREG_e(4143i32);
pub const CV_IA64_CR48: CV_HREG_e = CV_HREG_e(4144i32);
pub const CV_IA64_CR49: CV_HREG_e = CV_HREG_e(4145i32);
pub const CV_IA64_CR50: CV_HREG_e = CV_HREG_e(4146i32);
pub const CV_IA64_CR51: CV_HREG_e = CV_HREG_e(4147i32);
pub const CV_IA64_CR52: CV_HREG_e = CV_HREG_e(4148i32);
pub const CV_IA64_CR53: CV_HREG_e = CV_HREG_e(4149i32);
pub const CV_IA64_CR54: CV_HREG_e = CV_HREG_e(4150i32);
pub const CV_IA64_CR55: CV_HREG_e = CV_HREG_e(4151i32);
pub const CV_IA64_CR56: CV_HREG_e = CV_HREG_e(4152i32);
pub const CV_IA64_CR57: CV_HREG_e = CV_HREG_e(4153i32);
pub const CV_IA64_CR58: CV_HREG_e = CV_HREG_e(4154i32);
pub const CV_IA64_CR59: CV_HREG_e = CV_HREG_e(4155i32);
pub const CV_IA64_CR60: CV_HREG_e = CV_HREG_e(4156i32);
pub const CV_IA64_CR61: CV_HREG_e = CV_HREG_e(4157i32);
pub const CV_IA64_CR62: CV_HREG_e = CV_HREG_e(4158i32);
pub const CV_IA64_CR63: CV_HREG_e = CV_HREG_e(4159i32);
pub const CV_IA64_SaLID: CV_HREG_e = CV_HREG_e(4160i32);
pub const CV_IA64_SaIVR: CV_HREG_e = CV_HREG_e(4161i32);
pub const CV_IA64_SaTPR: CV_HREG_e = CV_HREG_e(4162i32);
pub const CV_IA64_SaEOI: CV_HREG_e = CV_HREG_e(4163i32);
pub const CV_IA64_SaIRR0: CV_HREG_e = CV_HREG_e(4164i32);
pub const CV_IA64_SaIRR1: CV_HREG_e = CV_HREG_e(4165i32);
pub const CV_IA64_SaIRR2: CV_HREG_e = CV_HREG_e(4166i32);
pub const CV_IA64_SaIRR3: CV_HREG_e = CV_HREG_e(4167i32);
pub const CV_IA64_SaITV: CV_HREG_e = CV_HREG_e(4168i32);
pub const CV_IA64_SaPMV: CV_HREG_e = CV_HREG_e(4169i32);
pub const CV_IA64_SaCMCV: CV_HREG_e = CV_HREG_e(4170i32);
pub const CV_IA64_CR75: CV_HREG_e = CV_HREG_e(4171i32);
pub const CV_IA64_CR76: CV_HREG_e = CV_HREG_e(4172i32);
pub const CV_IA64_CR77: CV_HREG_e = CV_HREG_e(4173i32);
pub const CV_IA64_CR78: CV_HREG_e = CV_HREG_e(4174i32);
pub const CV_IA64_CR79: CV_HREG_e = CV_HREG_e(4175i32);
pub const CV_IA64_SaLRR0: CV_HREG_e = CV_HREG_e(4176i32);
pub const CV_IA64_SaLRR1: CV_HREG_e = CV_HREG_e(4177i32);
pub const CV_IA64_CR82: CV_HREG_e = CV_HREG_e(4178i32);
pub const CV_IA64_CR83: CV_HREG_e = CV_HREG_e(4179i32);
pub const CV_IA64_CR84: CV_HREG_e = CV_HREG_e(4180i32);
pub const CV_IA64_CR85: CV_HREG_e = CV_HREG_e(4181i32);
pub const CV_IA64_CR86: CV_HREG_e = CV_HREG_e(4182i32);
pub const CV_IA64_CR87: CV_HREG_e = CV_HREG_e(4183i32);
pub const CV_IA64_CR88: CV_HREG_e = CV_HREG_e(4184i32);
pub const CV_IA64_CR89: CV_HREG_e = CV_HREG_e(4185i32);
pub const CV_IA64_CR90: CV_HREG_e = CV_HREG_e(4186i32);
pub const CV_IA64_CR91: CV_HREG_e = CV_HREG_e(4187i32);
pub const CV_IA64_CR92: CV_HREG_e = CV_HREG_e(4188i32);
pub const CV_IA64_CR93: CV_HREG_e = CV_HREG_e(4189i32);
pub const CV_IA64_CR94: CV_HREG_e = CV_HREG_e(4190i32);
pub const CV_IA64_CR95: CV_HREG_e = CV_HREG_e(4191i32);
pub const CV_IA64_CR96: CV_HREG_e = CV_HREG_e(4192i32);
pub const CV_IA64_CR97: CV_HREG_e = CV_HREG_e(4193i32);
pub const CV_IA64_CR98: CV_HREG_e = CV_HREG_e(4194i32);
pub const CV_IA64_CR99: CV_HREG_e = CV_HREG_e(4195i32);
pub const CV_IA64_CR100: CV_HREG_e = CV_HREG_e(4196i32);
pub const CV_IA64_CR101: CV_HREG_e = CV_HREG_e(4197i32);
pub const CV_IA64_CR102: CV_HREG_e = CV_HREG_e(4198i32);
pub const CV_IA64_CR103: CV_HREG_e = CV_HREG_e(4199i32);
pub const CV_IA64_CR104: CV_HREG_e = CV_HREG_e(4200i32);
pub const CV_IA64_CR105: CV_HREG_e = CV_HREG_e(4201i32);
pub const CV_IA64_CR106: CV_HREG_e = CV_HREG_e(4202i32);
pub const CV_IA64_CR107: CV_HREG_e = CV_HREG_e(4203i32);
pub const CV_IA64_CR108: CV_HREG_e = CV_HREG_e(4204i32);
pub const CV_IA64_CR109: CV_HREG_e = CV_HREG_e(4205i32);
pub const CV_IA64_CR110: CV_HREG_e = CV_HREG_e(4206i32);
pub const CV_IA64_CR111: CV_HREG_e = CV_HREG_e(4207i32);
pub const CV_IA64_CR112: CV_HREG_e = CV_HREG_e(4208i32);
pub const CV_IA64_CR113: CV_HREG_e = CV_HREG_e(4209i32);
pub const CV_IA64_CR114: CV_HREG_e = CV_HREG_e(4210i32);
pub const CV_IA64_CR115: CV_HREG_e = CV_HREG_e(4211i32);
pub const CV_IA64_CR116: CV_HREG_e = CV_HREG_e(4212i32);
pub const CV_IA64_CR117: CV_HREG_e = CV_HREG_e(4213i32);
pub const CV_IA64_CR118: CV_HREG_e = CV_HREG_e(4214i32);
pub const CV_IA64_CR119: CV_HREG_e = CV_HREG_e(4215i32);
pub const CV_IA64_CR120: CV_HREG_e = CV_HREG_e(4216i32);
pub const CV_IA64_CR121: CV_HREG_e = CV_HREG_e(4217i32);
pub const CV_IA64_CR122: CV_HREG_e = CV_HREG_e(4218i32);
pub const CV_IA64_CR123: CV_HREG_e = CV_HREG_e(4219i32);
pub const CV_IA64_CR124: CV_HREG_e = CV_HREG_e(4220i32);
pub const CV_IA64_CR125: CV_HREG_e = CV_HREG_e(4221i32);
pub const CV_IA64_CR126: CV_HREG_e = CV_HREG_e(4222i32);
pub const CV_IA64_CR127: CV_HREG_e = CV_HREG_e(4223i32);
pub const CV_IA64_Pkr0: CV_HREG_e = CV_HREG_e(5120i32);
pub const CV_IA64_Pkr1: CV_HREG_e = CV_HREG_e(5121i32);
pub const CV_IA64_Pkr2: CV_HREG_e = CV_HREG_e(5122i32);
pub const CV_IA64_Pkr3: CV_HREG_e = CV_HREG_e(5123i32);
pub const CV_IA64_Pkr4: CV_HREG_e = CV_HREG_e(5124i32);
pub const CV_IA64_Pkr5: CV_HREG_e = CV_HREG_e(5125i32);
pub const CV_IA64_Pkr6: CV_HREG_e = CV_HREG_e(5126i32);
pub const CV_IA64_Pkr7: CV_HREG_e = CV_HREG_e(5127i32);
pub const CV_IA64_Pkr8: CV_HREG_e = CV_HREG_e(5128i32);
pub const CV_IA64_Pkr9: CV_HREG_e = CV_HREG_e(5129i32);
pub const CV_IA64_Pkr10: CV_HREG_e = CV_HREG_e(5130i32);
pub const CV_IA64_Pkr11: CV_HREG_e = CV_HREG_e(5131i32);
pub const CV_IA64_Pkr12: CV_HREG_e = CV_HREG_e(5132i32);
pub const CV_IA64_Pkr13: CV_HREG_e = CV_HREG_e(5133i32);
pub const CV_IA64_Pkr14: CV_HREG_e = CV_HREG_e(5134i32);
pub const CV_IA64_Pkr15: CV_HREG_e = CV_HREG_e(5135i32);
pub const CV_IA64_Rr0: CV_HREG_e = CV_HREG_e(6144i32);
pub const CV_IA64_Rr1: CV_HREG_e = CV_HREG_e(6145i32);
pub const CV_IA64_Rr2: CV_HREG_e = CV_HREG_e(6146i32);
pub const CV_IA64_Rr3: CV_HREG_e = CV_HREG_e(6147i32);
pub const CV_IA64_Rr4: CV_HREG_e = CV_HREG_e(6148i32);
pub const CV_IA64_Rr5: CV_HREG_e = CV_HREG_e(6149i32);
pub const CV_IA64_Rr6: CV_HREG_e = CV_HREG_e(6150i32);
pub const CV_IA64_Rr7: CV_HREG_e = CV_HREG_e(6151i32);
pub const CV_IA64_PFD0: CV_HREG_e = CV_HREG_e(7168i32);
pub const CV_IA64_PFD1: CV_HREG_e = CV_HREG_e(7169i32);
pub const CV_IA64_PFD2: CV_HREG_e = CV_HREG_e(7170i32);
pub const CV_IA64_PFD3: CV_HREG_e = CV_HREG_e(7171i32);
pub const CV_IA64_PFD4: CV_HREG_e = CV_HREG_e(7172i32);
pub const CV_IA64_PFD5: CV_HREG_e = CV_HREG_e(7173i32);
pub const CV_IA64_PFD6: CV_HREG_e = CV_HREG_e(7174i32);
pub const CV_IA64_PFD7: CV_HREG_e = CV_HREG_e(7175i32);
pub const CV_IA64_PFD8: CV_HREG_e = CV_HREG_e(7176i32);
pub const CV_IA64_PFD9: CV_HREG_e = CV_HREG_e(7177i32);
pub const CV_IA64_PFD10: CV_HREG_e = CV_HREG_e(7178i32);
pub const CV_IA64_PFD11: CV_HREG_e = CV_HREG_e(7179i32);
pub const CV_IA64_PFD12: CV_HREG_e = CV_HREG_e(7180i32);
pub const CV_IA64_PFD13: CV_HREG_e = CV_HREG_e(7181i32);
pub const CV_IA64_PFD14: CV_HREG_e = CV_HREG_e(7182i32);
pub const CV_IA64_PFD15: CV_HREG_e = CV_HREG_e(7183i32);
pub const CV_IA64_PFD16: CV_HREG_e = CV_HREG_e(7184i32);
pub const CV_IA64_PFD17: CV_HREG_e = CV_HREG_e(7185i32);
pub const CV_IA64_PFC0: CV_HREG_e = CV_HREG_e(7424i32);
pub const CV_IA64_PFC1: CV_HREG_e = CV_HREG_e(7425i32);
pub const CV_IA64_PFC2: CV_HREG_e = CV_HREG_e(7426i32);
pub const CV_IA64_PFC3: CV_HREG_e = CV_HREG_e(7427i32);
pub const CV_IA64_PFC4: CV_HREG_e = CV_HREG_e(7428i32);
pub const CV_IA64_PFC5: CV_HREG_e = CV_HREG_e(7429i32);
pub const CV_IA64_PFC6: CV_HREG_e = CV_HREG_e(7430i32);
pub const CV_IA64_PFC7: CV_HREG_e = CV_HREG_e(7431i32);
pub const CV_IA64_PFC8: CV_HREG_e = CV_HREG_e(7432i32);
pub const CV_IA64_PFC9: CV_HREG_e = CV_HREG_e(7433i32);
pub const CV_IA64_PFC10: CV_HREG_e = CV_HREG_e(7434i32);
pub const CV_IA64_PFC11: CV_HREG_e = CV_HREG_e(7435i32);
pub const CV_IA64_PFC12: CV_HREG_e = CV_HREG_e(7436i32);
pub const CV_IA64_PFC13: CV_HREG_e = CV_HREG_e(7437i32);
pub const CV_IA64_PFC14: CV_HREG_e = CV_HREG_e(7438i32);
pub const CV_IA64_PFC15: CV_HREG_e = CV_HREG_e(7439i32);
pub const CV_IA64_TrI0: CV_HREG_e = CV_HREG_e(8192i32);
pub const CV_IA64_TrI1: CV_HREG_e = CV_HREG_e(8193i32);
pub const CV_IA64_TrI2: CV_HREG_e = CV_HREG_e(8194i32);
pub const CV_IA64_TrI3: CV_HREG_e = CV_HREG_e(8195i32);
pub const CV_IA64_TrI4: CV_HREG_e = CV_HREG_e(8196i32);
pub const CV_IA64_TrI5: CV_HREG_e = CV_HREG_e(8197i32);
pub const CV_IA64_TrI6: CV_HREG_e = CV_HREG_e(8198i32);
pub const CV_IA64_TrI7: CV_HREG_e = CV_HREG_e(8199i32);
pub const CV_IA64_TrD0: CV_HREG_e = CV_HREG_e(8320i32);
pub const CV_IA64_TrD1: CV_HREG_e = CV_HREG_e(8321i32);
pub const CV_IA64_TrD2: CV_HREG_e = CV_HREG_e(8322i32);
pub const CV_IA64_TrD3: CV_HREG_e = CV_HREG_e(8323i32);
pub const CV_IA64_TrD4: CV_HREG_e = CV_HREG_e(8324i32);
pub const CV_IA64_TrD5: CV_HREG_e = CV_HREG_e(8325i32);
pub const CV_IA64_TrD6: CV_HREG_e = CV_HREG_e(8326i32);
pub const CV_IA64_TrD7: CV_HREG_e = CV_HREG_e(8327i32);
pub const CV_IA64_DbI0: CV_HREG_e = CV_HREG_e(8448i32);
pub const CV_IA64_DbI1: CV_HREG_e = CV_HREG_e(8449i32);
pub const CV_IA64_DbI2: CV_HREG_e = CV_HREG_e(8450i32);
pub const CV_IA64_DbI3: CV_HREG_e = CV_HREG_e(8451i32);
pub const CV_IA64_DbI4: CV_HREG_e = CV_HREG_e(8452i32);
pub const CV_IA64_DbI5: CV_HREG_e = CV_HREG_e(8453i32);
pub const CV_IA64_DbI6: CV_HREG_e = CV_HREG_e(8454i32);
pub const CV_IA64_DbI7: CV_HREG_e = CV_HREG_e(8455i32);
pub const CV_IA64_DbD0: CV_HREG_e = CV_HREG_e(8576i32);
pub const CV_IA64_DbD1: CV_HREG_e = CV_HREG_e(8577i32);
pub const CV_IA64_DbD2: CV_HREG_e = CV_HREG_e(8578i32);
pub const CV_IA64_DbD3: CV_HREG_e = CV_HREG_e(8579i32);
pub const CV_IA64_DbD4: CV_HREG_e = CV_HREG_e(8580i32);
pub const CV_IA64_DbD5: CV_HREG_e = CV_HREG_e(8581i32);
pub const CV_IA64_DbD6: CV_HREG_e = CV_HREG_e(8582i32);
pub const CV_IA64_DbD7: CV_HREG_e = CV_HREG_e(8583i32);
pub const CV_TRI_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_TRI_D0: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_TRI_D1: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_TRI_D2: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_TRI_D3: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_TRI_D4: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_TRI_D5: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_TRI_D6: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_TRI_D7: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_TRI_D8: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_TRI_D9: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_TRI_D10: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_TRI_D11: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_TRI_D12: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_TRI_D13: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_TRI_D14: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_TRI_D15: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_TRI_A0: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_TRI_A1: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_TRI_A2: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_TRI_A3: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_TRI_A4: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_TRI_A5: CV_HREG_e = CV_HREG_e(31i32);
pub const CV_TRI_A6: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_TRI_A7: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_TRI_A8: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_TRI_A9: CV_HREG_e = CV_HREG_e(35i32);
pub const CV_TRI_A10: CV_HREG_e = CV_HREG_e(36i32);
pub const CV_TRI_A11: CV_HREG_e = CV_HREG_e(37i32);
pub const CV_TRI_A12: CV_HREG_e = CV_HREG_e(38i32);
pub const CV_TRI_A13: CV_HREG_e = CV_HREG_e(39i32);
pub const CV_TRI_A14: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_TRI_A15: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_TRI_E0: CV_HREG_e = CV_HREG_e(42i32);
pub const CV_TRI_E2: CV_HREG_e = CV_HREG_e(43i32);
pub const CV_TRI_E4: CV_HREG_e = CV_HREG_e(44i32);
pub const CV_TRI_E6: CV_HREG_e = CV_HREG_e(45i32);
pub const CV_TRI_E8: CV_HREG_e = CV_HREG_e(46i32);
pub const CV_TRI_E10: CV_HREG_e = CV_HREG_e(47i32);
pub const CV_TRI_E12: CV_HREG_e = CV_HREG_e(48i32);
pub const CV_TRI_E14: CV_HREG_e = CV_HREG_e(49i32);
pub const CV_TRI_EA0: CV_HREG_e = CV_HREG_e(50i32);
pub const CV_TRI_EA2: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_TRI_EA4: CV_HREG_e = CV_HREG_e(52i32);
pub const CV_TRI_EA6: CV_HREG_e = CV_HREG_e(53i32);
pub const CV_TRI_EA8: CV_HREG_e = CV_HREG_e(54i32);
pub const CV_TRI_EA10: CV_HREG_e = CV_HREG_e(55i32);
pub const CV_TRI_EA12: CV_HREG_e = CV_HREG_e(56i32);
pub const CV_TRI_EA14: CV_HREG_e = CV_HREG_e(57i32);
pub const CV_TRI_PSW: CV_HREG_e = CV_HREG_e(58i32);
pub const CV_TRI_PCXI: CV_HREG_e = CV_HREG_e(59i32);
pub const CV_TRI_PC: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_TRI_FCX: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_TRI_LCX: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_TRI_ISP: CV_HREG_e = CV_HREG_e(63i32);
pub const CV_TRI_ICR: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_TRI_BIV: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_TRI_BTV: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_TRI_SYSCON: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_TRI_DPRx_0: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_TRI_DPRx_1: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_TRI_DPRx_2: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_TRI_DPRx_3: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_TRI_CPRx_0: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_TRI_CPRx_1: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_TRI_CPRx_2: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_TRI_CPRx_3: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_TRI_DPMx_0: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_TRI_DPMx_1: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_TRI_DPMx_2: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_TRI_DPMx_3: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_TRI_CPMx_0: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_TRI_CPMx_1: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_TRI_CPMx_2: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_TRI_CPMx_3: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_TRI_DBGSSR: CV_HREG_e = CV_HREG_e(72i32);
pub const CV_TRI_EXEVT: CV_HREG_e = CV_HREG_e(73i32);
pub const CV_TRI_SWEVT: CV_HREG_e = CV_HREG_e(74i32);
pub const CV_TRI_CREVT: CV_HREG_e = CV_HREG_e(75i32);
pub const CV_TRI_TRnEVT: CV_HREG_e = CV_HREG_e(76i32);
pub const CV_TRI_MMUCON: CV_HREG_e = CV_HREG_e(77i32);
pub const CV_TRI_ASI: CV_HREG_e = CV_HREG_e(78i32);
pub const CV_TRI_TVA: CV_HREG_e = CV_HREG_e(79i32);
pub const CV_TRI_TPA: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_TRI_TPX: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_TRI_TFA: CV_HREG_e = CV_HREG_e(82i32);
pub const CV_AM33_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_AM33_E0: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_AM33_E1: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_AM33_E2: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_AM33_E3: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_AM33_E4: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_AM33_E5: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_AM33_E6: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_AM33_E7: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_AM33_A0: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_AM33_A1: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_AM33_A2: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_AM33_A3: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_AM33_D0: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_AM33_D1: CV_HREG_e = CV_HREG_e(31i32);
pub const CV_AM33_D2: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_AM33_D3: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_AM33_FS0: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_AM33_FS1: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_AM33_FS2: CV_HREG_e = CV_HREG_e(42i32);
pub const CV_AM33_FS3: CV_HREG_e = CV_HREG_e(43i32);
pub const CV_AM33_FS4: CV_HREG_e = CV_HREG_e(44i32);
pub const CV_AM33_FS5: CV_HREG_e = CV_HREG_e(45i32);
pub const CV_AM33_FS6: CV_HREG_e = CV_HREG_e(46i32);
pub const CV_AM33_FS7: CV_HREG_e = CV_HREG_e(47i32);
pub const CV_AM33_FS8: CV_HREG_e = CV_HREG_e(48i32);
pub const CV_AM33_FS9: CV_HREG_e = CV_HREG_e(49i32);
pub const CV_AM33_FS10: CV_HREG_e = CV_HREG_e(50i32);
pub const CV_AM33_FS11: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_AM33_FS12: CV_HREG_e = CV_HREG_e(52i32);
pub const CV_AM33_FS13: CV_HREG_e = CV_HREG_e(53i32);
pub const CV_AM33_FS14: CV_HREG_e = CV_HREG_e(54i32);
pub const CV_AM33_FS15: CV_HREG_e = CV_HREG_e(55i32);
pub const CV_AM33_FS16: CV_HREG_e = CV_HREG_e(56i32);
pub const CV_AM33_FS17: CV_HREG_e = CV_HREG_e(57i32);
pub const CV_AM33_FS18: CV_HREG_e = CV_HREG_e(58i32);
pub const CV_AM33_FS19: CV_HREG_e = CV_HREG_e(59i32);
pub const CV_AM33_FS20: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_AM33_FS21: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_AM33_FS22: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_AM33_FS23: CV_HREG_e = CV_HREG_e(63i32);
pub const CV_AM33_FS24: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_AM33_FS25: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_AM33_FS26: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_AM33_FS27: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_AM33_FS28: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_AM33_FS29: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_AM33_FS30: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_AM33_FS31: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_AM33_SP: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_AM33_PC: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_AM33_MDR: CV_HREG_e = CV_HREG_e(82i32);
pub const CV_AM33_MDRQ: CV_HREG_e = CV_HREG_e(83i32);
pub const CV_AM33_MCRH: CV_HREG_e = CV_HREG_e(84i32);
pub const CV_AM33_MCRL: CV_HREG_e = CV_HREG_e(85i32);
pub const CV_AM33_MCVF: CV_HREG_e = CV_HREG_e(86i32);
pub const CV_AM33_EPSW: CV_HREG_e = CV_HREG_e(87i32);
pub const CV_AM33_FPCR: CV_HREG_e = CV_HREG_e(88i32);
pub const CV_AM33_LIR: CV_HREG_e = CV_HREG_e(89i32);
pub const CV_AM33_LAR: CV_HREG_e = CV_HREG_e(90i32);
pub const CV_M32R_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_M32R_R0: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_M32R_R1: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_M32R_R2: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_M32R_R3: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_M32R_R4: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_M32R_R5: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_M32R_R6: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_M32R_R7: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_M32R_R8: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_M32R_R9: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_M32R_R10: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_M32R_R11: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_M32R_R12: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_M32R_R13: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_M32R_R14: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_M32R_R15: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_M32R_PSW: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_M32R_CBR: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_M32R_SPI: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_M32R_SPU: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_M32R_SPO: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_M32R_BPC: CV_HREG_e = CV_HREG_e(31i32);
pub const CV_M32R_ACHI: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_M32R_ACLO: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_M32R_PC: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_SHMEDIA_NOREG: CV_HREG_e = CV_HREG_e(0i32);
pub const CV_SHMEDIA_R0: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_SHMEDIA_R1: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_SHMEDIA_R2: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_SHMEDIA_R3: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_SHMEDIA_R4: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_SHMEDIA_R5: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_SHMEDIA_R6: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_SHMEDIA_R7: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_SHMEDIA_R8: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_SHMEDIA_R9: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_SHMEDIA_R10: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_SHMEDIA_R11: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_SHMEDIA_R12: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_SHMEDIA_R13: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_SHMEDIA_R14: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_SHMEDIA_R15: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_SHMEDIA_R16: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_SHMEDIA_R17: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_SHMEDIA_R18: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_SHMEDIA_R19: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_SHMEDIA_R20: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_SHMEDIA_R21: CV_HREG_e = CV_HREG_e(31i32);
pub const CV_SHMEDIA_R22: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_SHMEDIA_R23: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_SHMEDIA_R24: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_SHMEDIA_R25: CV_HREG_e = CV_HREG_e(35i32);
pub const CV_SHMEDIA_R26: CV_HREG_e = CV_HREG_e(36i32);
pub const CV_SHMEDIA_R27: CV_HREG_e = CV_HREG_e(37i32);
pub const CV_SHMEDIA_R28: CV_HREG_e = CV_HREG_e(38i32);
pub const CV_SHMEDIA_R29: CV_HREG_e = CV_HREG_e(39i32);
pub const CV_SHMEDIA_R30: CV_HREG_e = CV_HREG_e(40i32);
pub const CV_SHMEDIA_R31: CV_HREG_e = CV_HREG_e(41i32);
pub const CV_SHMEDIA_R32: CV_HREG_e = CV_HREG_e(42i32);
pub const CV_SHMEDIA_R33: CV_HREG_e = CV_HREG_e(43i32);
pub const CV_SHMEDIA_R34: CV_HREG_e = CV_HREG_e(44i32);
pub const CV_SHMEDIA_R35: CV_HREG_e = CV_HREG_e(45i32);
pub const CV_SHMEDIA_R36: CV_HREG_e = CV_HREG_e(46i32);
pub const CV_SHMEDIA_R37: CV_HREG_e = CV_HREG_e(47i32);
pub const CV_SHMEDIA_R38: CV_HREG_e = CV_HREG_e(48i32);
pub const CV_SHMEDIA_R39: CV_HREG_e = CV_HREG_e(49i32);
pub const CV_SHMEDIA_R40: CV_HREG_e = CV_HREG_e(50i32);
pub const CV_SHMEDIA_R41: CV_HREG_e = CV_HREG_e(51i32);
pub const CV_SHMEDIA_R42: CV_HREG_e = CV_HREG_e(52i32);
pub const CV_SHMEDIA_R43: CV_HREG_e = CV_HREG_e(53i32);
pub const CV_SHMEDIA_R44: CV_HREG_e = CV_HREG_e(54i32);
pub const CV_SHMEDIA_R45: CV_HREG_e = CV_HREG_e(55i32);
pub const CV_SHMEDIA_R46: CV_HREG_e = CV_HREG_e(56i32);
pub const CV_SHMEDIA_R47: CV_HREG_e = CV_HREG_e(57i32);
pub const CV_SHMEDIA_R48: CV_HREG_e = CV_HREG_e(58i32);
pub const CV_SHMEDIA_R49: CV_HREG_e = CV_HREG_e(59i32);
pub const CV_SHMEDIA_R50: CV_HREG_e = CV_HREG_e(60i32);
pub const CV_SHMEDIA_R51: CV_HREG_e = CV_HREG_e(61i32);
pub const CV_SHMEDIA_R52: CV_HREG_e = CV_HREG_e(62i32);
pub const CV_SHMEDIA_R53: CV_HREG_e = CV_HREG_e(63i32);
pub const CV_SHMEDIA_R54: CV_HREG_e = CV_HREG_e(64i32);
pub const CV_SHMEDIA_R55: CV_HREG_e = CV_HREG_e(65i32);
pub const CV_SHMEDIA_R56: CV_HREG_e = CV_HREG_e(66i32);
pub const CV_SHMEDIA_R57: CV_HREG_e = CV_HREG_e(67i32);
pub const CV_SHMEDIA_R58: CV_HREG_e = CV_HREG_e(68i32);
pub const CV_SHMEDIA_R59: CV_HREG_e = CV_HREG_e(69i32);
pub const CV_SHMEDIA_R60: CV_HREG_e = CV_HREG_e(70i32);
pub const CV_SHMEDIA_R61: CV_HREG_e = CV_HREG_e(71i32);
pub const CV_SHMEDIA_R62: CV_HREG_e = CV_HREG_e(72i32);
pub const CV_SHMEDIA_R63: CV_HREG_e = CV_HREG_e(73i32);
pub const CV_SHMEDIA_TR0: CV_HREG_e = CV_HREG_e(74i32);
pub const CV_SHMEDIA_TR1: CV_HREG_e = CV_HREG_e(75i32);
pub const CV_SHMEDIA_TR2: CV_HREG_e = CV_HREG_e(76i32);
pub const CV_SHMEDIA_TR3: CV_HREG_e = CV_HREG_e(77i32);
pub const CV_SHMEDIA_TR4: CV_HREG_e = CV_HREG_e(78i32);
pub const CV_SHMEDIA_TR5: CV_HREG_e = CV_HREG_e(79i32);
pub const CV_SHMEDIA_TR6: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_SHMEDIA_TR7: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_SHMEDIA_TR8: CV_HREG_e = CV_HREG_e(82i32);
pub const CV_SHMEDIA_TR9: CV_HREG_e = CV_HREG_e(83i32);
pub const CV_SHMEDIA_TR10: CV_HREG_e = CV_HREG_e(84i32);
pub const CV_SHMEDIA_TR11: CV_HREG_e = CV_HREG_e(85i32);
pub const CV_SHMEDIA_TR12: CV_HREG_e = CV_HREG_e(86i32);
pub const CV_SHMEDIA_TR13: CV_HREG_e = CV_HREG_e(87i32);
pub const CV_SHMEDIA_TR14: CV_HREG_e = CV_HREG_e(88i32);
pub const CV_SHMEDIA_TR15: CV_HREG_e = CV_HREG_e(89i32);
pub const CV_SHMEDIA_FR0: CV_HREG_e = CV_HREG_e(128i32);
pub const CV_SHMEDIA_FR1: CV_HREG_e = CV_HREG_e(129i32);
pub const CV_SHMEDIA_FR2: CV_HREG_e = CV_HREG_e(130i32);
pub const CV_SHMEDIA_FR3: CV_HREG_e = CV_HREG_e(131i32);
pub const CV_SHMEDIA_FR4: CV_HREG_e = CV_HREG_e(132i32);
pub const CV_SHMEDIA_FR5: CV_HREG_e = CV_HREG_e(133i32);
pub const CV_SHMEDIA_FR6: CV_HREG_e = CV_HREG_e(134i32);
pub const CV_SHMEDIA_FR7: CV_HREG_e = CV_HREG_e(135i32);
pub const CV_SHMEDIA_FR8: CV_HREG_e = CV_HREG_e(136i32);
pub const CV_SHMEDIA_FR9: CV_HREG_e = CV_HREG_e(137i32);
pub const CV_SHMEDIA_FR10: CV_HREG_e = CV_HREG_e(138i32);
pub const CV_SHMEDIA_FR11: CV_HREG_e = CV_HREG_e(139i32);
pub const CV_SHMEDIA_FR12: CV_HREG_e = CV_HREG_e(140i32);
pub const CV_SHMEDIA_FR13: CV_HREG_e = CV_HREG_e(141i32);
pub const CV_SHMEDIA_FR14: CV_HREG_e = CV_HREG_e(142i32);
pub const CV_SHMEDIA_FR15: CV_HREG_e = CV_HREG_e(143i32);
pub const CV_SHMEDIA_FR16: CV_HREG_e = CV_HREG_e(144i32);
pub const CV_SHMEDIA_FR17: CV_HREG_e = CV_HREG_e(145i32);
pub const CV_SHMEDIA_FR18: CV_HREG_e = CV_HREG_e(146i32);
pub const CV_SHMEDIA_FR19: CV_HREG_e = CV_HREG_e(147i32);
pub const CV_SHMEDIA_FR20: CV_HREG_e = CV_HREG_e(148i32);
pub const CV_SHMEDIA_FR21: CV_HREG_e = CV_HREG_e(149i32);
pub const CV_SHMEDIA_FR22: CV_HREG_e = CV_HREG_e(150i32);
pub const CV_SHMEDIA_FR23: CV_HREG_e = CV_HREG_e(151i32);
pub const CV_SHMEDIA_FR24: CV_HREG_e = CV_HREG_e(152i32);
pub const CV_SHMEDIA_FR25: CV_HREG_e = CV_HREG_e(153i32);
pub const CV_SHMEDIA_FR26: CV_HREG_e = CV_HREG_e(154i32);
pub const CV_SHMEDIA_FR27: CV_HREG_e = CV_HREG_e(155i32);
pub const CV_SHMEDIA_FR28: CV_HREG_e = CV_HREG_e(156i32);
pub const CV_SHMEDIA_FR29: CV_HREG_e = CV_HREG_e(157i32);
pub const CV_SHMEDIA_FR30: CV_HREG_e = CV_HREG_e(158i32);
pub const CV_SHMEDIA_FR31: CV_HREG_e = CV_HREG_e(159i32);
pub const CV_SHMEDIA_FR32: CV_HREG_e = CV_HREG_e(160i32);
pub const CV_SHMEDIA_FR33: CV_HREG_e = CV_HREG_e(161i32);
pub const CV_SHMEDIA_FR34: CV_HREG_e = CV_HREG_e(162i32);
pub const CV_SHMEDIA_FR35: CV_HREG_e = CV_HREG_e(163i32);
pub const CV_SHMEDIA_FR36: CV_HREG_e = CV_HREG_e(164i32);
pub const CV_SHMEDIA_FR37: CV_HREG_e = CV_HREG_e(165i32);
pub const CV_SHMEDIA_FR38: CV_HREG_e = CV_HREG_e(166i32);
pub const CV_SHMEDIA_FR39: CV_HREG_e = CV_HREG_e(167i32);
pub const CV_SHMEDIA_FR40: CV_HREG_e = CV_HREG_e(168i32);
pub const CV_SHMEDIA_FR41: CV_HREG_e = CV_HREG_e(169i32);
pub const CV_SHMEDIA_FR42: CV_HREG_e = CV_HREG_e(170i32);
pub const CV_SHMEDIA_FR43: CV_HREG_e = CV_HREG_e(171i32);
pub const CV_SHMEDIA_FR44: CV_HREG_e = CV_HREG_e(172i32);
pub const CV_SHMEDIA_FR45: CV_HREG_e = CV_HREG_e(173i32);
pub const CV_SHMEDIA_FR46: CV_HREG_e = CV_HREG_e(174i32);
pub const CV_SHMEDIA_FR47: CV_HREG_e = CV_HREG_e(175i32);
pub const CV_SHMEDIA_FR48: CV_HREG_e = CV_HREG_e(176i32);
pub const CV_SHMEDIA_FR49: CV_HREG_e = CV_HREG_e(177i32);
pub const CV_SHMEDIA_FR50: CV_HREG_e = CV_HREG_e(178i32);
pub const CV_SHMEDIA_FR51: CV_HREG_e = CV_HREG_e(179i32);
pub const CV_SHMEDIA_FR52: CV_HREG_e = CV_HREG_e(180i32);
pub const CV_SHMEDIA_FR53: CV_HREG_e = CV_HREG_e(181i32);
pub const CV_SHMEDIA_FR54: CV_HREG_e = CV_HREG_e(182i32);
pub const CV_SHMEDIA_FR55: CV_HREG_e = CV_HREG_e(183i32);
pub const CV_SHMEDIA_FR56: CV_HREG_e = CV_HREG_e(184i32);
pub const CV_SHMEDIA_FR57: CV_HREG_e = CV_HREG_e(185i32);
pub const CV_SHMEDIA_FR58: CV_HREG_e = CV_HREG_e(186i32);
pub const CV_SHMEDIA_FR59: CV_HREG_e = CV_HREG_e(187i32);
pub const CV_SHMEDIA_FR60: CV_HREG_e = CV_HREG_e(188i32);
pub const CV_SHMEDIA_FR61: CV_HREG_e = CV_HREG_e(189i32);
pub const CV_SHMEDIA_FR62: CV_HREG_e = CV_HREG_e(190i32);
pub const CV_SHMEDIA_FR63: CV_HREG_e = CV_HREG_e(191i32);
pub const CV_SHMEDIA_DR0: CV_HREG_e = CV_HREG_e(256i32);
pub const CV_SHMEDIA_DR2: CV_HREG_e = CV_HREG_e(258i32);
pub const CV_SHMEDIA_DR4: CV_HREG_e = CV_HREG_e(260i32);
pub const CV_SHMEDIA_DR6: CV_HREG_e = CV_HREG_e(262i32);
pub const CV_SHMEDIA_DR8: CV_HREG_e = CV_HREG_e(264i32);
pub const CV_SHMEDIA_DR10: CV_HREG_e = CV_HREG_e(266i32);
pub const CV_SHMEDIA_DR12: CV_HREG_e = CV_HREG_e(268i32);
pub const CV_SHMEDIA_DR14: CV_HREG_e = CV_HREG_e(270i32);
pub const CV_SHMEDIA_DR16: CV_HREG_e = CV_HREG_e(272i32);
pub const CV_SHMEDIA_DR18: CV_HREG_e = CV_HREG_e(274i32);
pub const CV_SHMEDIA_DR20: CV_HREG_e = CV_HREG_e(276i32);
pub const CV_SHMEDIA_DR22: CV_HREG_e = CV_HREG_e(278i32);
pub const CV_SHMEDIA_DR24: CV_HREG_e = CV_HREG_e(280i32);
pub const CV_SHMEDIA_DR26: CV_HREG_e = CV_HREG_e(282i32);
pub const CV_SHMEDIA_DR28: CV_HREG_e = CV_HREG_e(284i32);
pub const CV_SHMEDIA_DR30: CV_HREG_e = CV_HREG_e(286i32);
pub const CV_SHMEDIA_DR32: CV_HREG_e = CV_HREG_e(288i32);
pub const CV_SHMEDIA_DR34: CV_HREG_e = CV_HREG_e(290i32);
pub const CV_SHMEDIA_DR36: CV_HREG_e = CV_HREG_e(292i32);
pub const CV_SHMEDIA_DR38: CV_HREG_e = CV_HREG_e(294i32);
pub const CV_SHMEDIA_DR40: CV_HREG_e = CV_HREG_e(296i32);
pub const CV_SHMEDIA_DR42: CV_HREG_e = CV_HREG_e(298i32);
pub const CV_SHMEDIA_DR44: CV_HREG_e = CV_HREG_e(300i32);
pub const CV_SHMEDIA_DR46: CV_HREG_e = CV_HREG_e(302i32);
pub const CV_SHMEDIA_DR48: CV_HREG_e = CV_HREG_e(304i32);
pub const CV_SHMEDIA_DR50: CV_HREG_e = CV_HREG_e(306i32);
pub const CV_SHMEDIA_DR52: CV_HREG_e = CV_HREG_e(308i32);
pub const CV_SHMEDIA_DR54: CV_HREG_e = CV_HREG_e(310i32);
pub const CV_SHMEDIA_DR56: CV_HREG_e = CV_HREG_e(312i32);
pub const CV_SHMEDIA_DR58: CV_HREG_e = CV_HREG_e(314i32);
pub const CV_SHMEDIA_DR60: CV_HREG_e = CV_HREG_e(316i32);
pub const CV_SHMEDIA_DR62: CV_HREG_e = CV_HREG_e(318i32);
pub const CV_SHMEDIA_FV0: CV_HREG_e = CV_HREG_e(512i32);
pub const CV_SHMEDIA_FV4: CV_HREG_e = CV_HREG_e(516i32);
pub const CV_SHMEDIA_FV8: CV_HREG_e = CV_HREG_e(520i32);
pub const CV_SHMEDIA_FV12: CV_HREG_e = CV_HREG_e(524i32);
pub const CV_SHMEDIA_FV16: CV_HREG_e = CV_HREG_e(528i32);
pub const CV_SHMEDIA_FV20: CV_HREG_e = CV_HREG_e(532i32);
pub const CV_SHMEDIA_FV24: CV_HREG_e = CV_HREG_e(536i32);
pub const CV_SHMEDIA_FV28: CV_HREG_e = CV_HREG_e(540i32);
pub const CV_SHMEDIA_FV32: CV_HREG_e = CV_HREG_e(544i32);
pub const CV_SHMEDIA_FV36: CV_HREG_e = CV_HREG_e(548i32);
pub const CV_SHMEDIA_FV40: CV_HREG_e = CV_HREG_e(552i32);
pub const CV_SHMEDIA_FV44: CV_HREG_e = CV_HREG_e(556i32);
pub const CV_SHMEDIA_FV48: CV_HREG_e = CV_HREG_e(560i32);
pub const CV_SHMEDIA_FV52: CV_HREG_e = CV_HREG_e(564i32);
pub const CV_SHMEDIA_FV56: CV_HREG_e = CV_HREG_e(568i32);
pub const CV_SHMEDIA_FV60: CV_HREG_e = CV_HREG_e(572i32);
pub const CV_SHMEDIA_MTRX0: CV_HREG_e = CV_HREG_e(1024i32);
pub const CV_SHMEDIA_MTRX16: CV_HREG_e = CV_HREG_e(1040i32);
pub const CV_SHMEDIA_MTRX32: CV_HREG_e = CV_HREG_e(1056i32);
pub const CV_SHMEDIA_MTRX48: CV_HREG_e = CV_HREG_e(1072i32);
pub const CV_SHMEDIA_CR0: CV_HREG_e = CV_HREG_e(2000i32);
pub const CV_SHMEDIA_CR1: CV_HREG_e = CV_HREG_e(2001i32);
pub const CV_SHMEDIA_CR2: CV_HREG_e = CV_HREG_e(2002i32);
pub const CV_SHMEDIA_CR3: CV_HREG_e = CV_HREG_e(2003i32);
pub const CV_SHMEDIA_CR4: CV_HREG_e = CV_HREG_e(2004i32);
pub const CV_SHMEDIA_CR5: CV_HREG_e = CV_HREG_e(2005i32);
pub const CV_SHMEDIA_CR6: CV_HREG_e = CV_HREG_e(2006i32);
pub const CV_SHMEDIA_CR7: CV_HREG_e = CV_HREG_e(2007i32);
pub const CV_SHMEDIA_CR8: CV_HREG_e = CV_HREG_e(2008i32);
pub const CV_SHMEDIA_CR9: CV_HREG_e = CV_HREG_e(2009i32);
pub const CV_SHMEDIA_CR10: CV_HREG_e = CV_HREG_e(2010i32);
pub const CV_SHMEDIA_CR11: CV_HREG_e = CV_HREG_e(2011i32);
pub const CV_SHMEDIA_CR12: CV_HREG_e = CV_HREG_e(2012i32);
pub const CV_SHMEDIA_CR13: CV_HREG_e = CV_HREG_e(2013i32);
pub const CV_SHMEDIA_CR14: CV_HREG_e = CV_HREG_e(2014i32);
pub const CV_SHMEDIA_CR15: CV_HREG_e = CV_HREG_e(2015i32);
pub const CV_SHMEDIA_CR16: CV_HREG_e = CV_HREG_e(2016i32);
pub const CV_SHMEDIA_CR17: CV_HREG_e = CV_HREG_e(2017i32);
pub const CV_SHMEDIA_CR18: CV_HREG_e = CV_HREG_e(2018i32);
pub const CV_SHMEDIA_CR19: CV_HREG_e = CV_HREG_e(2019i32);
pub const CV_SHMEDIA_CR20: CV_HREG_e = CV_HREG_e(2020i32);
pub const CV_SHMEDIA_CR21: CV_HREG_e = CV_HREG_e(2021i32);
pub const CV_SHMEDIA_CR22: CV_HREG_e = CV_HREG_e(2022i32);
pub const CV_SHMEDIA_CR23: CV_HREG_e = CV_HREG_e(2023i32);
pub const CV_SHMEDIA_CR24: CV_HREG_e = CV_HREG_e(2024i32);
pub const CV_SHMEDIA_CR25: CV_HREG_e = CV_HREG_e(2025i32);
pub const CV_SHMEDIA_CR26: CV_HREG_e = CV_HREG_e(2026i32);
pub const CV_SHMEDIA_CR27: CV_HREG_e = CV_HREG_e(2027i32);
pub const CV_SHMEDIA_CR28: CV_HREG_e = CV_HREG_e(2028i32);
pub const CV_SHMEDIA_CR29: CV_HREG_e = CV_HREG_e(2029i32);
pub const CV_SHMEDIA_CR30: CV_HREG_e = CV_HREG_e(2030i32);
pub const CV_SHMEDIA_CR31: CV_HREG_e = CV_HREG_e(2031i32);
pub const CV_SHMEDIA_CR32: CV_HREG_e = CV_HREG_e(2032i32);
pub const CV_SHMEDIA_CR33: CV_HREG_e = CV_HREG_e(2033i32);
pub const CV_SHMEDIA_CR34: CV_HREG_e = CV_HREG_e(2034i32);
pub const CV_SHMEDIA_CR35: CV_HREG_e = CV_HREG_e(2035i32);
pub const CV_SHMEDIA_CR36: CV_HREG_e = CV_HREG_e(2036i32);
pub const CV_SHMEDIA_CR37: CV_HREG_e = CV_HREG_e(2037i32);
pub const CV_SHMEDIA_CR38: CV_HREG_e = CV_HREG_e(2038i32);
pub const CV_SHMEDIA_CR39: CV_HREG_e = CV_HREG_e(2039i32);
pub const CV_SHMEDIA_CR40: CV_HREG_e = CV_HREG_e(2040i32);
pub const CV_SHMEDIA_CR41: CV_HREG_e = CV_HREG_e(2041i32);
pub const CV_SHMEDIA_CR42: CV_HREG_e = CV_HREG_e(2042i32);
pub const CV_SHMEDIA_CR43: CV_HREG_e = CV_HREG_e(2043i32);
pub const CV_SHMEDIA_CR44: CV_HREG_e = CV_HREG_e(2044i32);
pub const CV_SHMEDIA_CR45: CV_HREG_e = CV_HREG_e(2045i32);
pub const CV_SHMEDIA_CR46: CV_HREG_e = CV_HREG_e(2046i32);
pub const CV_SHMEDIA_CR47: CV_HREG_e = CV_HREG_e(2047i32);
pub const CV_SHMEDIA_CR48: CV_HREG_e = CV_HREG_e(2048i32);
pub const CV_SHMEDIA_CR49: CV_HREG_e = CV_HREG_e(2049i32);
pub const CV_SHMEDIA_CR50: CV_HREG_e = CV_HREG_e(2050i32);
pub const CV_SHMEDIA_CR51: CV_HREG_e = CV_HREG_e(2051i32);
pub const CV_SHMEDIA_CR52: CV_HREG_e = CV_HREG_e(2052i32);
pub const CV_SHMEDIA_CR53: CV_HREG_e = CV_HREG_e(2053i32);
pub const CV_SHMEDIA_CR54: CV_HREG_e = CV_HREG_e(2054i32);
pub const CV_SHMEDIA_CR55: CV_HREG_e = CV_HREG_e(2055i32);
pub const CV_SHMEDIA_CR56: CV_HREG_e = CV_HREG_e(2056i32);
pub const CV_SHMEDIA_CR57: CV_HREG_e = CV_HREG_e(2057i32);
pub const CV_SHMEDIA_CR58: CV_HREG_e = CV_HREG_e(2058i32);
pub const CV_SHMEDIA_CR59: CV_HREG_e = CV_HREG_e(2059i32);
pub const CV_SHMEDIA_CR60: CV_HREG_e = CV_HREG_e(2060i32);
pub const CV_SHMEDIA_CR61: CV_HREG_e = CV_HREG_e(2061i32);
pub const CV_SHMEDIA_CR62: CV_HREG_e = CV_HREG_e(2062i32);
pub const CV_SHMEDIA_CR63: CV_HREG_e = CV_HREG_e(2063i32);
pub const CV_SHMEDIA_FPSCR: CV_HREG_e = CV_HREG_e(2064i32);
pub const CV_SHMEDIA_GBR: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_SHMEDIA_MACL: CV_HREG_e = CV_HREG_e(90i32);
pub const CV_SHMEDIA_MACH: CV_HREG_e = CV_HREG_e(91i32);
pub const CV_SHMEDIA_PR: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_SHMEDIA_T: CV_HREG_e = CV_HREG_e(92i32);
pub const CV_SHMEDIA_FPUL: CV_HREG_e = CV_HREG_e(160i32);
pub const CV_SHMEDIA_PC: CV_HREG_e = CV_HREG_e(93i32);
pub const CV_SHMEDIA_SR: CV_HREG_e = CV_HREG_e(2000i32);
pub const CV_AMD64_AL: CV_HREG_e = CV_HREG_e(1i32);
pub const CV_AMD64_CL: CV_HREG_e = CV_HREG_e(2i32);
pub const CV_AMD64_DL: CV_HREG_e = CV_HREG_e(3i32);
pub const CV_AMD64_BL: CV_HREG_e = CV_HREG_e(4i32);
pub const CV_AMD64_AH: CV_HREG_e = CV_HREG_e(5i32);
pub const CV_AMD64_CH: CV_HREG_e = CV_HREG_e(6i32);
pub const CV_AMD64_DH: CV_HREG_e = CV_HREG_e(7i32);
pub const CV_AMD64_BH: CV_HREG_e = CV_HREG_e(8i32);
pub const CV_AMD64_AX: CV_HREG_e = CV_HREG_e(9i32);
pub const CV_AMD64_CX: CV_HREG_e = CV_HREG_e(10i32);
pub const CV_AMD64_DX: CV_HREG_e = CV_HREG_e(11i32);
pub const CV_AMD64_BX: CV_HREG_e = CV_HREG_e(12i32);
pub const CV_AMD64_SP: CV_HREG_e = CV_HREG_e(13i32);
pub const CV_AMD64_BP: CV_HREG_e = CV_HREG_e(14i32);
pub const CV_AMD64_SI: CV_HREG_e = CV_HREG_e(15i32);
pub const CV_AMD64_DI: CV_HREG_e = CV_HREG_e(16i32);
pub const CV_AMD64_EAX: CV_HREG_e = CV_HREG_e(17i32);
pub const CV_AMD64_ECX: CV_HREG_e = CV_HREG_e(18i32);
pub const CV_AMD64_EDX: CV_HREG_e = CV_HREG_e(19i32);
pub const CV_AMD64_EBX: CV_HREG_e = CV_HREG_e(20i32);
pub const CV_AMD64_ESP: CV_HREG_e = CV_HREG_e(21i32);
pub const CV_AMD64_EBP: CV_HREG_e = CV_HREG_e(22i32);
pub const CV_AMD64_ESI: CV_HREG_e = CV_HREG_e(23i32);
pub const CV_AMD64_EDI: CV_HREG_e = CV_HREG_e(24i32);
pub const CV_AMD64_ES: CV_HREG_e = CV_HREG_e(25i32);
pub const CV_AMD64_CS: CV_HREG_e = CV_HREG_e(26i32);
pub const CV_AMD64_SS: CV_HREG_e = CV_HREG_e(27i32);
pub const CV_AMD64_DS: CV_HREG_e = CV_HREG_e(28i32);
pub const CV_AMD64_FS: CV_HREG_e = CV_HREG_e(29i32);
pub const CV_AMD64_GS: CV_HREG_e = CV_HREG_e(30i32);
pub const CV_AMD64_FLAGS: CV_HREG_e = CV_HREG_e(32i32);
pub const CV_AMD64_RIP: CV_HREG_e = CV_HREG_e(33i32);
pub const CV_AMD64_EFLAGS: CV_HREG_e = CV_HREG_e(34i32);
pub const CV_AMD64_CR0: CV_HREG_e = CV_HREG_e(80i32);
pub const CV_AMD64_CR1: CV_HREG_e = CV_HREG_e(81i32);
pub const CV_AMD64_CR2: CV_HREG_e = CV_HREG_e(82i32);
pub const CV_AMD64_CR3: CV_HREG_e = CV_HREG_e(83i32);
pub const CV_AMD64_CR4: CV_HREG_e = CV_HREG_e(84i32);
pub const CV_AMD64_CR8: CV_HREG_e = CV_HREG_e(88i32);
pub const CV_AMD64_DR0: CV_HREG_e = CV_HREG_e(90i32);
pub const CV_AMD64_DR1: CV_HREG_e = CV_HREG_e(91i32);
pub const CV_AMD64_DR2: CV_HREG_e = CV_HREG_e(92i32);
pub const CV_AMD64_DR3: CV_HREG_e = CV_HREG_e(93i32);
pub const CV_AMD64_DR4: CV_HREG_e = CV_HREG_e(94i32);
pub const CV_AMD64_DR5: CV_HREG_e = CV_HREG_e(95i32);
pub const CV_AMD64_DR6: CV_HREG_e = CV_HREG_e(96i32);
pub const CV_AMD64_DR7: CV_HREG_e = CV_HREG_e(97i32);
pub const CV_AMD64_DR8: CV_HREG_e = CV_HREG_e(98i32);
pub const CV_AMD64_DR9: CV_HREG_e = CV_HREG_e(99i32);
pub const CV_AMD64_DR10: CV_HREG_e = CV_HREG_e(100i32);
pub const CV_AMD64_DR11: CV_HREG_e = CV_HREG_e(101i32);
pub const CV_AMD64_DR12: CV_HREG_e = CV_HREG_e(102i32);
pub const CV_AMD64_DR13: CV_HREG_e = CV_HREG_e(103i32);
pub const CV_AMD64_DR14: CV_HREG_e = CV_HREG_e(104i32);
pub const CV_AMD64_DR15: CV_HREG_e = CV_HREG_e(105i32);
pub const CV_AMD64_GDTR: CV_HREG_e = CV_HREG_e(110i32);
pub const CV_AMD64_GDTL: CV_HREG_e = CV_HREG_e(111i32);
pub const CV_AMD64_IDTR: CV_HREG_e = CV_HREG_e(112i32);
pub const CV_AMD64_IDTL: CV_HREG_e = CV_HREG_e(113i32);
pub const CV_AMD64_LDTR: CV_HREG_e = CV_HREG_e(114i32);
pub const CV_AMD64_TR: CV_HREG_e = CV_HREG_e(115i32);
pub const CV_AMD64_ST0: CV_HREG_e = CV_HREG_e(128i32);
pub const CV_AMD64_ST1: CV_HREG_e = CV_HREG_e(129i32);
pub const CV_AMD64_ST2: CV_HREG_e = CV_HREG_e(130i32);
pub const CV_AMD64_ST3: CV_HREG_e = CV_HREG_e(131i32);
pub const CV_AMD64_ST4: CV_HREG_e = CV_HREG_e(132i32);
pub const CV_AMD64_ST5: CV_HREG_e = CV_HREG_e(133i32);
pub const CV_AMD64_ST6: CV_HREG_e = CV_HREG_e(134i32);
pub const CV_AMD64_ST7: CV_HREG_e = CV_HREG_e(135i32);
pub const CV_AMD64_CTRL: CV_HREG_e = CV_HREG_e(136i32);
pub const CV_AMD64_STAT: CV_HREG_e = CV_HREG_e(137i32);
pub const CV_AMD64_TAG: CV_HREG_e = CV_HREG_e(138i32);
pub const CV_AMD64_FPIP: CV_HREG_e = CV_HREG_e(139i32);
pub const CV_AMD64_FPCS: CV_HREG_e = CV_HREG_e(140i32);
pub const CV_AMD64_FPDO: CV_HREG_e = CV_HREG_e(141i32);
pub const CV_AMD64_FPDS: CV_HREG_e = CV_HREG_e(142i32);
pub const CV_AMD64_ISEM: CV_HREG_e = CV_HREG_e(143i32);
pub const CV_AMD64_FPEIP: CV_HREG_e = CV_HREG_e(144i32);
pub const CV_AMD64_FPEDO: CV_HREG_e = CV_HREG_e(145i32);
pub const CV_AMD64_MM0: CV_HREG_e = CV_HREG_e(146i32);
pub const CV_AMD64_MM1: CV_HREG_e = CV_HREG_e(147i32);
pub const CV_AMD64_MM2: CV_HREG_e = CV_HREG_e(148i32);
pub const CV_AMD64_MM3: CV_HREG_e = CV_HREG_e(149i32);
pub const CV_AMD64_MM4: CV_HREG_e = CV_HREG_e(150i32);
pub const CV_AMD64_MM5: CV_HREG_e = CV_HREG_e(151i32);
pub const CV_AMD64_MM6: CV_HREG_e = CV_HREG_e(152i32);
pub const CV_AMD64_MM7: CV_HREG_e = CV_HREG_e(153i32);
pub const CV_AMD64_XMM0: CV_HREG_e = CV_HREG_e(154i32);
pub const CV_AMD64_XMM1: CV_HREG_e = CV_HREG_e(155i32);
pub const CV_AMD64_XMM2: CV_HREG_e = CV_HREG_e(156i32);
pub const CV_AMD64_XMM3: CV_HREG_e = CV_HREG_e(157i32);
pub const CV_AMD64_XMM4: CV_HREG_e = CV_HREG_e(158i32);
pub const CV_AMD64_XMM5: CV_HREG_e = CV_HREG_e(159i32);
pub const CV_AMD64_XMM6: CV_HREG_e = CV_HREG_e(160i32);
pub const CV_AMD64_XMM7: CV_HREG_e = CV_HREG_e(161i32);
pub const CV_AMD64_XMM0_0: CV_HREG_e = CV_HREG_e(162i32);
pub const CV_AMD64_XMM0_1: CV_HREG_e = CV_HREG_e(163i32);
pub const CV_AMD64_XMM0_2: CV_HREG_e = CV_HREG_e(164i32);
pub const CV_AMD64_XMM0_3: CV_HREG_e = CV_HREG_e(165i32);
pub const CV_AMD64_XMM1_0: CV_HREG_e = CV_HREG_e(166i32);
pub const CV_AMD64_XMM1_1: CV_HREG_e = CV_HREG_e(167i32);
pub const CV_AMD64_XMM1_2: CV_HREG_e = CV_HREG_e(168i32);
pub const CV_AMD64_XMM1_3: CV_HREG_e = CV_HREG_e(169i32);
pub const CV_AMD64_XMM2_0: CV_HREG_e = CV_HREG_e(170i32);
pub const CV_AMD64_XMM2_1: CV_HREG_e = CV_HREG_e(171i32);
pub const CV_AMD64_XMM2_2: CV_HREG_e = CV_HREG_e(172i32);
pub const CV_AMD64_XMM2_3: CV_HREG_e = CV_HREG_e(173i32);
pub const CV_AMD64_XMM3_0: CV_HREG_e = CV_HREG_e(174i32);
pub const CV_AMD64_XMM3_1: CV_HREG_e = CV_HREG_e(175i32);
pub const CV_AMD64_XMM3_2: CV_HREG_e = CV_HREG_e(176i32);
pub const CV_AMD64_XMM3_3: CV_HREG_e = CV_HREG_e(177i32);
pub const CV_AMD64_XMM4_0: CV_HREG_e = CV_HREG_e(178i32);
pub const CV_AMD64_XMM4_1: CV_HREG_e = CV_HREG_e(179i32);
pub const CV_AMD64_XMM4_2: CV_HREG_e = CV_HREG_e(180i32);
pub const CV_AMD64_XMM4_3: CV_HREG_e = CV_HREG_e(181i32);
pub const CV_AMD64_XMM5_0: CV_HREG_e = CV_HREG_e(182i32);
pub const CV_AMD64_XMM5_1: CV_HREG_e = CV_HREG_e(183i32);
pub const CV_AMD64_XMM5_2: CV_HREG_e = CV_HREG_e(184i32);
pub const CV_AMD64_XMM5_3: CV_HREG_e = CV_HREG_e(185i32);
pub const CV_AMD64_XMM6_0: CV_HREG_e = CV_HREG_e(186i32);
pub const CV_AMD64_XMM6_1: CV_HREG_e = CV_HREG_e(187i32);
pub const CV_AMD64_XMM6_2: CV_HREG_e = CV_HREG_e(188i32);
pub const CV_AMD64_XMM6_3: CV_HREG_e = CV_HREG_e(189i32);
pub const CV_AMD64_XMM7_0: CV_HREG_e = CV_HREG_e(190i32);
pub const CV_AMD64_XMM7_1: CV_HREG_e = CV_HREG_e(191i32);
pub const CV_AMD64_XMM7_2: CV_HREG_e = CV_HREG_e(192i32);
pub const CV_AMD64_XMM7_3: CV_HREG_e = CV_HREG_e(193i32);
pub const CV_AMD64_XMM0L: CV_HREG_e = CV_HREG_e(194i32);
pub const CV_AMD64_XMM1L: CV_HREG_e = CV_HREG_e(195i32);
pub const CV_AMD64_XMM2L: CV_HREG_e = CV_HREG_e(196i32);
pub const CV_AMD64_XMM3L: CV_HREG_e = CV_HREG_e(197i32);
pub const CV_AMD64_XMM4L: CV_HREG_e = CV_HREG_e(198i32);
pub const CV_AMD64_XMM5L: CV_HREG_e = CV_HREG_e(199i32);
pub const CV_AMD64_XMM6L: CV_HREG_e = CV_HREG_e(200i32);
pub const CV_AMD64_XMM7L: CV_HREG_e = CV_HREG_e(201i32);
pub const CV_AMD64_XMM0H: CV_HREG_e = CV_HREG_e(202i32);
pub const CV_AMD64_XMM1H: CV_HREG_e = CV_HREG_e(203i32);
pub const CV_AMD64_XMM2H: CV_HREG_e = CV_HREG_e(204i32);
pub const CV_AMD64_XMM3H: CV_HREG_e = CV_HREG_e(205i32);
pub const CV_AMD64_XMM4H: CV_HREG_e = CV_HREG_e(206i32);
pub const CV_AMD64_XMM5H: CV_HREG_e = CV_HREG_e(207i32);
pub const CV_AMD64_XMM6H: CV_HREG_e = CV_HREG_e(208i32);
pub const CV_AMD64_XMM7H: CV_HREG_e = CV_HREG_e(209i32);
pub const CV_AMD64_MXCSR: CV_HREG_e = CV_HREG_e(211i32);
pub const CV_AMD64_EMM0L: CV_HREG_e = CV_HREG_e(220i32);
pub const CV_AMD64_EMM1L: CV_HREG_e = CV_HREG_e(221i32);
pub const CV_AMD64_EMM2L: CV_HREG_e = CV_HREG_e(222i32);
pub const CV_AMD64_EMM3L: CV_HREG_e = CV_HREG_e(223i32);
pub const CV_AMD64_EMM4L: CV_HREG_e = CV_HREG_e(224i32);
pub const CV_AMD64_EMM5L: CV_HREG_e = CV_HREG_e(225i32);
pub const CV_AMD64_EMM6L: CV_HREG_e = CV_HREG_e(226i32);
pub const CV_AMD64_EMM7L: CV_HREG_e = CV_HREG_e(227i32);
pub const CV_AMD64_EMM0H: CV_HREG_e = CV_HREG_e(228i32);
pub const CV_AMD64_EMM1H: CV_HREG_e = CV_HREG_e(229i32);
pub const CV_AMD64_EMM2H: CV_HREG_e = CV_HREG_e(230i32);
pub const CV_AMD64_EMM3H: CV_HREG_e = CV_HREG_e(231i32);
pub const CV_AMD64_EMM4H: CV_HREG_e = CV_HREG_e(232i32);
pub const CV_AMD64_EMM5H: CV_HREG_e = CV_HREG_e(233i32);
pub const CV_AMD64_EMM6H: CV_HREG_e = CV_HREG_e(234i32);
pub const CV_AMD64_EMM7H: CV_HREG_e = CV_HREG_e(235i32);
pub const CV_AMD64_MM00: CV_HREG_e = CV_HREG_e(236i32);
pub const CV_AMD64_MM01: CV_HREG_e = CV_HREG_e(237i32);
pub const CV_AMD64_MM10: CV_HREG_e = CV_HREG_e(238i32);
pub const CV_AMD64_MM11: CV_HREG_e = CV_HREG_e(239i32);
pub const CV_AMD64_MM20: CV_HREG_e = CV_HREG_e(240i32);
pub const CV_AMD64_MM21: CV_HREG_e = CV_HREG_e(241i32);
pub const CV_AMD64_MM30: CV_HREG_e = CV_HREG_e(242i32);
pub const CV_AMD64_MM31: CV_HREG_e = CV_HREG_e(243i32);
pub const CV_AMD64_MM40: CV_HREG_e = CV_HREG_e(244i32);
pub const CV_AMD64_MM41: CV_HREG_e = CV_HREG_e(245i32);
pub const CV_AMD64_MM50: CV_HREG_e = CV_HREG_e(246i32);
pub const CV_AMD64_MM51: CV_HREG_e = CV_HREG_e(247i32);
pub const CV_AMD64_MM60: CV_HREG_e = CV_HREG_e(248i32);
pub const CV_AMD64_MM61: CV_HREG_e = CV_HREG_e(249i32);
pub const CV_AMD64_MM70: CV_HREG_e = CV_HREG_e(250i32);
pub const CV_AMD64_MM71: CV_HREG_e = CV_HREG_e(251i32);
pub const CV_AMD64_XMM8: CV_HREG_e = CV_HREG_e(252i32);
pub const CV_AMD64_XMM9: CV_HREG_e = CV_HREG_e(253i32);
pub const CV_AMD64_XMM10: CV_HREG_e = CV_HREG_e(254i32);
pub const CV_AMD64_XMM11: CV_HREG_e = CV_HREG_e(255i32);
pub const CV_AMD64_XMM12: CV_HREG_e = CV_HREG_e(256i32);
pub const CV_AMD64_XMM13: CV_HREG_e = CV_HREG_e(257i32);
pub const CV_AMD64_XMM14: CV_HREG_e = CV_HREG_e(258i32);
pub const CV_AMD64_XMM15: CV_HREG_e = CV_HREG_e(259i32);
pub const CV_AMD64_XMM8_0: CV_HREG_e = CV_HREG_e(260i32);
pub const CV_AMD64_XMM8_1: CV_HREG_e = CV_HREG_e(261i32);
pub const CV_AMD64_XMM8_2: CV_HREG_e = CV_HREG_e(262i32);
pub const CV_AMD64_XMM8_3: CV_HREG_e = CV_HREG_e(263i32);
pub const CV_AMD64_XMM9_0: CV_HREG_e = CV_HREG_e(264i32);
pub const CV_AMD64_XMM9_1: CV_HREG_e = CV_HREG_e(265i32);
pub const CV_AMD64_XMM9_2: CV_HREG_e = CV_HREG_e(266i32);
pub const CV_AMD64_XMM9_3: CV_HREG_e = CV_HREG_e(267i32);
pub const CV_AMD64_XMM10_0: CV_HREG_e = CV_HREG_e(268i32);
pub const CV_AMD64_XMM10_1: CV_HREG_e = CV_HREG_e(269i32);
pub const CV_AMD64_XMM10_2: CV_HREG_e = CV_HREG_e(270i32);
pub const CV_AMD64_XMM10_3: CV_HREG_e = CV_HREG_e(271i32);
pub const CV_AMD64_XMM11_0: CV_HREG_e = CV_HREG_e(272i32);
pub const CV_AMD64_XMM11_1: CV_HREG_e = CV_HREG_e(273i32);
pub const CV_AMD64_XMM11_2: CV_HREG_e = CV_HREG_e(274i32);
pub const CV_AMD64_XMM11_3: CV_HREG_e = CV_HREG_e(275i32);
pub const CV_AMD64_XMM12_0: CV_HREG_e = CV_HREG_e(276i32);
pub const CV_AMD64_XMM12_1: CV_HREG_e = CV_HREG_e(277i32);
pub const CV_AMD64_XMM12_2: CV_HREG_e = CV_HREG_e(278i32);
pub const CV_AMD64_XMM12_3: CV_HREG_e = CV_HREG_e(279i32);
pub const CV_AMD64_XMM13_0: CV_HREG_e = CV_HREG_e(280i32);
pub const CV_AMD64_XMM13_1: CV_HREG_e = CV_HREG_e(281i32);
pub const CV_AMD64_XMM13_2: CV_HREG_e = CV_HREG_e(282i32);
pub const CV_AMD64_XMM13_3: CV_HREG_e = CV_HREG_e(283i32);
pub const CV_AMD64_XMM14_0: CV_HREG_e = CV_HREG_e(284i32);
pub const CV_AMD64_XMM14_1: CV_HREG_e = CV_HREG_e(285i32);
pub const CV_AMD64_XMM14_2: CV_HREG_e = CV_HREG_e(286i32);
pub const CV_AMD64_XMM14_3: CV_HREG_e = CV_HREG_e(287i32);
pub const CV_AMD64_XMM15_0: CV_HREG_e = CV_HREG_e(288i32);
pub const CV_AMD64_XMM15_1: CV_HREG_e = CV_HREG_e(289i32);
pub const CV_AMD64_XMM15_2: CV_HREG_e = CV_HREG_e(290i32);
pub const CV_AMD64_XMM15_3: CV_HREG_e = CV_HREG_e(291i32);
pub const CV_AMD64_XMM8L: CV_HREG_e = CV_HREG_e(292i32);
pub const CV_AMD64_XMM9L: CV_HREG_e = CV_HREG_e(293i32);
pub const CV_AMD64_XMM10L: CV_HREG_e = CV_HREG_e(294i32);
pub const CV_AMD64_XMM11L: CV_HREG_e = CV_HREG_e(295i32);
pub const CV_AMD64_XMM12L: CV_HREG_e = CV_HREG_e(296i32);
pub const CV_AMD64_XMM13L: CV_HREG_e = CV_HREG_e(297i32);
pub const CV_AMD64_XMM14L: CV_HREG_e = CV_HREG_e(298i32);
pub const CV_AMD64_XMM15L: CV_HREG_e = CV_HREG_e(299i32);
pub const CV_AMD64_XMM8H: CV_HREG_e = CV_HREG_e(300i32);
pub const CV_AMD64_XMM9H: CV_HREG_e = CV_HREG_e(301i32);
pub const CV_AMD64_XMM10H: CV_HREG_e = CV_HREG_e(302i32);
pub const CV_AMD64_XMM11H: CV_HREG_e = CV_HREG_e(303i32);
pub const CV_AMD64_XMM12H: CV_HREG_e = CV_HREG_e(304i32);
pub const CV_AMD64_XMM13H: CV_HREG_e = CV_HREG_e(305i32);
pub const CV_AMD64_XMM14H: CV_HREG_e = CV_HREG_e(306i32);
pub const CV_AMD64_XMM15H: CV_HREG_e = CV_HREG_e(307i32);
pub const CV_AMD64_EMM8L: CV_HREG_e = CV_HREG_e(308i32);
pub const CV_AMD64_EMM9L: CV_HREG_e = CV_HREG_e(309i32);
pub const CV_AMD64_EMM10L: CV_HREG_e = CV_HREG_e(310i32);
pub const CV_AMD64_EMM11L: CV_HREG_e = CV_HREG_e(311i32);
pub const CV_AMD64_EMM12L: CV_HREG_e = CV_HREG_e(312i32);
pub const CV_AMD64_EMM13L: CV_HREG_e = CV_HREG_e(313i32);
pub const CV_AMD64_EMM14L: CV_HREG_e = CV_HREG_e(314i32);
pub const CV_AMD64_EMM15L: CV_HREG_e = CV_HREG_e(315i32);
pub const CV_AMD64_EMM8H: CV_HREG_e = CV_HREG_e(316i32);
pub const CV_AMD64_EMM9H: CV_HREG_e = CV_HREG_e(317i32);
pub const CV_AMD64_EMM10H: CV_HREG_e = CV_HREG_e(318i32);
pub const CV_AMD64_EMM11H: CV_HREG_e = CV_HREG_e(319i32);
pub const CV_AMD64_EMM12H: CV_HREG_e = CV_HREG_e(320i32);
pub const CV_AMD64_EMM13H: CV_HREG_e = CV_HREG_e(321i32);
pub const CV_AMD64_EMM14H: CV_HREG_e = CV_HREG_e(322i32);
pub const CV_AMD64_EMM15H: CV_HREG_e = CV_HREG_e(323i32);
pub const CV_AMD64_SIL: CV_HREG_e = CV_HREG_e(324i32);
pub const CV_AMD64_DIL: CV_HREG_e = CV_HREG_e(325i32);
pub const CV_AMD64_BPL: CV_HREG_e = CV_HREG_e(326i32);
pub const CV_AMD64_SPL: CV_HREG_e = CV_HREG_e(327i32);
pub const CV_AMD64_RAX: CV_HREG_e = CV_HREG_e(328i32);
pub const CV_AMD64_RBX: CV_HREG_e = CV_HREG_e(329i32);
pub const CV_AMD64_RCX: CV_HREG_e = CV_HREG_e(330i32);
pub const CV_AMD64_RDX: CV_HREG_e = CV_HREG_e(331i32);
pub const CV_AMD64_RSI: CV_HREG_e = CV_HREG_e(332i32);
pub const CV_AMD64_RDI: CV_HREG_e = CV_HREG_e(333i32);
pub const CV_AMD64_RBP: CV_HREG_e = CV_HREG_e(334i32);
pub const CV_AMD64_RSP: CV_HREG_e = CV_HREG_e(335i32);
pub const CV_AMD64_R8: CV_HREG_e = CV_HREG_e(336i32);
pub const CV_AMD64_R9: CV_HREG_e = CV_HREG_e(337i32);
pub const CV_AMD64_R10: CV_HREG_e = CV_HREG_e(338i32);
pub const CV_AMD64_R11: CV_HREG_e = CV_HREG_e(339i32);
pub const CV_AMD64_R12: CV_HREG_e = CV_HREG_e(340i32);
pub const CV_AMD64_R13: CV_HREG_e = CV_HREG_e(341i32);
pub const CV_AMD64_R14: CV_HREG_e = CV_HREG_e(342i32);
pub const CV_AMD64_R15: CV_HREG_e = CV_HREG_e(343i32);
pub const CV_AMD64_R8B: CV_HREG_e = CV_HREG_e(344i32);
pub const CV_AMD64_R9B: CV_HREG_e = CV_HREG_e(345i32);
pub const CV_AMD64_R10B: CV_HREG_e = CV_HREG_e(346i32);
pub const CV_AMD64_R11B: CV_HREG_e = CV_HREG_e(347i32);
pub const CV_AMD64_R12B: CV_HREG_e = CV_HREG_e(348i32);
pub const CV_AMD64_R13B: CV_HREG_e = CV_HREG_e(349i32);
pub const CV_AMD64_R14B: CV_HREG_e = CV_HREG_e(350i32);
pub const CV_AMD64_R15B: CV_HREG_e = CV_HREG_e(351i32);
pub const CV_AMD64_R8W: CV_HREG_e = CV_HREG_e(352i32);
pub const CV_AMD64_R9W: CV_HREG_e = CV_HREG_e(353i32);
pub const CV_AMD64_R10W: CV_HREG_e = CV_HREG_e(354i32);
pub const CV_AMD64_R11W: CV_HREG_e = CV_HREG_e(355i32);
pub const CV_AMD64_R12W: CV_HREG_e = CV_HREG_e(356i32);
pub const CV_AMD64_R13W: CV_HREG_e = CV_HREG_e(357i32);
pub const CV_AMD64_R14W: CV_HREG_e = CV_HREG_e(358i32);
pub const CV_AMD64_R15W: CV_HREG_e = CV_HREG_e(359i32);
pub const CV_AMD64_R8D: CV_HREG_e = CV_HREG_e(360i32);
pub const CV_AMD64_R9D: CV_HREG_e = CV_HREG_e(361i32);
pub const CV_AMD64_R10D: CV_HREG_e = CV_HREG_e(362i32);
pub const CV_AMD64_R11D: CV_HREG_e = CV_HREG_e(363i32);
pub const CV_AMD64_R12D: CV_HREG_e = CV_HREG_e(364i32);
pub const CV_AMD64_R13D: CV_HREG_e = CV_HREG_e(365i32);
pub const CV_AMD64_R14D: CV_HREG_e = CV_HREG_e(366i32);
pub const CV_AMD64_R15D: CV_HREG_e = CV_HREG_e(367i32);
pub const CV_AMD64_YMM0: CV_HREG_e = CV_HREG_e(368i32);
pub const CV_AMD64_YMM1: CV_HREG_e = CV_HREG_e(369i32);
pub const CV_AMD64_YMM2: CV_HREG_e = CV_HREG_e(370i32);
pub const CV_AMD64_YMM3: CV_HREG_e = CV_HREG_e(371i32);
pub const CV_AMD64_YMM4: CV_HREG_e = CV_HREG_e(372i32);
pub const CV_AMD64_YMM5: CV_HREG_e = CV_HREG_e(373i32);
pub const CV_AMD64_YMM6: CV_HREG_e = CV_HREG_e(374i32);
pub const CV_AMD64_YMM7: CV_HREG_e = CV_HREG_e(375i32);
pub const CV_AMD64_YMM8: CV_HREG_e = CV_HREG_e(376i32);
pub const CV_AMD64_YMM9: CV_HREG_e = CV_HREG_e(377i32);
pub const CV_AMD64_YMM10: CV_HREG_e = CV_HREG_e(378i32);
pub const CV_AMD64_YMM11: CV_HREG_e = CV_HREG_e(379i32);
pub const CV_AMD64_YMM12: CV_HREG_e = CV_HREG_e(380i32);
pub const CV_AMD64_YMM13: CV_HREG_e = CV_HREG_e(381i32);
pub const CV_AMD64_YMM14: CV_HREG_e = CV_HREG_e(382i32);
pub const CV_AMD64_YMM15: CV_HREG_e = CV_HREG_e(383i32);
pub const CV_AMD64_YMM0H: CV_HREG_e = CV_HREG_e(384i32);
pub const CV_AMD64_YMM1H: CV_HREG_e = CV_HREG_e(385i32);
pub const CV_AMD64_YMM2H: CV_HREG_e = CV_HREG_e(386i32);
pub const CV_AMD64_YMM3H: CV_HREG_e = CV_HREG_e(387i32);
pub const CV_AMD64_YMM4H: CV_HREG_e = CV_HREG_e(388i32);
pub const CV_AMD64_YMM5H: CV_HREG_e = CV_HREG_e(389i32);
pub const CV_AMD64_YMM6H: CV_HREG_e = CV_HREG_e(390i32);
pub const CV_AMD64_YMM7H: CV_HREG_e = CV_HREG_e(391i32);
pub const CV_AMD64_YMM8H: CV_HREG_e = CV_HREG_e(392i32);
pub const CV_AMD64_YMM9H: CV_HREG_e = CV_HREG_e(393i32);
pub const CV_AMD64_YMM10H: CV_HREG_e = CV_HREG_e(394i32);
pub const CV_AMD64_YMM11H: CV_HREG_e = CV_HREG_e(395i32);
pub const CV_AMD64_YMM12H: CV_HREG_e = CV_HREG_e(396i32);
pub const CV_AMD64_YMM13H: CV_HREG_e = CV_HREG_e(397i32);
pub const CV_AMD64_YMM14H: CV_HREG_e = CV_HREG_e(398i32);
pub const CV_AMD64_YMM15H: CV_HREG_e = CV_HREG_e(399i32);
pub const CV_AMD64_XMM0IL: CV_HREG_e = CV_HREG_e(400i32);
pub const CV_AMD64_XMM1IL: CV_HREG_e = CV_HREG_e(401i32);
pub const CV_AMD64_XMM2IL: CV_HREG_e = CV_HREG_e(402i32);
pub const CV_AMD64_XMM3IL: CV_HREG_e = CV_HREG_e(403i32);
pub const CV_AMD64_XMM4IL: CV_HREG_e = CV_HREG_e(404i32);
pub const CV_AMD64_XMM5IL: CV_HREG_e = CV_HREG_e(405i32);
pub const CV_AMD64_XMM6IL: CV_HREG_e = CV_HREG_e(406i32);
pub const CV_AMD64_XMM7IL: CV_HREG_e = CV_HREG_e(407i32);
pub const CV_AMD64_XMM8IL: CV_HREG_e = CV_HREG_e(408i32);
pub const CV_AMD64_XMM9IL: CV_HREG_e = CV_HREG_e(409i32);
pub const CV_AMD64_XMM10IL: CV_HREG_e = CV_HREG_e(410i32);
pub const CV_AMD64_XMM11IL: CV_HREG_e = CV_HREG_e(411i32);
pub const CV_AMD64_XMM12IL: CV_HREG_e = CV_HREG_e(412i32);
pub const CV_AMD64_XMM13IL: CV_HREG_e = CV_HREG_e(413i32);
pub const CV_AMD64_XMM14IL: CV_HREG_e = CV_HREG_e(414i32);
pub const CV_AMD64_XMM15IL: CV_HREG_e = CV_HREG_e(415i32);
pub const CV_AMD64_XMM0IH: CV_HREG_e = CV_HREG_e(416i32);
pub const CV_AMD64_XMM1IH: CV_HREG_e = CV_HREG_e(417i32);
pub const CV_AMD64_XMM2IH: CV_HREG_e = CV_HREG_e(418i32);
pub const CV_AMD64_XMM3IH: CV_HREG_e = CV_HREG_e(419i32);
pub const CV_AMD64_XMM4IH: CV_HREG_e = CV_HREG_e(420i32);
pub const CV_AMD64_XMM5IH: CV_HREG_e = CV_HREG_e(421i32);
pub const CV_AMD64_XMM6IH: CV_HREG_e = CV_HREG_e(422i32);
pub const CV_AMD64_XMM7IH: CV_HREG_e = CV_HREG_e(423i32);
pub const CV_AMD64_XMM8IH: CV_HREG_e = CV_HREG_e(424i32);
pub const CV_AMD64_XMM9IH: CV_HREG_e = CV_HREG_e(425i32);
pub const CV_AMD64_XMM10IH: CV_HREG_e = CV_HREG_e(426i32);
pub const CV_AMD64_XMM11IH: CV_HREG_e = CV_HREG_e(427i32);
pub const CV_AMD64_XMM12IH: CV_HREG_e = CV_HREG_e(428i32);
pub const CV_AMD64_XMM13IH: CV_HREG_e = CV_HREG_e(429i32);
pub const CV_AMD64_XMM14IH: CV_HREG_e = CV_HREG_e(430i32);
pub const CV_AMD64_XMM15IH: CV_HREG_e = CV_HREG_e(431i32);
pub const CV_AMD64_YMM0I0: CV_HREG_e = CV_HREG_e(432i32);
pub const CV_AMD64_YMM0I1: CV_HREG_e = CV_HREG_e(433i32);
pub const CV_AMD64_YMM0I2: CV_HREG_e = CV_HREG_e(434i32);
pub const CV_AMD64_YMM0I3: CV_HREG_e = CV_HREG_e(435i32);
pub const CV_AMD64_YMM1I0: CV_HREG_e = CV_HREG_e(436i32);
pub const CV_AMD64_YMM1I1: CV_HREG_e = CV_HREG_e(437i32);
pub const CV_AMD64_YMM1I2: CV_HREG_e = CV_HREG_e(438i32);
pub const CV_AMD64_YMM1I3: CV_HREG_e = CV_HREG_e(439i32);
pub const CV_AMD64_YMM2I0: CV_HREG_e = CV_HREG_e(440i32);
pub const CV_AMD64_YMM2I1: CV_HREG_e = CV_HREG_e(441i32);
pub const CV_AMD64_YMM2I2: CV_HREG_e = CV_HREG_e(442i32);
pub const CV_AMD64_YMM2I3: CV_HREG_e = CV_HREG_e(443i32);
pub const CV_AMD64_YMM3I0: CV_HREG_e = CV_HREG_e(444i32);
pub const CV_AMD64_YMM3I1: CV_HREG_e = CV_HREG_e(445i32);
pub const CV_AMD64_YMM3I2: CV_HREG_e = CV_HREG_e(446i32);
pub const CV_AMD64_YMM3I3: CV_HREG_e = CV_HREG_e(447i32);
pub const CV_AMD64_YMM4I0: CV_HREG_e = CV_HREG_e(448i32);
pub const CV_AMD64_YMM4I1: CV_HREG_e = CV_HREG_e(449i32);
pub const CV_AMD64_YMM4I2: CV_HREG_e = CV_HREG_e(450i32);
pub const CV_AMD64_YMM4I3: CV_HREG_e = CV_HREG_e(451i32);
pub const CV_AMD64_YMM5I0: CV_HREG_e = CV_HREG_e(452i32);
pub const CV_AMD64_YMM5I1: CV_HREG_e = CV_HREG_e(453i32);
pub const CV_AMD64_YMM5I2: CV_HREG_e = CV_HREG_e(454i32);
pub const CV_AMD64_YMM5I3: CV_HREG_e = CV_HREG_e(455i32);
pub const CV_AMD64_YMM6I0: CV_HREG_e = CV_HREG_e(456i32);
pub const CV_AMD64_YMM6I1: CV_HREG_e = CV_HREG_e(457i32);
pub const CV_AMD64_YMM6I2: CV_HREG_e = CV_HREG_e(458i32);
pub const CV_AMD64_YMM6I3: CV_HREG_e = CV_HREG_e(459i32);
pub const CV_AMD64_YMM7I0: CV_HREG_e = CV_HREG_e(460i32);
pub const CV_AMD64_YMM7I1: CV_HREG_e = CV_HREG_e(461i32);
pub const CV_AMD64_YMM7I2: CV_HREG_e = CV_HREG_e(462i32);
pub const CV_AMD64_YMM7I3: CV_HREG_e = CV_HREG_e(463i32);
pub const CV_AMD64_YMM8I0: CV_HREG_e = CV_HREG_e(464i32);
pub const CV_AMD64_YMM8I1: CV_HREG_e = CV_HREG_e(465i32);
pub const CV_AMD64_YMM8I2: CV_HREG_e = CV_HREG_e(466i32);
pub const CV_AMD64_YMM8I3: CV_HREG_e = CV_HREG_e(467i32);
pub const CV_AMD64_YMM9I0: CV_HREG_e = CV_HREG_e(468i32);
pub const CV_AMD64_YMM9I1: CV_HREG_e = CV_HREG_e(469i32);
pub const CV_AMD64_YMM9I2: CV_HREG_e = CV_HREG_e(470i32);
pub const CV_AMD64_YMM9I3: CV_HREG_e = CV_HREG_e(471i32);
pub const CV_AMD64_YMM10I0: CV_HREG_e = CV_HREG_e(472i32);
pub const CV_AMD64_YMM10I1: CV_HREG_e = CV_HREG_e(473i32);
pub const CV_AMD64_YMM10I2: CV_HREG_e = CV_HREG_e(474i32);
pub const CV_AMD64_YMM10I3: CV_HREG_e = CV_HREG_e(475i32);
pub const CV_AMD64_YMM11I0: CV_HREG_e = CV_HREG_e(476i32);
pub const CV_AMD64_YMM11I1: CV_HREG_e = CV_HREG_e(477i32);
pub const CV_AMD64_YMM11I2: CV_HREG_e = CV_HREG_e(478i32);
pub const CV_AMD64_YMM11I3: CV_HREG_e = CV_HREG_e(479i32);
pub const CV_AMD64_YMM12I0: CV_HREG_e = CV_HREG_e(480i32);
pub const CV_AMD64_YMM12I1: CV_HREG_e = CV_HREG_e(481i32);
pub const CV_AMD64_YMM12I2: CV_HREG_e = CV_HREG_e(482i32);
pub const CV_AMD64_YMM12I3: CV_HREG_e = CV_HREG_e(483i32);
pub const CV_AMD64_YMM13I0: CV_HREG_e = CV_HREG_e(484i32);
pub const CV_AMD64_YMM13I1: CV_HREG_e = CV_HREG_e(485i32);
pub const CV_AMD64_YMM13I2: CV_HREG_e = CV_HREG_e(486i32);
pub const CV_AMD64_YMM13I3: CV_HREG_e = CV_HREG_e(487i32);
pub const CV_AMD64_YMM14I0: CV_HREG_e = CV_HREG_e(488i32);
pub const CV_AMD64_YMM14I1: CV_HREG_e = CV_HREG_e(489i32);
pub const CV_AMD64_YMM14I2: CV_HREG_e = CV_HREG_e(490i32);
pub const CV_AMD64_YMM14I3: CV_HREG_e = CV_HREG_e(491i32);
pub const CV_AMD64_YMM15I0: CV_HREG_e = CV_HREG_e(492i32);
pub const CV_AMD64_YMM15I1: CV_HREG_e = CV_HREG_e(493i32);
pub const CV_AMD64_YMM15I2: CV_HREG_e = CV_HREG_e(494i32);
pub const CV_AMD64_YMM15I3: CV_HREG_e = CV_HREG_e(495i32);
pub const CV_AMD64_YMM0F0: CV_HREG_e = CV_HREG_e(496i32);
pub const CV_AMD64_YMM0F1: CV_HREG_e = CV_HREG_e(497i32);
pub const CV_AMD64_YMM0F2: CV_HREG_e = CV_HREG_e(498i32);
pub const CV_AMD64_YMM0F3: CV_HREG_e = CV_HREG_e(499i32);
pub const CV_AMD64_YMM0F4: CV_HREG_e = CV_HREG_e(500i32);
pub const CV_AMD64_YMM0F5: CV_HREG_e = CV_HREG_e(501i32);
pub const CV_AMD64_YMM0F6: CV_HREG_e = CV_HREG_e(502i32);
pub const CV_AMD64_YMM0F7: CV_HREG_e = CV_HREG_e(503i32);
pub const CV_AMD64_YMM1F0: CV_HREG_e = CV_HREG_e(504i32);
pub const CV_AMD64_YMM1F1: CV_HREG_e = CV_HREG_e(505i32);
pub const CV_AMD64_YMM1F2: CV_HREG_e = CV_HREG_e(506i32);
pub const CV_AMD64_YMM1F3: CV_HREG_e = CV_HREG_e(507i32);
pub const CV_AMD64_YMM1F4: CV_HREG_e = CV_HREG_e(508i32);
pub const CV_AMD64_YMM1F5: CV_HREG_e = CV_HREG_e(509i32);
pub const CV_AMD64_YMM1F6: CV_HREG_e = CV_HREG_e(510i32);
pub const CV_AMD64_YMM1F7: CV_HREG_e = CV_HREG_e(511i32);
pub const CV_AMD64_YMM2F0: CV_HREG_e = CV_HREG_e(512i32);
pub const CV_AMD64_YMM2F1: CV_HREG_e = CV_HREG_e(513i32);
pub const CV_AMD64_YMM2F2: CV_HREG_e = CV_HREG_e(514i32);
pub const CV_AMD64_YMM2F3: CV_HREG_e = CV_HREG_e(515i32);
pub const CV_AMD64_YMM2F4: CV_HREG_e = CV_HREG_e(516i32);
pub const CV_AMD64_YMM2F5: CV_HREG_e = CV_HREG_e(517i32);
pub const CV_AMD64_YMM2F6: CV_HREG_e = CV_HREG_e(518i32);
pub const CV_AMD64_YMM2F7: CV_HREG_e = CV_HREG_e(519i32);
pub const CV_AMD64_YMM3F0: CV_HREG_e = CV_HREG_e(520i32);
pub const CV_AMD64_YMM3F1: CV_HREG_e = CV_HREG_e(521i32);
pub const CV_AMD64_YMM3F2: CV_HREG_e = CV_HREG_e(522i32);
pub const CV_AMD64_YMM3F3: CV_HREG_e = CV_HREG_e(523i32);
pub const CV_AMD64_YMM3F4: CV_HREG_e = CV_HREG_e(524i32);
pub const CV_AMD64_YMM3F5: CV_HREG_e = CV_HREG_e(525i32);
pub const CV_AMD64_YMM3F6: CV_HREG_e = CV_HREG_e(526i32);
pub const CV_AMD64_YMM3F7: CV_HREG_e = CV_HREG_e(527i32);
pub const CV_AMD64_YMM4F0: CV_HREG_e = CV_HREG_e(528i32);
pub const CV_AMD64_YMM4F1: CV_HREG_e = CV_HREG_e(529i32);
pub const CV_AMD64_YMM4F2: CV_HREG_e = CV_HREG_e(530i32);
pub const CV_AMD64_YMM4F3: CV_HREG_e = CV_HREG_e(531i32);
pub const CV_AMD64_YMM4F4: CV_HREG_e = CV_HREG_e(532i32);
pub const CV_AMD64_YMM4F5: CV_HREG_e = CV_HREG_e(533i32);
pub const CV_AMD64_YMM4F6: CV_HREG_e = CV_HREG_e(534i32);
pub const CV_AMD64_YMM4F7: CV_HREG_e = CV_HREG_e(535i32);
pub const CV_AMD64_YMM5F0: CV_HREG_e = CV_HREG_e(536i32);
pub const CV_AMD64_YMM5F1: CV_HREG_e = CV_HREG_e(537i32);
pub const CV_AMD64_YMM5F2: CV_HREG_e = CV_HREG_e(538i32);
pub const CV_AMD64_YMM5F3: CV_HREG_e = CV_HREG_e(539i32);
pub const CV_AMD64_YMM5F4: CV_HREG_e = CV_HREG_e(540i32);
pub const CV_AMD64_YMM5F5: CV_HREG_e = CV_HREG_e(541i32);
pub const CV_AMD64_YMM5F6: CV_HREG_e = CV_HREG_e(542i32);
pub const CV_AMD64_YMM5F7: CV_HREG_e = CV_HREG_e(543i32);
pub const CV_AMD64_YMM6F0: CV_HREG_e = CV_HREG_e(544i32);
pub const CV_AMD64_YMM6F1: CV_HREG_e = CV_HREG_e(545i32);
pub const CV_AMD64_YMM6F2: CV_HREG_e = CV_HREG_e(546i32);
pub const CV_AMD64_YMM6F3: CV_HREG_e = CV_HREG_e(547i32);
pub const CV_AMD64_YMM6F4: CV_HREG_e = CV_HREG_e(548i32);
pub const CV_AMD64_YMM6F5: CV_HREG_e = CV_HREG_e(549i32);
pub const CV_AMD64_YMM6F6: CV_HREG_e = CV_HREG_e(550i32);
pub const CV_AMD64_YMM6F7: CV_HREG_e = CV_HREG_e(551i32);
pub const CV_AMD64_YMM7F0: CV_HREG_e = CV_HREG_e(552i32);
pub const CV_AMD64_YMM7F1: CV_HREG_e = CV_HREG_e(553i32);
pub const CV_AMD64_YMM7F2: CV_HREG_e = CV_HREG_e(554i32);
pub const CV_AMD64_YMM7F3: CV_HREG_e = CV_HREG_e(555i32);
pub const CV_AMD64_YMM7F4: CV_HREG_e = CV_HREG_e(556i32);
pub const CV_AMD64_YMM7F5: CV_HREG_e = CV_HREG_e(557i32);
pub const CV_AMD64_YMM7F6: CV_HREG_e = CV_HREG_e(558i32);
pub const CV_AMD64_YMM7F7: CV_HREG_e = CV_HREG_e(559i32);
pub const CV_AMD64_YMM8F0: CV_HREG_e = CV_HREG_e(560i32);
pub const CV_AMD64_YMM8F1: CV_HREG_e = CV_HREG_e(561i32);
pub const CV_AMD64_YMM8F2: CV_HREG_e = CV_HREG_e(562i32);
pub const CV_AMD64_YMM8F3: CV_HREG_e = CV_HREG_e(563i32);
pub const CV_AMD64_YMM8F4: CV_HREG_e = CV_HREG_e(564i32);
pub const CV_AMD64_YMM8F5: CV_HREG_e = CV_HREG_e(565i32);
pub const CV_AMD64_YMM8F6: CV_HREG_e = CV_HREG_e(566i32);
pub const CV_AMD64_YMM8F7: CV_HREG_e = CV_HREG_e(567i32);
pub const CV_AMD64_YMM9F0: CV_HREG_e = CV_HREG_e(568i32);
pub const CV_AMD64_YMM9F1: CV_HREG_e = CV_HREG_e(569i32);
pub const CV_AMD64_YMM9F2: CV_HREG_e = CV_HREG_e(570i32);
pub const CV_AMD64_YMM9F3: CV_HREG_e = CV_HREG_e(571i32);
pub const CV_AMD64_YMM9F4: CV_HREG_e = CV_HREG_e(572i32);
pub const CV_AMD64_YMM9F5: CV_HREG_e = CV_HREG_e(573i32);
pub const CV_AMD64_YMM9F6: CV_HREG_e = CV_HREG_e(574i32);
pub const CV_AMD64_YMM9F7: CV_HREG_e = CV_HREG_e(575i32);
pub const CV_AMD64_YMM10F0: CV_HREG_e = CV_HREG_e(576i32);
pub const CV_AMD64_YMM10F1: CV_HREG_e = CV_HREG_e(577i32);
pub const CV_AMD64_YMM10F2: CV_HREG_e = CV_HREG_e(578i32);
pub const CV_AMD64_YMM10F3: CV_HREG_e = CV_HREG_e(579i32);
pub const CV_AMD64_YMM10F4: CV_HREG_e = CV_HREG_e(580i32);
pub const CV_AMD64_YMM10F5: CV_HREG_e = CV_HREG_e(581i32);
pub const CV_AMD64_YMM10F6: CV_HREG_e = CV_HREG_e(582i32);
pub const CV_AMD64_YMM10F7: CV_HREG_e = CV_HREG_e(583i32);
pub const CV_AMD64_YMM11F0: CV_HREG_e = CV_HREG_e(584i32);
pub const CV_AMD64_YMM11F1: CV_HREG_e = CV_HREG_e(585i32);
pub const CV_AMD64_YMM11F2: CV_HREG_e = CV_HREG_e(586i32);
pub const CV_AMD64_YMM11F3: CV_HREG_e = CV_HREG_e(587i32);
pub const CV_AMD64_YMM11F4: CV_HREG_e = CV_HREG_e(588i32);
pub const CV_AMD64_YMM11F5: CV_HREG_e = CV_HREG_e(589i32);
pub const CV_AMD64_YMM11F6: CV_HREG_e = CV_HREG_e(590i32);
pub const CV_AMD64_YMM11F7: CV_HREG_e = CV_HREG_e(591i32);
pub const CV_AMD64_YMM12F0: CV_HREG_e = CV_HREG_e(592i32);
pub const CV_AMD64_YMM12F1: CV_HREG_e = CV_HREG_e(593i32);
pub const CV_AMD64_YMM12F2: CV_HREG_e = CV_HREG_e(594i32);
pub const CV_AMD64_YMM12F3: CV_HREG_e = CV_HREG_e(595i32);
pub const CV_AMD64_YMM12F4: CV_HREG_e = CV_HREG_e(596i32);
pub const CV_AMD64_YMM12F5: CV_HREG_e = CV_HREG_e(597i32);
pub const CV_AMD64_YMM12F6: CV_HREG_e = CV_HREG_e(598i32);
pub const CV_AMD64_YMM12F7: CV_HREG_e = CV_HREG_e(599i32);
pub const CV_AMD64_YMM13F0: CV_HREG_e = CV_HREG_e(600i32);
pub const CV_AMD64_YMM13F1: CV_HREG_e = CV_HREG_e(601i32);
pub const CV_AMD64_YMM13F2: CV_HREG_e = CV_HREG_e(602i32);
pub const CV_AMD64_YMM13F3: CV_HREG_e = CV_HREG_e(603i32);
pub const CV_AMD64_YMM13F4: CV_HREG_e = CV_HREG_e(604i32);
pub const CV_AMD64_YMM13F5: CV_HREG_e = CV_HREG_e(605i32);
pub const CV_AMD64_YMM13F6: CV_HREG_e = CV_HREG_e(606i32);
pub const CV_AMD64_YMM13F7: CV_HREG_e = CV_HREG_e(607i32);
pub const CV_AMD64_YMM14F0: CV_HREG_e = CV_HREG_e(608i32);
pub const CV_AMD64_YMM14F1: CV_HREG_e = CV_HREG_e(609i32);
pub const CV_AMD64_YMM14F2: CV_HREG_e = CV_HREG_e(610i32);
pub const CV_AMD64_YMM14F3: CV_HREG_e = CV_HREG_e(611i32);
pub const CV_AMD64_YMM14F4: CV_HREG_e = CV_HREG_e(612i32);
pub const CV_AMD64_YMM14F5: CV_HREG_e = CV_HREG_e(613i32);
pub const CV_AMD64_YMM14F6: CV_HREG_e = CV_HREG_e(614i32);
pub const CV_AMD64_YMM14F7: CV_HREG_e = CV_HREG_e(615i32);
pub const CV_AMD64_YMM15F0: CV_HREG_e = CV_HREG_e(616i32);
pub const CV_AMD64_YMM15F1: CV_HREG_e = CV_HREG_e(617i32);
pub const CV_AMD64_YMM15F2: CV_HREG_e = CV_HREG_e(618i32);
pub const CV_AMD64_YMM15F3: CV_HREG_e = CV_HREG_e(619i32);
pub const CV_AMD64_YMM15F4: CV_HREG_e = CV_HREG_e(620i32);
pub const CV_AMD64_YMM15F5: CV_HREG_e = CV_HREG_e(621i32);
pub const CV_AMD64_YMM15F6: CV_HREG_e = CV_HREG_e(622i32);
pub const CV_AMD64_YMM15F7: CV_HREG_e = CV_HREG_e(623i32);
pub const CV_AMD64_YMM0D0: CV_HREG_e = CV_HREG_e(624i32);
pub const CV_AMD64_YMM0D1: CV_HREG_e = CV_HREG_e(625i32);
pub const CV_AMD64_YMM0D2: CV_HREG_e = CV_HREG_e(626i32);
pub const CV_AMD64_YMM0D3: CV_HREG_e = CV_HREG_e(627i32);
pub const CV_AMD64_YMM1D0: CV_HREG_e = CV_HREG_e(628i32);
pub const CV_AMD64_YMM1D1: CV_HREG_e = CV_HREG_e(629i32);
pub const CV_AMD64_YMM1D2: CV_HREG_e = CV_HREG_e(630i32);
pub const CV_AMD64_YMM1D3: CV_HREG_e = CV_HREG_e(631i32);
pub const CV_AMD64_YMM2D0: CV_HREG_e = CV_HREG_e(632i32);
pub const CV_AMD64_YMM2D1: CV_HREG_e = CV_HREG_e(633i32);
pub const CV_AMD64_YMM2D2: CV_HREG_e = CV_HREG_e(634i32);
pub const CV_AMD64_YMM2D3: CV_HREG_e = CV_HREG_e(635i32);
pub const CV_AMD64_YMM3D0: CV_HREG_e = CV_HREG_e(636i32);
pub const CV_AMD64_YMM3D1: CV_HREG_e = CV_HREG_e(637i32);
pub const CV_AMD64_YMM3D2: CV_HREG_e = CV_HREG_e(638i32);
pub const CV_AMD64_YMM3D3: CV_HREG_e = CV_HREG_e(639i32);
pub const CV_AMD64_YMM4D0: CV_HREG_e = CV_HREG_e(640i32);
pub const CV_AMD64_YMM4D1: CV_HREG_e = CV_HREG_e(641i32);
pub const CV_AMD64_YMM4D2: CV_HREG_e = CV_HREG_e(642i32);
pub const CV_AMD64_YMM4D3: CV_HREG_e = CV_HREG_e(643i32);
pub const CV_AMD64_YMM5D0: CV_HREG_e = CV_HREG_e(644i32);
pub const CV_AMD64_YMM5D1: CV_HREG_e = CV_HREG_e(645i32);
pub const CV_AMD64_YMM5D2: CV_HREG_e = CV_HREG_e(646i32);
pub const CV_AMD64_YMM5D3: CV_HREG_e = CV_HREG_e(647i32);
pub const CV_AMD64_YMM6D0: CV_HREG_e = CV_HREG_e(648i32);
pub const CV_AMD64_YMM6D1: CV_HREG_e = CV_HREG_e(649i32);
pub const CV_AMD64_YMM6D2: CV_HREG_e = CV_HREG_e(650i32);
pub const CV_AMD64_YMM6D3: CV_HREG_e = CV_HREG_e(651i32);
pub const CV_AMD64_YMM7D0: CV_HREG_e = CV_HREG_e(652i32);
pub const CV_AMD64_YMM7D1: CV_HREG_e = CV_HREG_e(653i32);
pub const CV_AMD64_YMM7D2: CV_HREG_e = CV_HREG_e(654i32);
pub const CV_AMD64_YMM7D3: CV_HREG_e = CV_HREG_e(655i32);
pub const CV_AMD64_YMM8D0: CV_HREG_e = CV_HREG_e(656i32);
pub const CV_AMD64_YMM8D1: CV_HREG_e = CV_HREG_e(657i32);
pub const CV_AMD64_YMM8D2: CV_HREG_e = CV_HREG_e(658i32);
pub const CV_AMD64_YMM8D3: CV_HREG_e = CV_HREG_e(659i32);
pub const CV_AMD64_YMM9D0: CV_HREG_e = CV_HREG_e(660i32);
pub const CV_AMD64_YMM9D1: CV_HREG_e = CV_HREG_e(661i32);
pub const CV_AMD64_YMM9D2: CV_HREG_e = CV_HREG_e(662i32);
pub const CV_AMD64_YMM9D3: CV_HREG_e = CV_HREG_e(663i32);
pub const CV_AMD64_YMM10D0: CV_HREG_e = CV_HREG_e(664i32);
pub const CV_AMD64_YMM10D1: CV_HREG_e = CV_HREG_e(665i32);
pub const CV_AMD64_YMM10D2: CV_HREG_e = CV_HREG_e(666i32);
pub const CV_AMD64_YMM10D3: CV_HREG_e = CV_HREG_e(667i32);
pub const CV_AMD64_YMM11D0: CV_HREG_e = CV_HREG_e(668i32);
pub const CV_AMD64_YMM11D1: CV_HREG_e = CV_HREG_e(669i32);
pub const CV_AMD64_YMM11D2: CV_HREG_e = CV_HREG_e(670i32);
pub const CV_AMD64_YMM11D3: CV_HREG_e = CV_HREG_e(671i32);
pub const CV_AMD64_YMM12D0: CV_HREG_e = CV_HREG_e(672i32);
pub const CV_AMD64_YMM12D1: CV_HREG_e = CV_HREG_e(673i32);
pub const CV_AMD64_YMM12D2: CV_HREG_e = CV_HREG_e(674i32);
pub const CV_AMD64_YMM12D3: CV_HREG_e = CV_HREG_e(675i32);
pub const CV_AMD64_YMM13D0: CV_HREG_e = CV_HREG_e(676i32);
pub const CV_AMD64_YMM13D1: CV_HREG_e = CV_HREG_e(677i32);
pub const CV_AMD64_YMM13D2: CV_HREG_e = CV_HREG_e(678i32);
pub const CV_AMD64_YMM13D3: CV_HREG_e = CV_HREG_e(679i32);
pub const CV_AMD64_YMM14D0: CV_HREG_e = CV_HREG_e(680i32);
pub const CV_AMD64_YMM14D1: CV_HREG_e = CV_HREG_e(681i32);
pub const CV_AMD64_YMM14D2: CV_HREG_e = CV_HREG_e(682i32);
pub const CV_AMD64_YMM14D3: CV_HREG_e = CV_HREG_e(683i32);
pub const CV_AMD64_YMM15D0: CV_HREG_e = CV_HREG_e(684i32);
pub const CV_AMD64_YMM15D1: CV_HREG_e = CV_HREG_e(685i32);
pub const CV_AMD64_YMM15D2: CV_HREG_e = CV_HREG_e(686i32);
pub const CV_AMD64_YMM15D3: CV_HREG_e = CV_HREG_e(687i32);
pub const CV_AMD64_BND0: CV_HREG_e = CV_HREG_e(688i32);
pub const CV_AMD64_BND1: CV_HREG_e = CV_HREG_e(689i32);
pub const CV_AMD64_BND2: CV_HREG_e = CV_HREG_e(690i32);
pub const CV_AMD64_BND3: CV_HREG_e = CV_HREG_e(691i32);
pub const CV_AMD64_BNDCFGU: CV_HREG_e = CV_HREG_e(692i32);
pub const CV_AMD64_BNDSTATUS: CV_HREG_e = CV_HREG_e(693i32);
pub const CV_AMD64_XMM16: CV_HREG_e = CV_HREG_e(694i32);
pub const CV_AMD64_XMM17: CV_HREG_e = CV_HREG_e(695i32);
pub const CV_AMD64_XMM18: CV_HREG_e = CV_HREG_e(696i32);
pub const CV_AMD64_XMM19: CV_HREG_e = CV_HREG_e(697i32);
pub const CV_AMD64_XMM20: CV_HREG_e = CV_HREG_e(698i32);
pub const CV_AMD64_XMM21: CV_HREG_e = CV_HREG_e(699i32);
pub const CV_AMD64_XMM22: CV_HREG_e = CV_HREG_e(700i32);
pub const CV_AMD64_XMM23: CV_HREG_e = CV_HREG_e(701i32);
pub const CV_AMD64_XMM24: CV_HREG_e = CV_HREG_e(702i32);
pub const CV_AMD64_XMM25: CV_HREG_e = CV_HREG_e(703i32);
pub const CV_AMD64_XMM26: CV_HREG_e = CV_HREG_e(704i32);
pub const CV_AMD64_XMM27: CV_HREG_e = CV_HREG_e(705i32);
pub const CV_AMD64_XMM28: CV_HREG_e = CV_HREG_e(706i32);
pub const CV_AMD64_XMM29: CV_HREG_e = CV_HREG_e(707i32);
pub const CV_AMD64_XMM30: CV_HREG_e = CV_HREG_e(708i32);
pub const CV_AMD64_XMM31: CV_HREG_e = CV_HREG_e(709i32);
pub const CV_AMD64_YMM16: CV_HREG_e = CV_HREG_e(710i32);
pub const CV_AMD64_YMM17: CV_HREG_e = CV_HREG_e(711i32);
pub const CV_AMD64_YMM18: CV_HREG_e = CV_HREG_e(712i32);
pub const CV_AMD64_YMM19: CV_HREG_e = CV_HREG_e(713i32);
pub const CV_AMD64_YMM20: CV_HREG_e = CV_HREG_e(714i32);
pub const CV_AMD64_YMM21: CV_HREG_e = CV_HREG_e(715i32);
pub const CV_AMD64_YMM22: CV_HREG_e = CV_HREG_e(716i32);
pub const CV_AMD64_YMM23: CV_HREG_e = CV_HREG_e(717i32);
pub const CV_AMD64_YMM24: CV_HREG_e = CV_HREG_e(718i32);
pub const CV_AMD64_YMM25: CV_HREG_e = CV_HREG_e(719i32);
pub const CV_AMD64_YMM26: CV_HREG_e = CV_HREG_e(720i32);
pub const CV_AMD64_YMM27: CV_HREG_e = CV_HREG_e(721i32);
pub const CV_AMD64_YMM28: CV_HREG_e = CV_HREG_e(722i32);
pub const CV_AMD64_YMM29: CV_HREG_e = CV_HREG_e(723i32);
pub const CV_AMD64_YMM30: CV_HREG_e = CV_HREG_e(724i32);
pub const CV_AMD64_YMM31: CV_HREG_e = CV_HREG_e(725i32);
pub const CV_AMD64_ZMM0: CV_HREG_e = CV_HREG_e(726i32);
pub const CV_AMD64_ZMM1: CV_HREG_e = CV_HREG_e(727i32);
pub const CV_AMD64_ZMM2: CV_HREG_e = CV_HREG_e(728i32);
pub const CV_AMD64_ZMM3: CV_HREG_e = CV_HREG_e(729i32);
pub const CV_AMD64_ZMM4: CV_HREG_e = CV_HREG_e(730i32);
pub const CV_AMD64_ZMM5: CV_HREG_e = CV_HREG_e(731i32);
pub const CV_AMD64_ZMM6: CV_HREG_e = CV_HREG_e(732i32);
pub const CV_AMD64_ZMM7: CV_HREG_e = CV_HREG_e(733i32);
pub const CV_AMD64_ZMM8: CV_HREG_e = CV_HREG_e(734i32);
pub const CV_AMD64_ZMM9: CV_HREG_e = CV_HREG_e(735i32);
pub const CV_AMD64_ZMM10: CV_HREG_e = CV_HREG_e(736i32);
pub const CV_AMD64_ZMM11: CV_HREG_e = CV_HREG_e(737i32);
pub const CV_AMD64_ZMM12: CV_HREG_e = CV_HREG_e(738i32);
pub const CV_AMD64_ZMM13: CV_HREG_e = CV_HREG_e(739i32);
pub const CV_AMD64_ZMM14: CV_HREG_e = CV_HREG_e(740i32);
pub const CV_AMD64_ZMM15: CV_HREG_e = CV_HREG_e(741i32);
pub const CV_AMD64_ZMM16: CV_HREG_e = CV_HREG_e(742i32);
pub const CV_AMD64_ZMM17: CV_HREG_e = CV_HREG_e(743i32);
pub const CV_AMD64_ZMM18: CV_HREG_e = CV_HREG_e(744i32);
pub const CV_AMD64_ZMM19: CV_HREG_e = CV_HREG_e(745i32);
pub const CV_AMD64_ZMM20: CV_HREG_e = CV_HREG_e(746i32);
pub const CV_AMD64_ZMM21: CV_HREG_e = CV_HREG_e(747i32);
pub const CV_AMD64_ZMM22: CV_HREG_e = CV_HREG_e(748i32);
pub const CV_AMD64_ZMM23: CV_HREG_e = CV_HREG_e(749i32);
pub const CV_AMD64_ZMM24: CV_HREG_e = CV_HREG_e(750i32);
pub const CV_AMD64_ZMM25: CV_HREG_e = CV_HREG_e(751i32);
pub const CV_AMD64_ZMM26: CV_HREG_e = CV_HREG_e(752i32);
pub const CV_AMD64_ZMM27: CV_HREG_e = CV_HREG_e(753i32);
pub const CV_AMD64_ZMM28: CV_HREG_e = CV_HREG_e(754i32);
pub const CV_AMD64_ZMM29: CV_HREG_e = CV_HREG_e(755i32);
pub const CV_AMD64_ZMM30: CV_HREG_e = CV_HREG_e(756i32);
pub const CV_AMD64_ZMM31: CV_HREG_e = CV_HREG_e(757i32);
pub const CV_AMD64_K0: CV_HREG_e = CV_HREG_e(758i32);
pub const CV_AMD64_K1: CV_HREG_e = CV_HREG_e(759i32);
pub const CV_AMD64_K2: CV_HREG_e = CV_HREG_e(760i32);
pub const CV_AMD64_K3: CV_HREG_e = CV_HREG_e(761i32);
pub const CV_AMD64_K4: CV_HREG_e = CV_HREG_e(762i32);
pub const CV_AMD64_K5: CV_HREG_e = CV_HREG_e(763i32);
pub const CV_AMD64_K6: CV_HREG_e = CV_HREG_e(764i32);
pub const CV_AMD64_K7: CV_HREG_e = CV_HREG_e(765i32);
pub const CV_AMD64_ZMM0H: CV_HREG_e = CV_HREG_e(766i32);
pub const CV_AMD64_ZMM1H: CV_HREG_e = CV_HREG_e(767i32);
pub const CV_AMD64_ZMM2H: CV_HREG_e = CV_HREG_e(768i32);
pub const CV_AMD64_ZMM3H: CV_HREG_e = CV_HREG_e(769i32);
pub const CV_AMD64_ZMM4H: CV_HREG_e = CV_HREG_e(770i32);
pub const CV_AMD64_ZMM5H: CV_HREG_e = CV_HREG_e(771i32);
pub const CV_AMD64_ZMM6H: CV_HREG_e = CV_HREG_e(772i32);
pub const CV_AMD64_ZMM7H: CV_HREG_e = CV_HREG_e(773i32);
pub const CV_AMD64_ZMM8H: CV_HREG_e = CV_HREG_e(774i32);
pub const CV_AMD64_ZMM9H: CV_HREG_e = CV_HREG_e(775i32);
pub const CV_AMD64_ZMM10H: CV_HREG_e = CV_HREG_e(776i32);
pub const CV_AMD64_ZMM11H: CV_HREG_e = CV_HREG_e(777i32);
pub const CV_AMD64_ZMM12H: CV_HREG_e = CV_HREG_e(778i32);
pub const CV_AMD64_ZMM13H: CV_HREG_e = CV_HREG_e(779i32);
pub const CV_AMD64_ZMM14H: CV_HREG_e = CV_HREG_e(780i32);
pub const CV_AMD64_ZMM15H: CV_HREG_e = CV_HREG_e(781i32);
pub const CV_AMD64_XMM16L: CV_HREG_e = CV_HREG_e(782i32);
pub const CV_AMD64_XMM17L: CV_HREG_e = CV_HREG_e(783i32);
pub const CV_AMD64_XMM18L: CV_HREG_e = CV_HREG_e(784i32);
pub const CV_AMD64_XMM19L: CV_HREG_e = CV_HREG_e(785i32);
pub const CV_AMD64_XMM20L: CV_HREG_e = CV_HREG_e(786i32);
pub const CV_AMD64_XMM21L: CV_HREG_e = CV_HREG_e(787i32);
pub const CV_AMD64_XMM22L: CV_HREG_e = CV_HREG_e(788i32);
pub const CV_AMD64_XMM23L: CV_HREG_e = CV_HREG_e(789i32);
pub const CV_AMD64_XMM24L: CV_HREG_e = CV_HREG_e(790i32);
pub const CV_AMD64_XMM25L: CV_HREG_e = CV_HREG_e(791i32);
pub const CV_AMD64_XMM26L: CV_HREG_e = CV_HREG_e(792i32);
pub const CV_AMD64_XMM27L: CV_HREG_e = CV_HREG_e(793i32);
pub const CV_AMD64_XMM28L: CV_HREG_e = CV_HREG_e(794i32);
pub const CV_AMD64_XMM29L: CV_HREG_e = CV_HREG_e(795i32);
pub const CV_AMD64_XMM30L: CV_HREG_e = CV_HREG_e(796i32);
pub const CV_AMD64_XMM31L: CV_HREG_e = CV_HREG_e(797i32);
pub const CV_AMD64_XMM16_0: CV_HREG_e = CV_HREG_e(798i32);
pub const CV_AMD64_XMM17_0: CV_HREG_e = CV_HREG_e(799i32);
pub const CV_AMD64_XMM18_0: CV_HREG_e = CV_HREG_e(800i32);
pub const CV_AMD64_XMM19_0: CV_HREG_e = CV_HREG_e(801i32);
pub const CV_AMD64_XMM20_0: CV_HREG_e = CV_HREG_e(802i32);
pub const CV_AMD64_XMM21_0: CV_HREG_e = CV_HREG_e(803i32);
pub const CV_AMD64_XMM22_0: CV_HREG_e = CV_HREG_e(804i32);
pub const CV_AMD64_XMM23_0: CV_HREG_e = CV_HREG_e(805i32);
pub const CV_AMD64_XMM24_0: CV_HREG_e = CV_HREG_e(806i32);
pub const CV_AMD64_XMM25_0: CV_HREG_e = CV_HREG_e(807i32);
pub const CV_AMD64_XMM26_0: CV_HREG_e = CV_HREG_e(808i32);
pub const CV_AMD64_XMM27_0: CV_HREG_e = CV_HREG_e(809i32);
pub const CV_AMD64_XMM28_0: CV_HREG_e = CV_HREG_e(810i32);
pub const CV_AMD64_XMM29_0: CV_HREG_e = CV_HREG_e(811i32);
pub const CV_AMD64_XMM30_0: CV_HREG_e = CV_HREG_e(812i32);
pub const CV_AMD64_XMM31_0: CV_HREG_e = CV_HREG_e(813i32);
pub const CV_AMD64_XMM16H: CV_HREG_e = CV_HREG_e(814i32);
pub const CV_AMD64_XMM17H: CV_HREG_e = CV_HREG_e(815i32);
pub const CV_AMD64_XMM18H: CV_HREG_e = CV_HREG_e(816i32);
pub const CV_AMD64_XMM19H: CV_HREG_e = CV_HREG_e(817i32);
pub const CV_AMD64_XMM20H: CV_HREG_e = CV_HREG_e(818i32);
pub const CV_AMD64_XMM21H: CV_HREG_e = CV_HREG_e(819i32);
pub const CV_AMD64_XMM22H: CV_HREG_e = CV_HREG_e(820i32);
pub const CV_AMD64_XMM23H: CV_HREG_e = CV_HREG_e(821i32);
pub const CV_AMD64_XMM24H: CV_HREG_e = CV_HREG_e(822i32);
pub const CV_AMD64_XMM25H: CV_HREG_e = CV_HREG_e(823i32);
pub const CV_AMD64_XMM26H: CV_HREG_e = CV_HREG_e(824i32);
pub const CV_AMD64_XMM27H: CV_HREG_e = CV_HREG_e(825i32);
pub const CV_AMD64_XMM28H: CV_HREG_e = CV_HREG_e(826i32);
pub const CV_AMD64_XMM29H: CV_HREG_e = CV_HREG_e(827i32);
pub const CV_AMD64_XMM30H: CV_HREG_e = CV_HREG_e(828i32);
pub const CV_AMD64_XMM31H: CV_HREG_e = CV_HREG_e(829i32);
pub const CV_AMD64_EMM16H: CV_HREG_e = CV_HREG_e(830i32);
pub const CV_AMD64_EMM17H: CV_HREG_e = CV_HREG_e(831i32);
pub const CV_AMD64_EMM18H: CV_HREG_e = CV_HREG_e(832i32);
pub const CV_AMD64_EMM19H: CV_HREG_e = CV_HREG_e(833i32);
pub const CV_AMD64_EMM20H: CV_HREG_e = CV_HREG_e(834i32);
pub const CV_AMD64_EMM21H: CV_HREG_e = CV_HREG_e(835i32);
pub const CV_AMD64_EMM22H: CV_HREG_e = CV_HREG_e(836i32);
pub const CV_AMD64_EMM23H: CV_HREG_e = CV_HREG_e(837i32);
pub const CV_AMD64_EMM24H: CV_HREG_e = CV_HREG_e(838i32);
pub const CV_AMD64_EMM25H: CV_HREG_e = CV_HREG_e(839i32);
pub const CV_AMD64_EMM26H: CV_HREG_e = CV_HREG_e(840i32);
pub const CV_AMD64_EMM27H: CV_HREG_e = CV_HREG_e(841i32);
pub const CV_AMD64_EMM28H: CV_HREG_e = CV_HREG_e(842i32);
pub const CV_AMD64_EMM29H: CV_HREG_e = CV_HREG_e(843i32);
pub const CV_AMD64_EMM30H: CV_HREG_e = CV_HREG_e(844i32);
pub const CV_AMD64_EMM31H: CV_HREG_e = CV_HREG_e(845i32);
pub const CV_AMD64_SSP: CV_HREG_e = CV_HREG_e(846i32);
pub const CV_AMD64_TMM0: CV_HREG_e = CV_HREG_e(847i32);
pub const CV_AMD64_TMM1: CV_HREG_e = CV_HREG_e(848i32);
pub const CV_AMD64_TMM2: CV_HREG_e = CV_HREG_e(849i32);
pub const CV_AMD64_TMM3: CV_HREG_e = CV_HREG_e(850i32);
pub const CV_AMD64_TMM4: CV_HREG_e = CV_HREG_e(851i32);
pub const CV_AMD64_TMM5: CV_HREG_e = CV_HREG_e(852i32);
pub const CV_AMD64_TMM6: CV_HREG_e = CV_HREG_e(853i32);
pub const CV_AMD64_TMM7: CV_HREG_e = CV_HREG_e(854i32);
pub const CV_AMD64_TILECFG: CV_HREG_e = CV_HREG_e(855i32);
impl ::core::marker::Copy for CV_HREG_e {}
impl ::core::clone::Clone for CV_HREG_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_HREG_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_HREG_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_HREG_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_HREG_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_SourceChksum_t(pub i32);
pub const CHKSUM_TYPE_NONE: CV_SourceChksum_t = CV_SourceChksum_t(0i32);
pub const CHKSUM_TYPE_MD5: CV_SourceChksum_t = CV_SourceChksum_t(1i32);
pub const CHKSUM_TYPE_SHA1: CV_SourceChksum_t = CV_SourceChksum_t(2i32);
pub const CHKSUM_TYPE_SHA_256: CV_SourceChksum_t = CV_SourceChksum_t(3i32);
impl ::core::marker::Copy for CV_SourceChksum_t {}
impl ::core::clone::Clone for CV_SourceChksum_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_SourceChksum_t {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_SourceChksum_t {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_SourceChksum_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_SourceChksum_t").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_access_e(pub i32);
pub const CV_private: CV_access_e = CV_access_e(1i32);
pub const CV_protected: CV_access_e = CV_access_e(2i32);
pub const CV_public: CV_access_e = CV_access_e(3i32);
impl ::core::marker::Copy for CV_access_e {}
impl ::core::clone::Clone for CV_access_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_access_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_access_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_access_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_access_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_builtin_e(pub i32);
pub const CV_BI_INVALID: CV_builtin_e = CV_builtin_e(0i32);
pub const CV_BI_HLSL_INTERFACE_POINTER: CV_builtin_e = CV_builtin_e(512i32);
pub const CV_BI_HLSL_TEXTURE1D: CV_builtin_e = CV_builtin_e(513i32);
pub const CV_BI_HLSL_TEXTURE1D_ARRAY: CV_builtin_e = CV_builtin_e(514i32);
pub const CV_BI_HLSL_TEXTURE2D: CV_builtin_e = CV_builtin_e(515i32);
pub const CV_BI_HLSL_TEXTURE2D_ARRAY: CV_builtin_e = CV_builtin_e(516i32);
pub const CV_BI_HLSL_TEXTURE3D: CV_builtin_e = CV_builtin_e(517i32);
pub const CV_BI_HLSL_TEXTURECUBE: CV_builtin_e = CV_builtin_e(518i32);
pub const CV_BI_HLSL_TEXTURECUBE_ARRAY: CV_builtin_e = CV_builtin_e(519i32);
pub const CV_BI_HLSL_TEXTURE2DMS: CV_builtin_e = CV_builtin_e(520i32);
pub const CV_BI_HLSL_TEXTURE2DMS_ARRAY: CV_builtin_e = CV_builtin_e(521i32);
pub const CV_BI_HLSL_SAMPLER: CV_builtin_e = CV_builtin_e(522i32);
pub const CV_BI_HLSL_SAMPLERCOMPARISON: CV_builtin_e = CV_builtin_e(523i32);
pub const CV_BI_HLSL_BUFFER: CV_builtin_e = CV_builtin_e(524i32);
pub const CV_BI_HLSL_POINTSTREAM: CV_builtin_e = CV_builtin_e(525i32);
pub const CV_BI_HLSL_LINESTREAM: CV_builtin_e = CV_builtin_e(526i32);
pub const CV_BI_HLSL_TRIANGLESTREAM: CV_builtin_e = CV_builtin_e(527i32);
pub const CV_BI_HLSL_INPUTPATCH: CV_builtin_e = CV_builtin_e(528i32);
pub const CV_BI_HLSL_OUTPUTPATCH: CV_builtin_e = CV_builtin_e(529i32);
pub const CV_BI_HLSL_RWTEXTURE1D: CV_builtin_e = CV_builtin_e(530i32);
pub const CV_BI_HLSL_RWTEXTURE1D_ARRAY: CV_builtin_e = CV_builtin_e(531i32);
pub const CV_BI_HLSL_RWTEXTURE2D: CV_builtin_e = CV_builtin_e(532i32);
pub const CV_BI_HLSL_RWTEXTURE2D_ARRAY: CV_builtin_e = CV_builtin_e(533i32);
pub const CV_BI_HLSL_RWTEXTURE3D: CV_builtin_e = CV_builtin_e(534i32);
pub const CV_BI_HLSL_RWBUFFER: CV_builtin_e = CV_builtin_e(535i32);
pub const CV_BI_HLSL_BYTEADDRESS_BUFFER: CV_builtin_e = CV_builtin_e(536i32);
pub const CV_BI_HLSL_RWBYTEADDRESS_BUFFER: CV_builtin_e = CV_builtin_e(537i32);
pub const CV_BI_HLSL_STRUCTURED_BUFFER: CV_builtin_e = CV_builtin_e(538i32);
pub const CV_BI_HLSL_RWSTRUCTURED_BUFFER: CV_builtin_e = CV_builtin_e(539i32);
pub const CV_BI_HLSL_APPEND_STRUCTURED_BUFFER: CV_builtin_e = CV_builtin_e(540i32);
pub const CV_BI_HLSL_CONSUME_STRUCTURED_BUFFER: CV_builtin_e = CV_builtin_e(541i32);
pub const CV_BI_HLSL_MIN8FLOAT: CV_builtin_e = CV_builtin_e(542i32);
pub const CV_BI_HLSL_MIN10FLOAT: CV_builtin_e = CV_builtin_e(543i32);
pub const CV_BI_HLSL_MIN16FLOAT: CV_builtin_e = CV_builtin_e(544i32);
pub const CV_BI_HLSL_MIN12INT: CV_builtin_e = CV_builtin_e(545i32);
pub const CV_BI_HLSL_MIN16INT: CV_builtin_e = CV_builtin_e(546i32);
pub const CV_BI_HLSL_MIN16UINT: CV_builtin_e = CV_builtin_e(547i32);
pub const CV_BI_HLSL_CONSTANT_BUFFER: CV_builtin_e = CV_builtin_e(548i32);
impl ::core::marker::Copy for CV_builtin_e {}
impl ::core::clone::Clone for CV_builtin_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_builtin_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_builtin_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_builtin_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_builtin_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_call_e(pub i32);
pub const CV_CALL_NEAR_C: CV_call_e = CV_call_e(0i32);
pub const CV_CALL_FAR_C: CV_call_e = CV_call_e(1i32);
pub const CV_CALL_NEAR_PASCAL: CV_call_e = CV_call_e(2i32);
pub const CV_CALL_FAR_PASCAL: CV_call_e = CV_call_e(3i32);
pub const CV_CALL_NEAR_FAST: CV_call_e = CV_call_e(4i32);
pub const CV_CALL_FAR_FAST: CV_call_e = CV_call_e(5i32);
pub const CV_CALL_SKIPPED: CV_call_e = CV_call_e(6i32);
pub const CV_CALL_NEAR_STD: CV_call_e = CV_call_e(7i32);
pub const CV_CALL_FAR_STD: CV_call_e = CV_call_e(8i32);
pub const CV_CALL_NEAR_SYS: CV_call_e = CV_call_e(9i32);
pub const CV_CALL_FAR_SYS: CV_call_e = CV_call_e(10i32);
pub const CV_CALL_THISCALL: CV_call_e = CV_call_e(11i32);
pub const CV_CALL_MIPSCALL: CV_call_e = CV_call_e(12i32);
pub const CV_CALL_GENERIC: CV_call_e = CV_call_e(13i32);
pub const CV_CALL_ALPHACALL: CV_call_e = CV_call_e(14i32);
pub const CV_CALL_PPCCALL: CV_call_e = CV_call_e(15i32);
pub const CV_CALL_SHCALL: CV_call_e = CV_call_e(16i32);
pub const CV_CALL_ARMCALL: CV_call_e = CV_call_e(17i32);
pub const CV_CALL_AM33CALL: CV_call_e = CV_call_e(18i32);
pub const CV_CALL_TRICALL: CV_call_e = CV_call_e(19i32);
pub const CV_CALL_SH5CALL: CV_call_e = CV_call_e(20i32);
pub const CV_CALL_M32RCALL: CV_call_e = CV_call_e(21i32);
pub const CV_CALL_CLRCALL: CV_call_e = CV_call_e(22i32);
pub const CV_CALL_INLINE: CV_call_e = CV_call_e(23i32);
pub const CV_CALL_NEAR_VECTOR: CV_call_e = CV_call_e(24i32);
pub const CV_CALL_SWIFT: CV_call_e = CV_call_e(25i32);
pub const CV_CALL_RESERVED: CV_call_e = CV_call_e(32i32);
impl ::core::marker::Copy for CV_call_e {}
impl ::core::clone::Clone for CV_call_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_call_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_call_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_call_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_call_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CV_modifier_e(pub i32);
pub const CV_MOD_INVALID: CV_modifier_e = CV_modifier_e(0i32);
pub const CV_MOD_CONST: CV_modifier_e = CV_modifier_e(1i32);
pub const CV_MOD_VOLATILE: CV_modifier_e = CV_modifier_e(2i32);
pub const CV_MOD_UNALIGNED: CV_modifier_e = CV_modifier_e(3i32);
pub const CV_MOD_HLSL_UNIFORM: CV_modifier_e = CV_modifier_e(512i32);
pub const CV_MOD_HLSL_LINE: CV_modifier_e = CV_modifier_e(513i32);
pub const CV_MOD_HLSL_TRIANGLE: CV_modifier_e = CV_modifier_e(514i32);
pub const CV_MOD_HLSL_LINEADJ: CV_modifier_e = CV_modifier_e(515i32);
pub const CV_MOD_HLSL_TRIANGLEADJ: CV_modifier_e = CV_modifier_e(516i32);
pub const CV_MOD_HLSL_LINEAR: CV_modifier_e = CV_modifier_e(517i32);
pub const CV_MOD_HLSL_CENTROID: CV_modifier_e = CV_modifier_e(518i32);
pub const CV_MOD_HLSL_CONSTINTERP: CV_modifier_e = CV_modifier_e(519i32);
pub const CV_MOD_HLSL_NOPERSPECTIVE: CV_modifier_e = CV_modifier_e(520i32);
pub const CV_MOD_HLSL_SAMPLE: CV_modifier_e = CV_modifier_e(521i32);
pub const CV_MOD_HLSL_CENTER: CV_modifier_e = CV_modifier_e(522i32);
pub const CV_MOD_HLSL_SNORM: CV_modifier_e = CV_modifier_e(523i32);
pub const CV_MOD_HLSL_UNORM: CV_modifier_e = CV_modifier_e(524i32);
pub const CV_MOD_HLSL_PRECISE: CV_modifier_e = CV_modifier_e(525i32);
pub const CV_MOD_HLSL_UAV_GLOBALLY_COHERENT: CV_modifier_e = CV_modifier_e(526i32);
impl ::core::marker::Copy for CV_modifier_e {}
impl ::core::clone::Clone for CV_modifier_e {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CV_modifier_e {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for CV_modifier_e {
    type Abi = Self;
}
impl ::core::fmt::Debug for CV_modifier_e {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CV_modifier_e").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DataKind(pub i32);
pub const DataIsUnknown: DataKind = DataKind(0i32);
pub const DataIsLocal: DataKind = DataKind(1i32);
pub const DataIsStaticLocal: DataKind = DataKind(2i32);
pub const DataIsParam: DataKind = DataKind(3i32);
pub const DataIsObjectPtr: DataKind = DataKind(4i32);
pub const DataIsFileStatic: DataKind = DataKind(5i32);
pub const DataIsGlobal: DataKind = DataKind(6i32);
pub const DataIsMember: DataKind = DataKind(7i32);
pub const DataIsStaticMember: DataKind = DataKind(8i32);
pub const DataIsConstant: DataKind = DataKind(9i32);
impl ::core::marker::Copy for DataKind {}
impl ::core::clone::Clone for DataKind {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DataKind {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for DataKind {
    type Abi = Self;
}
impl ::core::fmt::Debug for DataKind {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DataKind").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct LocationType(pub i32);
pub const LocIsNull: LocationType = LocationType(0i32);
pub const LocIsStatic: LocationType = LocationType(1i32);
pub const LocIsTLS: LocationType = LocationType(2i32);
pub const LocIsRegRel: LocationType = LocationType(3i32);
pub const LocIsThisRel: LocationType = LocationType(4i32);
pub const LocIsEnregistered: LocationType = LocationType(5i32);
pub const LocIsBitField: LocationType = LocationType(6i32);
pub const LocIsSlot: LocationType = LocationType(7i32);
pub const LocIsIlRel: LocationType = LocationType(8i32);
pub const LocInMetaData: LocationType = LocationType(9i32);
pub const LocIsConstant: LocationType = LocationType(10i32);
pub const LocIsRegRelAliasIndir: LocationType = LocationType(11i32);
pub const LocTypeMax: LocationType = LocationType(12i32);
impl ::core::marker::Copy for LocationType {}
impl ::core::clone::Clone for LocationType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for LocationType {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for LocationType {
    type Abi = Self;
}
impl ::core::fmt::Debug for LocationType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LocationType").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MemoryTypeEnum(pub i32);
pub const MemTypeCode: MemoryTypeEnum = MemoryTypeEnum(0i32);
pub const MemTypeData: MemoryTypeEnum = MemoryTypeEnum(1i32);
pub const MemTypeStack: MemoryTypeEnum = MemoryTypeEnum(2i32);
pub const MemTypeCodeOnHeap: MemoryTypeEnum = MemoryTypeEnum(3i32);
pub const MemTypeAny: MemoryTypeEnum = MemoryTypeEnum(-1i32);
impl ::core::marker::Copy for MemoryTypeEnum {}
impl ::core::clone::Clone for MemoryTypeEnum {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MemoryTypeEnum {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for MemoryTypeEnum {
    type Abi = Self;
}
impl ::core::fmt::Debug for MemoryTypeEnum {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MemoryTypeEnum").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct NameSearchOptions(pub i32);
pub const nsNone: NameSearchOptions = NameSearchOptions(0i32);
pub const nsfCaseSensitive: NameSearchOptions = NameSearchOptions(1i32);
pub const nsfCaseInsensitive: NameSearchOptions = NameSearchOptions(2i32);
pub const nsfFNameExt: NameSearchOptions = NameSearchOptions(4i32);
pub const nsfRegularExpression: NameSearchOptions = NameSearchOptions(8i32);
pub const nsfUndecoratedName: NameSearchOptions = NameSearchOptions(16i32);
pub const nsCaseSensitive: NameSearchOptions = NameSearchOptions(1i32);
pub const nsCaseInsensitive: NameSearchOptions = NameSearchOptions(2i32);
pub const nsFNameExt: NameSearchOptions = NameSearchOptions(6i32);
pub const nsRegularExpression: NameSearchOptions = NameSearchOptions(9i32);
pub const nsCaseInRegularExpression: NameSearchOptions = NameSearchOptions(10i32);
impl ::core::marker::Copy for NameSearchOptions {}
impl ::core::clone::Clone for NameSearchOptions {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NameSearchOptions {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for NameSearchOptions {
    type Abi = Self;
}
impl ::core::fmt::Debug for NameSearchOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NameSearchOptions").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct StackFrameTypeEnum(pub i32);
pub const FrameTypeFPO: StackFrameTypeEnum = StackFrameTypeEnum(0i32);
pub const FrameTypeTrap: StackFrameTypeEnum = StackFrameTypeEnum(1i32);
pub const FrameTypeTSS: StackFrameTypeEnum = StackFrameTypeEnum(2i32);
pub const FrameTypeStandard: StackFrameTypeEnum = StackFrameTypeEnum(3i32);
pub const FrameTypeFrameData: StackFrameTypeEnum = StackFrameTypeEnum(4i32);
pub const FrameTypeUnknown: StackFrameTypeEnum = StackFrameTypeEnum(-1i32);
impl ::core::marker::Copy for StackFrameTypeEnum {}
impl ::core::clone::Clone for StackFrameTypeEnum {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for StackFrameTypeEnum {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for StackFrameTypeEnum {
    type Abi = Self;
}
impl ::core::fmt::Debug for StackFrameTypeEnum {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("StackFrameTypeEnum").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SymTag(pub i32);
pub const SymTagNull: SymTag = SymTag(0i32);
pub const SymTagExe: SymTag = SymTag(1i32);
pub const SymTagCompiland: SymTag = SymTag(2i32);
pub const SymTagCompilandDetails: SymTag = SymTag(3i32);
pub const SymTagCompilandEnv: SymTag = SymTag(4i32);
pub const SymTagFunction: SymTag = SymTag(5i32);
pub const SymTagBlock: SymTag = SymTag(6i32);
pub const SymTagData: SymTag = SymTag(7i32);
pub const SymTagAnnotation: SymTag = SymTag(8i32);
pub const SymTagLabel: SymTag = SymTag(9i32);
pub const SymTagPublicSymbol: SymTag = SymTag(10i32);
pub const SymTagUDT: SymTag = SymTag(11i32);
pub const SymTagEnum: SymTag = SymTag(12i32);
pub const SymTagFunctionType: SymTag = SymTag(13i32);
pub const SymTagPointerType: SymTag = SymTag(14i32);
pub const SymTagArrayType: SymTag = SymTag(15i32);
pub const SymTagBaseType: SymTag = SymTag(16i32);
pub const SymTagTypedef: SymTag = SymTag(17i32);
pub const SymTagBaseClass: SymTag = SymTag(18i32);
pub const SymTagFriend: SymTag = SymTag(19i32);
pub const SymTagFunctionArgType: SymTag = SymTag(20i32);
pub const SymTagFuncDebugStart: SymTag = SymTag(21i32);
pub const SymTagFuncDebugEnd: SymTag = SymTag(22i32);
pub const SymTagUsingNamespace: SymTag = SymTag(23i32);
pub const SymTagVTableShape: SymTag = SymTag(24i32);
pub const SymTagVTable: SymTag = SymTag(25i32);
pub const SymTagCustom: SymTag = SymTag(26i32);
pub const SymTagThunk: SymTag = SymTag(27i32);
pub const SymTagCustomType: SymTag = SymTag(28i32);
pub const SymTagManagedType: SymTag = SymTag(29i32);
pub const SymTagDimension: SymTag = SymTag(30i32);
pub const SymTagCallSite: SymTag = SymTag(31i32);
pub const SymTagInlineSite: SymTag = SymTag(32i32);
pub const SymTagBaseInterface: SymTag = SymTag(33i32);
pub const SymTagVectorType: SymTag = SymTag(34i32);
pub const SymTagMatrixType: SymTag = SymTag(35i32);
pub const SymTagHLSLType: SymTag = SymTag(36i32);
pub const SymTagCaller: SymTag = SymTag(37i32);
pub const SymTagCallee: SymTag = SymTag(38i32);
pub const SymTagExport: SymTag = SymTag(39i32);
pub const SymTagHeapAllocationSite: SymTag = SymTag(40i32);
pub const SymTagCoffGroup: SymTag = SymTag(41i32);
pub const SymTagInlinee: SymTag = SymTag(42i32);
pub const SymTagMax: SymTag = SymTag(43i32);
impl ::core::marker::Copy for SymTag {}
impl ::core::clone::Clone for SymTag {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SymTag {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for SymTag {
    type Abi = Self;
}
impl ::core::fmt::Debug for SymTag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SymTag").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct THUNK_ORDINAL(pub i32);
pub const THUNK_ORDINAL_NOTYPE: THUNK_ORDINAL = THUNK_ORDINAL(0i32);
pub const THUNK_ORDINAL_ADJUSTOR: THUNK_ORDINAL = THUNK_ORDINAL(1i32);
pub const THUNK_ORDINAL_VCALL: THUNK_ORDINAL = THUNK_ORDINAL(2i32);
pub const THUNK_ORDINAL_PCODE: THUNK_ORDINAL = THUNK_ORDINAL(3i32);
pub const THUNK_ORDINAL_LOAD: THUNK_ORDINAL = THUNK_ORDINAL(4i32);
pub const THUNK_ORDINAL_TRAMP_INCREMENTAL: THUNK_ORDINAL = THUNK_ORDINAL(5i32);
pub const THUNK_ORDINAL_TRAMP_BRANCHISLAND: THUNK_ORDINAL = THUNK_ORDINAL(6i32);
pub const THUNK_ORDINAL_TRAMP_STRICTICF: THUNK_ORDINAL = THUNK_ORDINAL(7i32);
pub const THUNK_ORDINAL_TRAMP_ARM64XSAMEADDRESS: THUNK_ORDINAL = THUNK_ORDINAL(8i32);
pub const THUNK_ORDINAL_TRAMP_FUNCOVERRIDING: THUNK_ORDINAL = THUNK_ORDINAL(9i32);
impl ::core::marker::Copy for THUNK_ORDINAL {}
impl ::core::clone::Clone for THUNK_ORDINAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for THUNK_ORDINAL {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for THUNK_ORDINAL {
    type Abi = Self;
}
impl ::core::fmt::Debug for THUNK_ORDINAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("THUNK_ORDINAL").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct UdtKind(pub i32);
pub const UdtStruct: UdtKind = UdtKind(0i32);
pub const UdtClass: UdtKind = UdtKind(1i32);
pub const UdtUnion: UdtKind = UdtKind(2i32);
pub const UdtInterface: UdtKind = UdtKind(3i32);
impl ::core::marker::Copy for UdtKind {}
impl ::core::clone::Clone for UdtKind {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for UdtKind {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for UdtKind {
    type Abi = Self;
}
impl ::core::fmt::Debug for UdtKind {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("UdtKind").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct __MIDL___MIDL_itf_dia2_0000_0035_0001(pub i32);
pub const E_DIA_INPROLOG: __MIDL___MIDL_itf_dia2_0000_0035_0001 = __MIDL___MIDL_itf_dia2_0000_0035_0001(-2140340124i32);
pub const E_DIA_SYNTAX: __MIDL___MIDL_itf_dia2_0000_0035_0001 = __MIDL___MIDL_itf_dia2_0000_0035_0001(-2140340123i32);
pub const E_DIA_FRAME_ACCESS: __MIDL___MIDL_itf_dia2_0000_0035_0001 = __MIDL___MIDL_itf_dia2_0000_0035_0001(-2140340122i32);
pub const E_DIA_VALUE: __MIDL___MIDL_itf_dia2_0000_0035_0001 = __MIDL___MIDL_itf_dia2_0000_0035_0001(-2140340121i32);
impl ::core::marker::Copy for __MIDL___MIDL_itf_dia2_0000_0035_0001 {}
impl ::core::clone::Clone for __MIDL___MIDL_itf_dia2_0000_0035_0001 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for __MIDL___MIDL_itf_dia2_0000_0035_0001 {
    fn default() -> Self {
        Self(0)
    }
}
unsafe impl ::windows::core::Abi for __MIDL___MIDL_itf_dia2_0000_0035_0001 {
    type Abi = Self;
}
impl ::core::fmt::Debug for __MIDL___MIDL_itf_dia2_0000_0035_0001 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("__MIDL___MIDL_itf_dia2_0000_0035_0001").field(&self.0).finish()
    }
}
#[repr(C)]
pub struct DiaAddressMapEntry {
    pub rva: u32,
    pub rvaTo: u32,
}
impl ::core::marker::Copy for DiaAddressMapEntry {}
impl ::core::clone::Clone for DiaAddressMapEntry {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DiaAddressMapEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DiaAddressMapEntry").field("rva", &self.rva).field("rvaTo", &self.rvaTo).finish()
    }
}
unsafe impl ::windows::core::Abi for DiaAddressMapEntry {
    type Abi = Self;
}
impl ::core::cmp::PartialEq for DiaAddressMapEntry {
    fn eq(&self, other: &Self) -> bool {
        unsafe { ::windows::core::memcmp(self as *const _ as _, other as *const _ as _, core::mem::size_of::<DiaAddressMapEntry>()) == 0 }
    }
}
impl ::core::cmp::Eq for DiaAddressMapEntry {}
impl ::core::default::Default for DiaAddressMapEntry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct __MIDL___MIDL_itf_dia2_0000_0044_0001 {
    pub ulOffStart: u32,
    pub cbProcSize: u32,
    pub cdwLocals: u32,
    pub cdwParams: u16,
    pub cdwFlags: u16,
}
impl ::core::marker::Copy for __MIDL___MIDL_itf_dia2_0000_0044_0001 {}
impl ::core::clone::Clone for __MIDL___MIDL_itf_dia2_0000_0044_0001 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for __MIDL___MIDL_itf_dia2_0000_0044_0001 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("__MIDL___MIDL_itf_dia2_0000_0044_0001").field("ulOffStart", &self.ulOffStart).field("cbProcSize", &self.cbProcSize).field("cdwLocals", &self.cdwLocals).field("cdwParams", &self.cdwParams).field("cdwFlags", &self.cdwFlags).finish()
    }
}
unsafe impl ::windows::core::Abi for __MIDL___MIDL_itf_dia2_0000_0044_0001 {
    type Abi = Self;
}
impl ::core::cmp::PartialEq for __MIDL___MIDL_itf_dia2_0000_0044_0001 {
    fn eq(&self, other: &Self) -> bool {
        unsafe { ::windows::core::memcmp(self as *const _ as _, other as *const _ as _, core::mem::size_of::<__MIDL___MIDL_itf_dia2_0000_0044_0001>()) == 0 }
    }
}
impl ::core::cmp::Eq for __MIDL___MIDL_itf_dia2_0000_0044_0001 {}
impl ::core::default::Default for __MIDL___MIDL_itf_dia2_0000_0044_0001 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub trait IDiaAddressMap_Impl: Sized {
    fn addressMapEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn SetaddressMapEnabled(&self, newval: ::windows::Win32::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn relativeVirtualAddressEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn SetrelativeVirtualAddressEnabled(&self, newval: ::windows::Win32::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn imageAlign(&self) -> ::windows::core::Result<u32>;
    fn SetimageAlign(&self, newval: u32) -> ::windows::core::Result<()>;
    fn set_imageHeaders(&self, cbdata: u32, pbdata: *const u8, originalheaders: ::windows::Win32::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn set_addressMap(&self, cdata: u32, pdata: *const DiaAddressMapEntry, imagetosymbols: ::windows::Win32::Foundation::BOOL) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaAddressMap {}
impl IDiaAddressMap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaAddressMap_Impl, const OFFSET: isize>() -> IDiaAddressMap_Vtbl {
        unsafe extern "system" fn addressMapEnabled<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaAddressMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressMapEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetaddressMapEnabled<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaAddressMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetaddressMapEnabled(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn relativeVirtualAddressEnabled<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaAddressMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.relativeVirtualAddressEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetrelativeVirtualAddressEnabled<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaAddressMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetrelativeVirtualAddressEnabled(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn imageAlign<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaAddressMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.imageAlign() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetimageAlign<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaAddressMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetimageAlign(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn set_imageHeaders<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaAddressMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbdata: u32, pbdata: *const u8, originalheaders: ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.set_imageHeaders(::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&originalheaders)).into()
        }
        unsafe extern "system" fn set_addressMap<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaAddressMap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cdata: u32, pdata: *const DiaAddressMapEntry, imagetosymbols: ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.set_addressMap(::core::mem::transmute_copy(&cdata), ::core::mem::transmute_copy(&pdata), ::core::mem::transmute_copy(&imagetosymbols)).into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            addressMapEnabled: addressMapEnabled::<Identity, Impl, OFFSET>,
            SetaddressMapEnabled: SetaddressMapEnabled::<Identity, Impl, OFFSET>,
            relativeVirtualAddressEnabled: relativeVirtualAddressEnabled::<Identity, Impl, OFFSET>,
            SetrelativeVirtualAddressEnabled: SetrelativeVirtualAddressEnabled::<Identity, Impl, OFFSET>,
            imageAlign: imageAlign::<Identity, Impl, OFFSET>,
            SetimageAlign: SetimageAlign::<Identity, Impl, OFFSET>,
            set_imageHeaders: set_imageHeaders::<Identity, Impl, OFFSET>,
            set_addressMap: set_addressMap::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaAddressMap as ::windows::core::Interface>::IID
    }
}
pub trait IDiaDataSource_Impl: Sized {
    fn lastError(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn loadDataFromPdb(&self, pdbpath: &::windows::core::PCWSTR) -> ::windows::core::Result<()>;
    fn loadAndValidateDataFromPdb(&self, pdbpath: &::windows::core::PCWSTR, pcsig70: *const ::windows::core::GUID, sig: u32, age: u32) -> ::windows::core::Result<()>;
    fn loadDataForExe(&self, executable: &::windows::core::PCWSTR, searchpath: &::windows::core::PCWSTR, pcallback: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn loadDataFromIStream(&self, pistream: &::core::option::Option<::windows::Win32::System::Com::IStream>) -> ::windows::core::Result<()>;
    fn openSession(&self) -> ::windows::core::Result<IDiaSession>;
    fn loadDataFromCodeViewInfo(&self, executable: &::windows::core::PCWSTR, searchpath: &::windows::core::PCWSTR, cbcvinfo: u32, pbcvinfo: *const u8, pcallback: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn loadDataFromMiscInfo(&self, executable: &::windows::core::PCWSTR, searchpath: &::windows::core::PCWSTR, timestampexe: u32, timestampdbg: u32, sizeofexe: u32, cbmiscinfo: u32, pbmiscinfo: *const u8, pcallback: &::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaDataSource {}
impl IDiaDataSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaDataSource_Impl, const OFFSET: isize>() -> IDiaDataSource_Vtbl {
        unsafe extern "system" fn lastError<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaDataSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lastError() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn loadDataFromPdb<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaDataSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdbpath: ::windows::core::PCWSTR) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.loadDataFromPdb(::core::mem::transmute(&pdbpath)).into()
        }
        unsafe extern "system" fn loadAndValidateDataFromPdb<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaDataSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdbpath: ::windows::core::PCWSTR, pcsig70: *const ::windows::core::GUID, sig: u32, age: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.loadAndValidateDataFromPdb(::core::mem::transmute(&pdbpath), ::core::mem::transmute_copy(&pcsig70), ::core::mem::transmute_copy(&sig), ::core::mem::transmute_copy(&age)).into()
        }
        unsafe extern "system" fn loadDataForExe<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaDataSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, executable: ::windows::core::PCWSTR, searchpath: ::windows::core::PCWSTR, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.loadDataForExe(::core::mem::transmute(&executable), ::core::mem::transmute(&searchpath), ::core::mem::transmute(&pcallback)).into()
        }
        unsafe extern "system" fn loadDataFromIStream<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaDataSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pistream: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.loadDataFromIStream(::core::mem::transmute(&pistream)).into()
        }
        unsafe extern "system" fn openSession<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaDataSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.openSession() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsession, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn loadDataFromCodeViewInfo<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaDataSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, executable: ::windows::core::PCWSTR, searchpath: ::windows::core::PCWSTR, cbcvinfo: u32, pbcvinfo: *const u8, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.loadDataFromCodeViewInfo(::core::mem::transmute(&executable), ::core::mem::transmute(&searchpath), ::core::mem::transmute_copy(&cbcvinfo), ::core::mem::transmute_copy(&pbcvinfo), ::core::mem::transmute(&pcallback)).into()
        }
        unsafe extern "system" fn loadDataFromMiscInfo<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaDataSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, executable: ::windows::core::PCWSTR, searchpath: ::windows::core::PCWSTR, timestampexe: u32, timestampdbg: u32, sizeofexe: u32, cbmiscinfo: u32, pbmiscinfo: *const u8, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.loadDataFromMiscInfo(
                ::core::mem::transmute(&executable),
                ::core::mem::transmute(&searchpath),
                ::core::mem::transmute_copy(&timestampexe),
                ::core::mem::transmute_copy(&timestampdbg),
                ::core::mem::transmute_copy(&sizeofexe),
                ::core::mem::transmute_copy(&cbmiscinfo),
                ::core::mem::transmute_copy(&pbmiscinfo),
                ::core::mem::transmute(&pcallback),
            )
            .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            lastError: lastError::<Identity, Impl, OFFSET>,
            loadDataFromPdb: loadDataFromPdb::<Identity, Impl, OFFSET>,
            loadAndValidateDataFromPdb: loadAndValidateDataFromPdb::<Identity, Impl, OFFSET>,
            loadDataForExe: loadDataForExe::<Identity, Impl, OFFSET>,
            loadDataFromIStream: loadDataFromIStream::<Identity, Impl, OFFSET>,
            openSession: openSession::<Identity, Impl, OFFSET>,
            loadDataFromCodeViewInfo: loadDataFromCodeViewInfo::<Identity, Impl, OFFSET>,
            loadDataFromMiscInfo: loadDataFromMiscInfo::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaDataSource as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumDebugStreamData_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn name(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn Item(&self, index: u32, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
    fn Next(&self, celt: u32, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumDebugStreamData>;
}
impl ::windows::core::RuntimeName for IDiaEnumDebugStreamData {}
impl IDiaEnumDebugStreamData_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreamData_Impl, const OFFSET: isize>() -> IDiaEnumDebugStreamData_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreamData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreamData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn name<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreamData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.name() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreamData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Item(::core::mem::transmute_copy(&index), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreamData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreamData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreamData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreamData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            name: name::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumDebugStreamData as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumDebugStreams_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: &::windows::Win32::System::Com::VARIANT) -> ::windows::core::Result<IDiaEnumDebugStreamData>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaEnumDebugStreamData>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumDebugStreams>;
}
impl ::windows::core::RuntimeName for IDiaEnumDebugStreams {}
impl IDiaEnumDebugStreams_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreams_Impl, const OFFSET: isize>() -> IDiaEnumDebugStreams_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<::windows::Win32::System::Com::VARIANT>, stream: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(stream, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumDebugStreams_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumDebugStreams as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumFrameData_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: u32) -> ::windows::core::Result<IDiaFrameData>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaFrameData>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumFrameData>;
    fn frameByRVA(&self, relativevirtualaddress: u32) -> ::windows::core::Result<IDiaFrameData>;
    fn frameByVA(&self, virtualaddress: u64) -> ::windows::core::Result<IDiaFrameData>;
}
impl ::windows::core::RuntimeName for IDiaEnumFrameData {}
impl IDiaEnumFrameData_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>() -> IDiaEnumFrameData_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, frame: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(frame, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn frameByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, relativevirtualaddress: u32, frame: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.frameByRVA(::core::mem::transmute_copy(&relativevirtualaddress)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(frame, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn frameByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, virtualaddress: u64, frame: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.frameByVA(::core::mem::transmute_copy(&virtualaddress)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(frame, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
            frameByRVA: frameByRVA::<Identity, Impl, OFFSET>,
            frameByVA: frameByVA::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumFrameData as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumInjectedSources_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: u32) -> ::windows::core::Result<IDiaInjectedSource>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaInjectedSource>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumInjectedSources>;
}
impl ::windows::core::RuntimeName for IDiaEnumInjectedSources {}
impl IDiaEnumInjectedSources_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInjectedSources_Impl, const OFFSET: isize>() -> IDiaEnumInjectedSources_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInjectedSources_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInjectedSources_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInjectedSources_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, injectedsource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(injectedsource, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInjectedSources_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInjectedSources_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInjectedSources_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInjectedSources_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumInjectedSources as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumInputAssemblyFiles_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: u32) -> ::windows::core::Result<IDiaInputAssemblyFile>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaInputAssemblyFile>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumInputAssemblyFiles>;
}
impl ::windows::core::RuntimeName for IDiaEnumInputAssemblyFiles {}
impl IDiaEnumInputAssemblyFiles_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInputAssemblyFiles_Impl, const OFFSET: isize>() -> IDiaEnumInputAssemblyFiles_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInputAssemblyFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInputAssemblyFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInputAssemblyFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, file: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(file, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInputAssemblyFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInputAssemblyFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInputAssemblyFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumInputAssemblyFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumInputAssemblyFiles as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumLineNumbers_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: u32) -> ::windows::core::Result<IDiaLineNumber>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaLineNumber>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumLineNumbers>;
}
impl ::windows::core::RuntimeName for IDiaEnumLineNumbers {}
impl IDiaEnumLineNumbers_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumLineNumbers_Impl, const OFFSET: isize>() -> IDiaEnumLineNumbers_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumLineNumbers_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumLineNumbers_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumLineNumbers_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, linenumber: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(linenumber, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumLineNumbers_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumLineNumbers_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumLineNumbers_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumLineNumbers_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumLineNumbers as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumSectionContribs_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: u32) -> ::windows::core::Result<IDiaSectionContrib>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSectionContrib>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumSectionContribs>;
}
impl ::windows::core::RuntimeName for IDiaEnumSectionContribs {}
impl IDiaEnumSectionContribs_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSectionContribs_Impl, const OFFSET: isize>() -> IDiaEnumSectionContribs_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSectionContribs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSectionContribs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSectionContribs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, section: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(section, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSectionContribs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSectionContribs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSectionContribs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSectionContribs_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumSectionContribs as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumSegments_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: u32) -> ::windows::core::Result<IDiaSegment>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSegment>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumSegments>;
}
impl ::windows::core::RuntimeName for IDiaEnumSegments {}
impl IDiaEnumSegments_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSegments_Impl, const OFFSET: isize>() -> IDiaEnumSegments_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSegments_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSegments_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSegments_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, segment: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(segment, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSegments_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSegments_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSegments_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSegments_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumSegments as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumSourceFiles_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: u32) -> ::windows::core::Result<IDiaSourceFile>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSourceFile>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumSourceFiles>;
}
impl ::windows::core::RuntimeName for IDiaEnumSourceFiles {}
impl IDiaEnumSourceFiles_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSourceFiles_Impl, const OFFSET: isize>() -> IDiaEnumSourceFiles_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSourceFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSourceFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSourceFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, sourcefile: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(sourcefile, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSourceFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSourceFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSourceFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSourceFiles_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumSourceFiles as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumStackFrames_Impl: Sized {
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaStackFrame>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaEnumStackFrames {}
impl IDiaEnumStackFrames_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumStackFrames_Impl, const OFFSET: isize>() -> IDiaEnumStackFrames_Vtbl {
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumStackFrames_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumStackFrames_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Next: Next::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumStackFrames as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumSymbols_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: u32) -> ::windows::core::Result<IDiaSymbol>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumSymbols>;
}
impl ::windows::core::RuntimeName for IDiaEnumSymbols {}
impl IDiaEnumSymbols_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbols_Impl, const OFFSET: isize>() -> IDiaEnumSymbols_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbols_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbols_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbols_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, symbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(symbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbols_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbols_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbols_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbols_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumSymbols as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumSymbolsByAddr_Impl: Sized {
    fn symbolByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaSymbol>;
    fn symbolByRVA(&self, relativevirtualaddress: u32) -> ::windows::core::Result<IDiaSymbol>;
    fn symbolByVA(&self, virtualaddress: u64) -> ::windows::core::Result<IDiaSymbol>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Prev(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumSymbolsByAddr>;
}
impl ::windows::core::RuntimeName for IDiaEnumSymbolsByAddr {}
impl IDiaEnumSymbolsByAddr_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr_Impl, const OFFSET: isize>() -> IDiaEnumSymbolsByAddr_Vtbl {
        unsafe extern "system" fn symbolByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symbolByAddr(::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn symbolByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, relativevirtualaddress: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symbolByRVA(::core::mem::transmute_copy(&relativevirtualaddress)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn symbolByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, virtualaddress: u64, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symbolByVA(::core::mem::transmute_copy(&virtualaddress)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Prev<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Prev(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            symbolByAddr: symbolByAddr::<Identity, Impl, OFFSET>,
            symbolByRVA: symbolByRVA::<Identity, Impl, OFFSET>,
            symbolByVA: symbolByVA::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Prev: Prev::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumSymbolsByAddr as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumSymbolsByAddr2_Impl: Sized + IDiaEnumSymbolsByAddr_Impl {
    fn symbolByAddrEx(&self, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, isect: u32, offset: u32) -> ::windows::core::Result<IDiaSymbol>;
    fn symbolByRVAEx(&self, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, relativevirtualaddress: u32) -> ::windows::core::Result<IDiaSymbol>;
    fn symbolByVAEx(&self, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, virtualaddress: u64) -> ::windows::core::Result<IDiaSymbol>;
    fn NextEx(&self, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn PrevEx(&self, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, celt: u32, rgelt: *mut ::core::option::Option<IDiaSymbol>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaEnumSymbolsByAddr2 {}
impl IDiaEnumSymbolsByAddr2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr2_Impl, const OFFSET: isize>() -> IDiaEnumSymbolsByAddr2_Vtbl {
        unsafe extern "system" fn symbolByAddrEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, isect: u32, offset: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symbolByAddrEx(::core::mem::transmute_copy(&fpromoteblocksym), ::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn symbolByRVAEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, relativevirtualaddress: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symbolByRVAEx(::core::mem::transmute_copy(&fpromoteblocksym), ::core::mem::transmute_copy(&relativevirtualaddress)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn symbolByVAEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, virtualaddress: u64, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symbolByVAEx(::core::mem::transmute_copy(&fpromoteblocksym), ::core::mem::transmute_copy(&virtualaddress)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NextEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.NextEx(::core::mem::transmute_copy(&fpromoteblocksym), ::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn PrevEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumSymbolsByAddr2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fpromoteblocksym: ::windows::Win32::Foundation::BOOL, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.PrevEx(::core::mem::transmute_copy(&fpromoteblocksym), ::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        Self {
            base__: IDiaEnumSymbolsByAddr_Vtbl::new::<Identity, Impl, OFFSET>(),
            symbolByAddrEx: symbolByAddrEx::<Identity, Impl, OFFSET>,
            symbolByRVAEx: symbolByRVAEx::<Identity, Impl, OFFSET>,
            symbolByVAEx: symbolByVAEx::<Identity, Impl, OFFSET>,
            NextEx: NextEx::<Identity, Impl, OFFSET>,
            PrevEx: PrevEx::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumSymbolsByAddr2 as ::windows::core::Interface>::IID || iid == &<IDiaEnumSymbolsByAddr as ::windows::core::Interface>::IID
    }
}
pub trait IDiaEnumTables_Impl: Sized {
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: &::windows::Win32::System::Com::VARIANT) -> ::windows::core::Result<IDiaTable>;
    fn Next(&self, celt: u32, rgelt: *mut ::core::option::Option<IDiaTable>, pceltfetched: *mut u32) -> ::windows::core::Result<()>;
    fn Skip(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset(&self) -> ::windows::core::Result<()>;
    fn Clone(&self) -> ::windows::core::Result<IDiaEnumTables>;
}
impl ::windows::core::RuntimeName for IDiaEnumTables {}
impl IDiaEnumTables_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumTables_Impl, const OFFSET: isize>() -> IDiaEnumTables_Vtbl {
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumTables_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumTables_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumTables_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: ::core::mem::ManuallyDrop<::windows::Win32::System::Com::VARIANT>, table: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(table, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Next<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumTables_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32, rgelt: *mut *mut ::core::ffi::c_void, pceltfetched: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Next(::core::mem::transmute_copy(&celt), ::core::mem::transmute_copy(&rgelt), ::core::mem::transmute_copy(&pceltfetched)).into()
        }
        unsafe extern "system" fn Skip<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumTables_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumTables_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        unsafe extern "system" fn Clone<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaEnumTables_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
            Next: Next::<Identity, Impl, OFFSET>,
            Skip: Skip::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            Clone: Clone::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaEnumTables as ::windows::core::Interface>::IID
    }
}
pub trait IDiaFrameData_Impl: Sized {
    fn addressSection(&self) -> ::windows::core::Result<u32>;
    fn addressOffset(&self) -> ::windows::core::Result<u32>;
    fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32>;
    fn virtualAddress(&self) -> ::windows::core::Result<u64>;
    fn lengthBlock(&self) -> ::windows::core::Result<u32>;
    fn lengthLocals(&self) -> ::windows::core::Result<u32>;
    fn lengthParams(&self) -> ::windows::core::Result<u32>;
    fn maxStack(&self) -> ::windows::core::Result<u32>;
    fn lengthProlog(&self) -> ::windows::core::Result<u32>;
    fn lengthSavedRegisters(&self) -> ::windows::core::Result<u32>;
    fn program(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn systemExceptionHandling(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn cplusplusExceptionHandling(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn functionStart(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn allocatesBasePointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn r#type(&self) -> ::windows::core::Result<u32>;
    fn functionParent(&self) -> ::windows::core::Result<IDiaFrameData>;
    fn execute(&self, frame: &::core::option::Option<IDiaStackWalkFrame>) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaFrameData {}
impl IDiaFrameData_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>() -> IDiaFrameData_Vtbl {
        unsafe extern "system" fn addressSection<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressSection() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn relativeVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.relativeVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lengthBlock<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lengthBlock() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lengthLocals<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lengthLocals() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lengthParams<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lengthParams() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn maxStack<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.maxStack() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lengthProlog<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lengthProlog() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lengthSavedRegisters<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lengthSavedRegisters() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn program<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.program() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn systemExceptionHandling<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.systemExceptionHandling() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn cplusplusExceptionHandling<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.cplusplusExceptionHandling() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn functionStart<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.functionStart() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn allocatesBasePointer<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.allocatesBasePointer() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn r#type<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.r#type() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn functionParent<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.functionParent() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn execute<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaFrameData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.execute(::core::mem::transmute(&frame)).into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            addressSection: addressSection::<Identity, Impl, OFFSET>,
            addressOffset: addressOffset::<Identity, Impl, OFFSET>,
            relativeVirtualAddress: relativeVirtualAddress::<Identity, Impl, OFFSET>,
            virtualAddress: virtualAddress::<Identity, Impl, OFFSET>,
            lengthBlock: lengthBlock::<Identity, Impl, OFFSET>,
            lengthLocals: lengthLocals::<Identity, Impl, OFFSET>,
            lengthParams: lengthParams::<Identity, Impl, OFFSET>,
            maxStack: maxStack::<Identity, Impl, OFFSET>,
            lengthProlog: lengthProlog::<Identity, Impl, OFFSET>,
            lengthSavedRegisters: lengthSavedRegisters::<Identity, Impl, OFFSET>,
            program: program::<Identity, Impl, OFFSET>,
            systemExceptionHandling: systemExceptionHandling::<Identity, Impl, OFFSET>,
            cplusplusExceptionHandling: cplusplusExceptionHandling::<Identity, Impl, OFFSET>,
            functionStart: functionStart::<Identity, Impl, OFFSET>,
            allocatesBasePointer: allocatesBasePointer::<Identity, Impl, OFFSET>,
            r#type: r#type::<Identity, Impl, OFFSET>,
            functionParent: functionParent::<Identity, Impl, OFFSET>,
            execute: execute::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaFrameData as ::windows::core::Interface>::IID
    }
}
pub trait IDiaImageData_Impl: Sized {
    fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32>;
    fn virtualAddress(&self) -> ::windows::core::Result<u64>;
    fn imageBase(&self) -> ::windows::core::Result<u64>;
}
impl ::windows::core::RuntimeName for IDiaImageData {}
impl IDiaImageData_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaImageData_Impl, const OFFSET: isize>() -> IDiaImageData_Vtbl {
        unsafe extern "system" fn relativeVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaImageData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.relativeVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaImageData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn imageBase<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaImageData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.imageBase() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            relativeVirtualAddress: relativeVirtualAddress::<Identity, Impl, OFFSET>,
            virtualAddress: virtualAddress::<Identity, Impl, OFFSET>,
            imageBase: imageBase::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaImageData as ::windows::core::Interface>::IID
    }
}
pub trait IDiaInjectedSource_Impl: Sized {
    fn crc(&self) -> ::windows::core::Result<u32>;
    fn length(&self) -> ::windows::core::Result<u64>;
    fn filename(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn objectFilename(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn virtualFilename(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn sourceCompression(&self) -> ::windows::core::Result<u32>;
    fn get_source(&self, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaInjectedSource {}
impl IDiaInjectedSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInjectedSource_Impl, const OFFSET: isize>() -> IDiaInjectedSource_Vtbl {
        unsafe extern "system" fn crc<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInjectedSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.crc() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn length<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInjectedSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.length() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn filename<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInjectedSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.filename() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn objectFilename<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInjectedSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.objectFilename() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualFilename<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInjectedSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualFilename() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn sourceCompression<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInjectedSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.sourceCompression() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn get_source<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInjectedSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_source(::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            crc: crc::<Identity, Impl, OFFSET>,
            length: length::<Identity, Impl, OFFSET>,
            filename: filename::<Identity, Impl, OFFSET>,
            objectFilename: objectFilename::<Identity, Impl, OFFSET>,
            virtualFilename: virtualFilename::<Identity, Impl, OFFSET>,
            sourceCompression: sourceCompression::<Identity, Impl, OFFSET>,
            get_source: get_source::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaInjectedSource as ::windows::core::Interface>::IID
    }
}
pub trait IDiaInputAssemblyFile_Impl: Sized {
    fn uniqueId(&self) -> ::windows::core::Result<u32>;
    fn index(&self) -> ::windows::core::Result<u32>;
    fn timestamp(&self) -> ::windows::core::Result<u32>;
    fn pdbAvailableAtILMerge(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn fileName(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn get_version(&self, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaInputAssemblyFile {}
impl IDiaInputAssemblyFile_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInputAssemblyFile_Impl, const OFFSET: isize>() -> IDiaInputAssemblyFile_Vtbl {
        unsafe extern "system" fn uniqueId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInputAssemblyFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.uniqueId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn index<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInputAssemblyFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.index() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn timestamp<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInputAssemblyFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.timestamp() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn pdbAvailableAtILMerge<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInputAssemblyFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.pdbAvailableAtILMerge() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn fileName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInputAssemblyFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.fileName() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn get_version<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaInputAssemblyFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_version(::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            uniqueId: uniqueId::<Identity, Impl, OFFSET>,
            index: index::<Identity, Impl, OFFSET>,
            timestamp: timestamp::<Identity, Impl, OFFSET>,
            pdbAvailableAtILMerge: pdbAvailableAtILMerge::<Identity, Impl, OFFSET>,
            fileName: fileName::<Identity, Impl, OFFSET>,
            get_version: get_version::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaInputAssemblyFile as ::windows::core::Interface>::IID
    }
}
pub trait IDiaLineNumber_Impl: Sized {
    fn compiland(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn sourceFile(&self) -> ::windows::core::Result<IDiaSourceFile>;
    fn lineNumber(&self) -> ::windows::core::Result<u32>;
    fn lineNumberEnd(&self) -> ::windows::core::Result<u32>;
    fn columnNumber(&self) -> ::windows::core::Result<u32>;
    fn columnNumberEnd(&self) -> ::windows::core::Result<u32>;
    fn addressSection(&self) -> ::windows::core::Result<u32>;
    fn addressOffset(&self) -> ::windows::core::Result<u32>;
    fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32>;
    fn virtualAddress(&self) -> ::windows::core::Result<u64>;
    fn length(&self) -> ::windows::core::Result<u32>;
    fn sourceFileId(&self) -> ::windows::core::Result<u32>;
    fn statement(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn compilandId(&self) -> ::windows::core::Result<u32>;
}
impl ::windows::core::RuntimeName for IDiaLineNumber {}
impl IDiaLineNumber_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>() -> IDiaLineNumber_Vtbl {
        unsafe extern "system" fn compiland<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.compiland() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn sourceFile<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.sourceFile() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lineNumber<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lineNumber() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lineNumberEnd<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lineNumberEnd() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn columnNumber<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.columnNumber() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn columnNumberEnd<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.columnNumberEnd() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressSection<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressSection() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn relativeVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.relativeVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn length<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.length() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn sourceFileId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.sourceFileId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn statement<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.statement() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn compilandId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLineNumber_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.compilandId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            compiland: compiland::<Identity, Impl, OFFSET>,
            sourceFile: sourceFile::<Identity, Impl, OFFSET>,
            lineNumber: lineNumber::<Identity, Impl, OFFSET>,
            lineNumberEnd: lineNumberEnd::<Identity, Impl, OFFSET>,
            columnNumber: columnNumber::<Identity, Impl, OFFSET>,
            columnNumberEnd: columnNumberEnd::<Identity, Impl, OFFSET>,
            addressSection: addressSection::<Identity, Impl, OFFSET>,
            addressOffset: addressOffset::<Identity, Impl, OFFSET>,
            relativeVirtualAddress: relativeVirtualAddress::<Identity, Impl, OFFSET>,
            virtualAddress: virtualAddress::<Identity, Impl, OFFSET>,
            length: length::<Identity, Impl, OFFSET>,
            sourceFileId: sourceFileId::<Identity, Impl, OFFSET>,
            statement: statement::<Identity, Impl, OFFSET>,
            compilandId: compilandId::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaLineNumber as ::windows::core::Interface>::IID
    }
}
pub trait IDiaLoadCallback_Impl: Sized {
    fn NotifyDebugDir(&self, fexecutable: ::windows::Win32::Foundation::BOOL, cbdata: u32, pbdata: *const u8) -> ::windows::core::Result<()>;
    fn NotifyOpenDBG(&self, dbgpath: &::windows::core::PCWSTR, resultcode: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
    fn NotifyOpenPDB(&self, pdbpath: &::windows::core::PCWSTR, resultcode: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
    fn RestrictRegistryAccess(&self) -> ::windows::core::Result<()>;
    fn RestrictSymbolServerAccess(&self) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaLoadCallback {}
impl IDiaLoadCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback_Impl, const OFFSET: isize>() -> IDiaLoadCallback_Vtbl {
        unsafe extern "system" fn NotifyDebugDir<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fexecutable: ::windows::Win32::Foundation::BOOL, cbdata: u32, pbdata: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.NotifyDebugDir(::core::mem::transmute_copy(&fexecutable), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        unsafe extern "system" fn NotifyOpenDBG<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dbgpath: ::windows::core::PCWSTR, resultcode: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.NotifyOpenDBG(::core::mem::transmute(&dbgpath), ::core::mem::transmute_copy(&resultcode)).into()
        }
        unsafe extern "system" fn NotifyOpenPDB<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdbpath: ::windows::core::PCWSTR, resultcode: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.NotifyOpenPDB(::core::mem::transmute(&pdbpath), ::core::mem::transmute_copy(&resultcode)).into()
        }
        unsafe extern "system" fn RestrictRegistryAccess<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RestrictRegistryAccess().into()
        }
        unsafe extern "system" fn RestrictSymbolServerAccess<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RestrictSymbolServerAccess().into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            NotifyDebugDir: NotifyDebugDir::<Identity, Impl, OFFSET>,
            NotifyOpenDBG: NotifyOpenDBG::<Identity, Impl, OFFSET>,
            NotifyOpenPDB: NotifyOpenPDB::<Identity, Impl, OFFSET>,
            RestrictRegistryAccess: RestrictRegistryAccess::<Identity, Impl, OFFSET>,
            RestrictSymbolServerAccess: RestrictSymbolServerAccess::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaLoadCallback as ::windows::core::Interface>::IID
    }
}
pub trait IDiaLoadCallback2_Impl: Sized + IDiaLoadCallback_Impl {
    fn RestrictOriginalPathAccess(&self) -> ::windows::core::Result<()>;
    fn RestrictReferencePathAccess(&self) -> ::windows::core::Result<()>;
    fn RestrictDBGAccess(&self) -> ::windows::core::Result<()>;
    fn RestrictSystemRootAccess(&self) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaLoadCallback2 {}
impl IDiaLoadCallback2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback2_Impl, const OFFSET: isize>() -> IDiaLoadCallback2_Vtbl {
        unsafe extern "system" fn RestrictOriginalPathAccess<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RestrictOriginalPathAccess().into()
        }
        unsafe extern "system" fn RestrictReferencePathAccess<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RestrictReferencePathAccess().into()
        }
        unsafe extern "system" fn RestrictDBGAccess<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RestrictDBGAccess().into()
        }
        unsafe extern "system" fn RestrictSystemRootAccess<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaLoadCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RestrictSystemRootAccess().into()
        }
        Self {
            base__: IDiaLoadCallback_Vtbl::new::<Identity, Impl, OFFSET>(),
            RestrictOriginalPathAccess: RestrictOriginalPathAccess::<Identity, Impl, OFFSET>,
            RestrictReferencePathAccess: RestrictReferencePathAccess::<Identity, Impl, OFFSET>,
            RestrictDBGAccess: RestrictDBGAccess::<Identity, Impl, OFFSET>,
            RestrictSystemRootAccess: RestrictSystemRootAccess::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaLoadCallback2 as ::windows::core::Interface>::IID || iid == &<IDiaLoadCallback as ::windows::core::Interface>::IID
    }
}
pub trait IDiaPropertyStorage_Impl: Sized {
    fn ReadMultiple(&self, cpspec: u32, rgpspec: *const ::windows::Win32::System::Com::StructuredStorage::PROPSPEC) -> ::windows::core::Result<::windows::Win32::System::Com::StructuredStorage::PROPVARIANT>;
    fn ReadPropertyNames(&self, cpropid: u32, rgpropid: *const u32, rglpwstrname: *mut ::windows::core::BSTR) -> ::windows::core::Result<()>;
    fn Enum(&self) -> ::windows::core::Result<::windows::Win32::System::Com::StructuredStorage::IEnumSTATPROPSTG>;
    fn ReadDWORD(&self, id: u32) -> ::windows::core::Result<u32>;
    fn ReadLONG(&self, id: u32) -> ::windows::core::Result<i32>;
    fn ReadBOOL(&self, id: u32) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn ReadULONGLONG(&self, id: u32) -> ::windows::core::Result<u64>;
    fn ReadBSTR(&self, id: u32) -> ::windows::core::Result<::windows::core::BSTR>;
}
impl ::windows::core::RuntimeName for IDiaPropertyStorage {}
impl IDiaPropertyStorage_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaPropertyStorage_Impl, const OFFSET: isize>() -> IDiaPropertyStorage_Vtbl {
        unsafe extern "system" fn ReadMultiple<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaPropertyStorage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cpspec: u32, rgpspec: *const ::windows::Win32::System::Com::StructuredStorage::PROPSPEC, rgvar: *mut ::core::mem::ManuallyDrop<::windows::Win32::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.ReadMultiple(::core::mem::transmute_copy(&cpspec), ::core::mem::transmute_copy(&rgpspec)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(rgvar, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReadPropertyNames<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaPropertyStorage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cpropid: u32, rgpropid: *const u32, rglpwstrname: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ReadPropertyNames(::core::mem::transmute_copy(&cpropid), ::core::mem::transmute_copy(&rgpropid), ::core::mem::transmute_copy(&rglpwstrname)).into()
        }
        unsafe extern "system" fn Enum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaPropertyStorage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Enum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReadDWORD<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaPropertyStorage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.ReadDWORD(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pvalue, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReadLONG<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaPropertyStorage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.ReadLONG(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pvalue, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReadBOOL<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaPropertyStorage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.ReadBOOL(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pvalue, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReadULONGLONG<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaPropertyStorage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.ReadULONGLONG(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pvalue, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReadBSTR<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaPropertyStorage_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: u32, pvalue: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.ReadBSTR(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pvalue, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ReadMultiple: ReadMultiple::<Identity, Impl, OFFSET>,
            ReadPropertyNames: ReadPropertyNames::<Identity, Impl, OFFSET>,
            Enum: Enum::<Identity, Impl, OFFSET>,
            ReadDWORD: ReadDWORD::<Identity, Impl, OFFSET>,
            ReadLONG: ReadLONG::<Identity, Impl, OFFSET>,
            ReadBOOL: ReadBOOL::<Identity, Impl, OFFSET>,
            ReadULONGLONG: ReadULONGLONG::<Identity, Impl, OFFSET>,
            ReadBSTR: ReadBSTR::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaPropertyStorage as ::windows::core::Interface>::IID
    }
}
pub trait IDiaReadExeAtOffsetCallback_Impl: Sized {
    fn ReadExecutableAt(&self, fileoffset: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaReadExeAtOffsetCallback {}
impl IDiaReadExeAtOffsetCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaReadExeAtOffsetCallback_Impl, const OFFSET: isize>() -> IDiaReadExeAtOffsetCallback_Vtbl {
        unsafe extern "system" fn ReadExecutableAt<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaReadExeAtOffsetCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fileoffset: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ReadExecutableAt(::core::mem::transmute_copy(&fileoffset), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ReadExecutableAt: ReadExecutableAt::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaReadExeAtOffsetCallback as ::windows::core::Interface>::IID
    }
}
pub trait IDiaReadExeAtRVACallback_Impl: Sized {
    fn ReadExecutableAtRVA(&self, relativevirtualaddress: u32, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaReadExeAtRVACallback {}
impl IDiaReadExeAtRVACallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaReadExeAtRVACallback_Impl, const OFFSET: isize>() -> IDiaReadExeAtRVACallback_Vtbl {
        unsafe extern "system" fn ReadExecutableAtRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaReadExeAtRVACallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, relativevirtualaddress: u32, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ReadExecutableAtRVA(::core::mem::transmute_copy(&relativevirtualaddress), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ReadExecutableAtRVA: ReadExecutableAtRVA::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaReadExeAtRVACallback as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSectionContrib_Impl: Sized {
    fn compiland(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn addressSection(&self) -> ::windows::core::Result<u32>;
    fn addressOffset(&self) -> ::windows::core::Result<u32>;
    fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32>;
    fn virtualAddress(&self) -> ::windows::core::Result<u64>;
    fn length(&self) -> ::windows::core::Result<u32>;
    fn notPaged(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn initializedData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn uninitializedData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn remove(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn comdat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn discardable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn notCached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn share(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn execute(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn read(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn write(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn dataCrc(&self) -> ::windows::core::Result<u32>;
    fn relocationsCrc(&self) -> ::windows::core::Result<u32>;
    fn compilandId(&self) -> ::windows::core::Result<u32>;
    fn code16bit(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
}
impl ::windows::core::RuntimeName for IDiaSectionContrib {}
impl IDiaSectionContrib_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>() -> IDiaSectionContrib_Vtbl {
        unsafe extern "system" fn compiland<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.compiland() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressSection<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressSection() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn relativeVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.relativeVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn length<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.length() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn notPaged<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.notPaged() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn code<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.code() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn initializedData<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.initializedData() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn uninitializedData<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.uninitializedData() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn remove<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.remove() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn comdat<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.comdat() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn discardable<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.discardable() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn notCached<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.notCached() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn share<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.share() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn execute<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.execute() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn read<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.read() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn write<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.write() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn dataCrc<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.dataCrc() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn relocationsCrc<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.relocationsCrc() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn compilandId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.compilandId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn code16bit<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSectionContrib_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.code16bit() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            compiland: compiland::<Identity, Impl, OFFSET>,
            addressSection: addressSection::<Identity, Impl, OFFSET>,
            addressOffset: addressOffset::<Identity, Impl, OFFSET>,
            relativeVirtualAddress: relativeVirtualAddress::<Identity, Impl, OFFSET>,
            virtualAddress: virtualAddress::<Identity, Impl, OFFSET>,
            length: length::<Identity, Impl, OFFSET>,
            notPaged: notPaged::<Identity, Impl, OFFSET>,
            code: code::<Identity, Impl, OFFSET>,
            initializedData: initializedData::<Identity, Impl, OFFSET>,
            uninitializedData: uninitializedData::<Identity, Impl, OFFSET>,
            remove: remove::<Identity, Impl, OFFSET>,
            comdat: comdat::<Identity, Impl, OFFSET>,
            discardable: discardable::<Identity, Impl, OFFSET>,
            notCached: notCached::<Identity, Impl, OFFSET>,
            share: share::<Identity, Impl, OFFSET>,
            execute: execute::<Identity, Impl, OFFSET>,
            read: read::<Identity, Impl, OFFSET>,
            write: write::<Identity, Impl, OFFSET>,
            dataCrc: dataCrc::<Identity, Impl, OFFSET>,
            relocationsCrc: relocationsCrc::<Identity, Impl, OFFSET>,
            compilandId: compilandId::<Identity, Impl, OFFSET>,
            code16bit: code16bit::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSectionContrib as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSegment_Impl: Sized {
    fn frame(&self) -> ::windows::core::Result<u32>;
    fn offset(&self) -> ::windows::core::Result<u32>;
    fn length(&self) -> ::windows::core::Result<u32>;
    fn read(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn write(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn execute(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn addressSection(&self) -> ::windows::core::Result<u32>;
    fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32>;
    fn virtualAddress(&self) -> ::windows::core::Result<u64>;
}
impl ::windows::core::RuntimeName for IDiaSegment {}
impl IDiaSegment_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>() -> IDiaSegment_Vtbl {
        unsafe extern "system" fn frame<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.frame() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn offset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.offset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn length<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.length() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn read<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.read() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn write<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.write() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn execute<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.execute() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressSection<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressSection() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn relativeVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.relativeVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSegment_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            frame: frame::<Identity, Impl, OFFSET>,
            offset: offset::<Identity, Impl, OFFSET>,
            length: length::<Identity, Impl, OFFSET>,
            read: read::<Identity, Impl, OFFSET>,
            write: write::<Identity, Impl, OFFSET>,
            execute: execute::<Identity, Impl, OFFSET>,
            addressSection: addressSection::<Identity, Impl, OFFSET>,
            relativeVirtualAddress: relativeVirtualAddress::<Identity, Impl, OFFSET>,
            virtualAddress: virtualAddress::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSegment as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSession_Impl: Sized {
    fn loadAddress(&self) -> ::windows::core::Result<u64>;
    fn SetloadAddress(&self, newval: u64) -> ::windows::core::Result<()>;
    fn globalScope(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn getEnumTables(&self) -> ::windows::core::Result<IDiaEnumTables>;
    fn getSymbolsByAddr(&self) -> ::windows::core::Result<IDiaEnumSymbolsByAddr>;
    fn findChildren(&self, parent: &::core::option::Option<IDiaSymbol>, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findChildrenEx(&self, parent: &::core::option::Option<IDiaSymbol>, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findChildrenExByAddr(&self, parent: &::core::option::Option<IDiaSymbol>, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findChildrenExByVA(&self, parent: &::core::option::Option<IDiaSymbol>, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findChildrenExByRVA(&self, parent: &::core::option::Option<IDiaSymbol>, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findSymbolByAddr(&self, isect: u32, offset: u32, symtag: SymTag) -> ::windows::core::Result<IDiaSymbol>;
    fn findSymbolByRVA(&self, rva: u32, symtag: SymTag) -> ::windows::core::Result<IDiaSymbol>;
    fn findSymbolByVA(&self, va: u64, symtag: SymTag) -> ::windows::core::Result<IDiaSymbol>;
    fn findSymbolByToken(&self, token: u32, symtag: SymTag) -> ::windows::core::Result<IDiaSymbol>;
    fn symsAreEquiv(&self, symbola: &::core::option::Option<IDiaSymbol>, symbolb: &::core::option::Option<IDiaSymbol>) -> ::windows::core::Result<()>;
    fn symbolById(&self, id: u32) -> ::windows::core::Result<IDiaSymbol>;
    fn findSymbolByRVAEx(&self, rva: u32, symtag: SymTag, ppsymbol: *mut ::core::option::Option<IDiaSymbol>, displacement: *mut i32) -> ::windows::core::Result<()>;
    fn findSymbolByVAEx(&self, va: u64, symtag: SymTag, ppsymbol: *mut ::core::option::Option<IDiaSymbol>, displacement: *mut i32) -> ::windows::core::Result<()>;
    fn findFile(&self, pcompiland: &::core::option::Option<IDiaSymbol>, name: &::windows::core::PCWSTR, compareflags: u32) -> ::windows::core::Result<IDiaEnumSourceFiles>;
    fn findFileById(&self, uniqueid: u32) -> ::windows::core::Result<IDiaSourceFile>;
    fn findLines(&self, compiland: &::core::option::Option<IDiaSymbol>, file: &::core::option::Option<IDiaSourceFile>) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findLinesByAddr(&self, seg: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findLinesByLinenum(&self, compiland: &::core::option::Option<IDiaSymbol>, file: &::core::option::Option<IDiaSourceFile>, linenum: u32, column: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInjectedSource(&self, srcfile: &::windows::core::PCWSTR) -> ::windows::core::Result<IDiaEnumInjectedSources>;
    fn getEnumDebugStreams(&self) -> ::windows::core::Result<IDiaEnumDebugStreams>;
    fn findInlineFramesByAddr(&self, parent: &::core::option::Option<IDiaSymbol>, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findInlineFramesByRVA(&self, parent: &::core::option::Option<IDiaSymbol>, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findInlineFramesByVA(&self, parent: &::core::option::Option<IDiaSymbol>, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findInlineeLines(&self, parent: &::core::option::Option<IDiaSymbol>) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInlineeLinesByAddr(&self, parent: &::core::option::Option<IDiaSymbol>, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInlineeLinesByRVA(&self, parent: &::core::option::Option<IDiaSymbol>, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInlineeLinesByVA(&self, parent: &::core::option::Option<IDiaSymbol>, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInlineeLinesByLinenum(&self, compiland: &::core::option::Option<IDiaSymbol>, file: &::core::option::Option<IDiaSourceFile>, linenum: u32, column: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInlineesByName(&self, name: &::windows::core::PCWSTR, option: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findAcceleratorInlineeLinesByLinenum(&self, parent: &::core::option::Option<IDiaSymbol>, file: &::core::option::Option<IDiaSourceFile>, linenum: u32, column: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findSymbolsForAcceleratorPointerTag(&self, parent: &::core::option::Option<IDiaSymbol>, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findSymbolsByRVAForAcceleratorPointerTag(&self, parent: &::core::option::Option<IDiaSymbol>, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findAcceleratorInlineesByName(&self, name: &::windows::core::PCWSTR, option: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn addressForVA(&self, va: u64, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::Result<()>;
    fn addressForRVA(&self, rva: u32, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::Result<()>;
    fn findILOffsetsByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findILOffsetsByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findILOffsetsByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInputAssemblyFiles(&self) -> ::windows::core::Result<IDiaEnumInputAssemblyFiles>;
    fn findInputAssembly(&self, index: u32) -> ::windows::core::Result<IDiaInputAssemblyFile>;
    fn findInputAssemblyById(&self, uniqueid: u32) -> ::windows::core::Result<IDiaInputAssemblyFile>;
    fn getFuncMDTokenMapSize(&self) -> ::windows::core::Result<u32>;
    fn getFuncMDTokenMap(&self, cb: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::Result<()>;
    fn getTypeMDTokenMapSize(&self) -> ::windows::core::Result<u32>;
    fn getTypeMDTokenMap(&self, cb: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::Result<()>;
    fn getNumberOfFunctionFragments_VA(&self, vafunc: u64, cbfunc: u32) -> ::windows::core::Result<u32>;
    fn getNumberOfFunctionFragments_RVA(&self, rvafunc: u32, cbfunc: u32) -> ::windows::core::Result<u32>;
    fn getFunctionFragments_VA(&self, vafunc: u64, cbfunc: u32, cfragments: u32, pvafragment: *mut u64, plenfragment: *mut u32) -> ::windows::core::Result<()>;
    fn getFunctionFragments_RVA(&self, rvafunc: u32, cbfunc: u32, cfragments: u32, prvafragment: *mut u32, plenfragment: *mut u32) -> ::windows::core::Result<()>;
    fn getExports(&self) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn getHeapAllocationSites(&self) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findInputAssemblyFile(&self, psymbol: &::core::option::Option<IDiaSymbol>) -> ::windows::core::Result<IDiaInputAssemblyFile>;
}
impl ::windows::core::RuntimeName for IDiaSession {}
impl IDiaSession_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>() -> IDiaSession_Vtbl {
        unsafe extern "system" fn loadAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.loadAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetloadAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, newval: u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetloadAddress(::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn globalScope<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.globalScope() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getEnumTables<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenumtables: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getEnumTables() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenumtables, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getSymbolsByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenumbyaddr: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getSymbolsByAddr() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenumbyaddr, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findChildren<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildren(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findChildrenEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildrenEx(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findChildrenExByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, isect: u32, offset: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildrenExByAddr(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags), ::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findChildrenExByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, va: u64, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildrenExByVA(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags), ::core::mem::transmute_copy(&va)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findChildrenExByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildrenExByRVA(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags), ::core::mem::transmute_copy(&rva)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findSymbolByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findSymbolByAddr(::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset), ::core::mem::transmute_copy(&symtag)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findSymbolByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rva: u32, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findSymbolByRVA(::core::mem::transmute_copy(&rva), ::core::mem::transmute_copy(&symtag)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findSymbolByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findSymbolByVA(::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&symtag)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findSymbolByToken<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, token: u32, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findSymbolByToken(::core::mem::transmute_copy(&token), ::core::mem::transmute_copy(&symtag)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn symsAreEquiv<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symbola: *mut ::core::ffi::c_void, symbolb: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.symsAreEquiv(::core::mem::transmute(&symbola), ::core::mem::transmute(&symbolb)).into()
        }
        unsafe extern "system" fn symbolById<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: u32, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symbolById(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findSymbolByRVAEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rva: u32, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void, displacement: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.findSymbolByRVAEx(::core::mem::transmute_copy(&rva), ::core::mem::transmute_copy(&symtag), ::core::mem::transmute_copy(&ppsymbol), ::core::mem::transmute_copy(&displacement)).into()
        }
        unsafe extern "system" fn findSymbolByVAEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, symtag: SymTag, ppsymbol: *mut *mut ::core::ffi::c_void, displacement: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.findSymbolByVAEx(::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&symtag), ::core::mem::transmute_copy(&ppsymbol), ::core::mem::transmute_copy(&displacement)).into()
        }
        unsafe extern "system" fn findFile<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcompiland: *mut ::core::ffi::c_void, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findFile(::core::mem::transmute(&pcompiland), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findFileById<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uniqueid: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findFileById(::core::mem::transmute_copy(&uniqueid)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findLines<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compiland: *mut ::core::ffi::c_void, file: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findLines(::core::mem::transmute(&compiland), ::core::mem::transmute(&file)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findLinesByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, seg: u32, offset: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findLinesByAddr(::core::mem::transmute_copy(&seg), ::core::mem::transmute_copy(&offset), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findLinesByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rva: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findLinesByRVA(::core::mem::transmute_copy(&rva), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findLinesByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findLinesByVA(::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findLinesByLinenum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compiland: *mut ::core::ffi::c_void, file: *mut ::core::ffi::c_void, linenum: u32, column: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findLinesByLinenum(::core::mem::transmute(&compiland), ::core::mem::transmute(&file), ::core::mem::transmute_copy(&linenum), ::core::mem::transmute_copy(&column)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInjectedSource<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, srcfile: ::windows::core::PCWSTR, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInjectedSource(::core::mem::transmute(&srcfile)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getEnumDebugStreams<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenumdebugstreams: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getEnumDebugStreams() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenumdebugstreams, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineFramesByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, isect: u32, offset: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineFramesByAddr(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineFramesByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineFramesByRVA(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&rva)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineFramesByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, va: u64, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineFramesByVA(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&va)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineeLines<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineeLines(::core::mem::transmute(&parent)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineeLinesByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, isect: u32, offset: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineeLinesByAddr(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineeLinesByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, rva: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineeLinesByRVA(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&rva), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineeLinesByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, va: u64, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineeLinesByVA(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineeLinesByLinenum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, compiland: *mut ::core::ffi::c_void, file: *mut ::core::ffi::c_void, linenum: u32, column: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineeLinesByLinenum(::core::mem::transmute(&compiland), ::core::mem::transmute(&file), ::core::mem::transmute_copy(&linenum), ::core::mem::transmute_copy(&column)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineesByName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: ::windows::core::PCWSTR, option: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineesByName(::core::mem::transmute(&name), ::core::mem::transmute_copy(&option)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findAcceleratorInlineeLinesByLinenum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, file: *mut ::core::ffi::c_void, linenum: u32, column: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findAcceleratorInlineeLinesByLinenum(::core::mem::transmute(&parent), ::core::mem::transmute(&file), ::core::mem::transmute_copy(&linenum), ::core::mem::transmute_copy(&column)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findSymbolsForAcceleratorPointerTag<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, tagvalue: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findSymbolsForAcceleratorPointerTag(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&tagvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findSymbolsByRVAForAcceleratorPointerTag<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, parent: *mut ::core::ffi::c_void, tagvalue: u32, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findSymbolsByRVAForAcceleratorPointerTag(::core::mem::transmute(&parent), ::core::mem::transmute_copy(&tagvalue), ::core::mem::transmute_copy(&rva)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findAcceleratorInlineesByName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: ::windows::core::PCWSTR, option: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findAcceleratorInlineesByName(::core::mem::transmute(&name), ::core::mem::transmute_copy(&option)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressForVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.addressForVA(::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&pisect), ::core::mem::transmute_copy(&poffset)).into()
        }
        unsafe extern "system" fn addressForRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rva: u32, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.addressForRVA(::core::mem::transmute_copy(&rva), ::core::mem::transmute_copy(&pisect), ::core::mem::transmute_copy(&poffset)).into()
        }
        unsafe extern "system" fn findILOffsetsByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findILOffsetsByAddr(::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findILOffsetsByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rva: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findILOffsetsByRVA(::core::mem::transmute_copy(&rva), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findILOffsetsByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findILOffsetsByVA(::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInputAssemblyFiles<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInputAssemblyFiles() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInputAssembly<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInputAssembly(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInputAssemblyById<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uniqueid: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInputAssemblyById(::core::mem::transmute_copy(&uniqueid)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getFuncMDTokenMapSize<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcb: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getFuncMDTokenMapSize() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pcb, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getFuncMDTokenMap<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cb: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.getFuncMDTokenMap(::core::mem::transmute_copy(&cb), ::core::mem::transmute_copy(&pcb), ::core::mem::transmute_copy(&pb)).into()
        }
        unsafe extern "system" fn getTypeMDTokenMapSize<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcb: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getTypeMDTokenMapSize() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pcb, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getTypeMDTokenMap<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cb: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.getTypeMDTokenMap(::core::mem::transmute_copy(&cb), ::core::mem::transmute_copy(&pcb), ::core::mem::transmute_copy(&pb)).into()
        }
        unsafe extern "system" fn getNumberOfFunctionFragments_VA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, vafunc: u64, cbfunc: u32, pnumfragments: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getNumberOfFunctionFragments_VA(::core::mem::transmute_copy(&vafunc), ::core::mem::transmute_copy(&cbfunc)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pnumfragments, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getNumberOfFunctionFragments_RVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rvafunc: u32, cbfunc: u32, pnumfragments: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getNumberOfFunctionFragments_RVA(::core::mem::transmute_copy(&rvafunc), ::core::mem::transmute_copy(&cbfunc)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pnumfragments, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getFunctionFragments_VA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, vafunc: u64, cbfunc: u32, cfragments: u32, pvafragment: *mut u64, plenfragment: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.getFunctionFragments_VA(::core::mem::transmute_copy(&vafunc), ::core::mem::transmute_copy(&cbfunc), ::core::mem::transmute_copy(&cfragments), ::core::mem::transmute_copy(&pvafragment), ::core::mem::transmute_copy(&plenfragment)).into()
        }
        unsafe extern "system" fn getFunctionFragments_RVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rvafunc: u32, cbfunc: u32, cfragments: u32, prvafragment: *mut u32, plenfragment: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.getFunctionFragments_RVA(::core::mem::transmute_copy(&rvafunc), ::core::mem::transmute_copy(&cbfunc), ::core::mem::transmute_copy(&cfragments), ::core::mem::transmute_copy(&prvafragment), ::core::mem::transmute_copy(&plenfragment)).into()
        }
        unsafe extern "system" fn getExports<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getExports() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getHeapAllocationSites<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getHeapAllocationSites() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInputAssemblyFile<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psymbol: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInputAssemblyFile(::core::mem::transmute(&psymbol)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            loadAddress: loadAddress::<Identity, Impl, OFFSET>,
            SetloadAddress: SetloadAddress::<Identity, Impl, OFFSET>,
            globalScope: globalScope::<Identity, Impl, OFFSET>,
            getEnumTables: getEnumTables::<Identity, Impl, OFFSET>,
            getSymbolsByAddr: getSymbolsByAddr::<Identity, Impl, OFFSET>,
            findChildren: findChildren::<Identity, Impl, OFFSET>,
            findChildrenEx: findChildrenEx::<Identity, Impl, OFFSET>,
            findChildrenExByAddr: findChildrenExByAddr::<Identity, Impl, OFFSET>,
            findChildrenExByVA: findChildrenExByVA::<Identity, Impl, OFFSET>,
            findChildrenExByRVA: findChildrenExByRVA::<Identity, Impl, OFFSET>,
            findSymbolByAddr: findSymbolByAddr::<Identity, Impl, OFFSET>,
            findSymbolByRVA: findSymbolByRVA::<Identity, Impl, OFFSET>,
            findSymbolByVA: findSymbolByVA::<Identity, Impl, OFFSET>,
            findSymbolByToken: findSymbolByToken::<Identity, Impl, OFFSET>,
            symsAreEquiv: symsAreEquiv::<Identity, Impl, OFFSET>,
            symbolById: symbolById::<Identity, Impl, OFFSET>,
            findSymbolByRVAEx: findSymbolByRVAEx::<Identity, Impl, OFFSET>,
            findSymbolByVAEx: findSymbolByVAEx::<Identity, Impl, OFFSET>,
            findFile: findFile::<Identity, Impl, OFFSET>,
            findFileById: findFileById::<Identity, Impl, OFFSET>,
            findLines: findLines::<Identity, Impl, OFFSET>,
            findLinesByAddr: findLinesByAddr::<Identity, Impl, OFFSET>,
            findLinesByRVA: findLinesByRVA::<Identity, Impl, OFFSET>,
            findLinesByVA: findLinesByVA::<Identity, Impl, OFFSET>,
            findLinesByLinenum: findLinesByLinenum::<Identity, Impl, OFFSET>,
            findInjectedSource: findInjectedSource::<Identity, Impl, OFFSET>,
            getEnumDebugStreams: getEnumDebugStreams::<Identity, Impl, OFFSET>,
            findInlineFramesByAddr: findInlineFramesByAddr::<Identity, Impl, OFFSET>,
            findInlineFramesByRVA: findInlineFramesByRVA::<Identity, Impl, OFFSET>,
            findInlineFramesByVA: findInlineFramesByVA::<Identity, Impl, OFFSET>,
            findInlineeLines: findInlineeLines::<Identity, Impl, OFFSET>,
            findInlineeLinesByAddr: findInlineeLinesByAddr::<Identity, Impl, OFFSET>,
            findInlineeLinesByRVA: findInlineeLinesByRVA::<Identity, Impl, OFFSET>,
            findInlineeLinesByVA: findInlineeLinesByVA::<Identity, Impl, OFFSET>,
            findInlineeLinesByLinenum: findInlineeLinesByLinenum::<Identity, Impl, OFFSET>,
            findInlineesByName: findInlineesByName::<Identity, Impl, OFFSET>,
            findAcceleratorInlineeLinesByLinenum: findAcceleratorInlineeLinesByLinenum::<Identity, Impl, OFFSET>,
            findSymbolsForAcceleratorPointerTag: findSymbolsForAcceleratorPointerTag::<Identity, Impl, OFFSET>,
            findSymbolsByRVAForAcceleratorPointerTag: findSymbolsByRVAForAcceleratorPointerTag::<Identity, Impl, OFFSET>,
            findAcceleratorInlineesByName: findAcceleratorInlineesByName::<Identity, Impl, OFFSET>,
            addressForVA: addressForVA::<Identity, Impl, OFFSET>,
            addressForRVA: addressForRVA::<Identity, Impl, OFFSET>,
            findILOffsetsByAddr: findILOffsetsByAddr::<Identity, Impl, OFFSET>,
            findILOffsetsByRVA: findILOffsetsByRVA::<Identity, Impl, OFFSET>,
            findILOffsetsByVA: findILOffsetsByVA::<Identity, Impl, OFFSET>,
            findInputAssemblyFiles: findInputAssemblyFiles::<Identity, Impl, OFFSET>,
            findInputAssembly: findInputAssembly::<Identity, Impl, OFFSET>,
            findInputAssemblyById: findInputAssemblyById::<Identity, Impl, OFFSET>,
            getFuncMDTokenMapSize: getFuncMDTokenMapSize::<Identity, Impl, OFFSET>,
            getFuncMDTokenMap: getFuncMDTokenMap::<Identity, Impl, OFFSET>,
            getTypeMDTokenMapSize: getTypeMDTokenMapSize::<Identity, Impl, OFFSET>,
            getTypeMDTokenMap: getTypeMDTokenMap::<Identity, Impl, OFFSET>,
            getNumberOfFunctionFragments_VA: getNumberOfFunctionFragments_VA::<Identity, Impl, OFFSET>,
            getNumberOfFunctionFragments_RVA: getNumberOfFunctionFragments_RVA::<Identity, Impl, OFFSET>,
            getFunctionFragments_VA: getFunctionFragments_VA::<Identity, Impl, OFFSET>,
            getFunctionFragments_RVA: getFunctionFragments_RVA::<Identity, Impl, OFFSET>,
            getExports: getExports::<Identity, Impl, OFFSET>,
            getHeapAllocationSites: getHeapAllocationSites::<Identity, Impl, OFFSET>,
            findInputAssemblyFile: findInputAssemblyFile::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSession as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSourceFile_Impl: Sized {
    fn uniqueId(&self) -> ::windows::core::Result<u32>;
    fn fileName(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn checksumType(&self) -> ::windows::core::Result<u32>;
    fn compilands(&self) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn get_checksum(&self, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaSourceFile {}
impl IDiaSourceFile_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSourceFile_Impl, const OFFSET: isize>() -> IDiaSourceFile_Vtbl {
        unsafe extern "system" fn uniqueId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSourceFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.uniqueId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn fileName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSourceFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.fileName() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn checksumType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSourceFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.checksumType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn compilands<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSourceFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.compilands() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn get_checksum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSourceFile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_checksum(::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            uniqueId: uniqueId::<Identity, Impl, OFFSET>,
            fileName: fileName::<Identity, Impl, OFFSET>,
            checksumType: checksumType::<Identity, Impl, OFFSET>,
            compilands: compilands::<Identity, Impl, OFFSET>,
            get_checksum: get_checksum::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSourceFile as ::windows::core::Interface>::IID
    }
}
pub trait IDiaStackFrame_Impl: Sized {
    fn r#type(&self) -> ::windows::core::Result<u32>;
    fn base(&self) -> ::windows::core::Result<u64>;
    fn size(&self) -> ::windows::core::Result<u32>;
    fn returnAddress(&self) -> ::windows::core::Result<u64>;
    fn localsBase(&self) -> ::windows::core::Result<u64>;
    fn lengthLocals(&self) -> ::windows::core::Result<u32>;
    fn lengthParams(&self) -> ::windows::core::Result<u32>;
    fn lengthProlog(&self) -> ::windows::core::Result<u32>;
    fn lengthSavedRegisters(&self) -> ::windows::core::Result<u32>;
    fn systemExceptionHandling(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn cplusplusExceptionHandling(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn functionStart(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn allocatesBasePointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn maxStack(&self) -> ::windows::core::Result<u32>;
    fn get_registerValue(&self, index: u32) -> ::windows::core::Result<u64>;
}
impl ::windows::core::RuntimeName for IDiaStackFrame {}
impl IDiaStackFrame_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>() -> IDiaStackFrame_Vtbl {
        unsafe extern "system" fn r#type<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.r#type() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn base<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.base() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn size<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.size() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn returnAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.returnAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn localsBase<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.localsBase() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lengthLocals<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lengthLocals() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lengthParams<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lengthParams() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lengthProlog<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lengthProlog() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lengthSavedRegisters<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lengthSavedRegisters() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn systemExceptionHandling<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.systemExceptionHandling() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn cplusplusExceptionHandling<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.cplusplusExceptionHandling() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn functionStart<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.functionStart() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn allocatesBasePointer<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.allocatesBasePointer() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn maxStack<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.maxStack() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn get_registerValue<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.get_registerValue(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            r#type: r#type::<Identity, Impl, OFFSET>,
            base: base::<Identity, Impl, OFFSET>,
            size: size::<Identity, Impl, OFFSET>,
            returnAddress: returnAddress::<Identity, Impl, OFFSET>,
            localsBase: localsBase::<Identity, Impl, OFFSET>,
            lengthLocals: lengthLocals::<Identity, Impl, OFFSET>,
            lengthParams: lengthParams::<Identity, Impl, OFFSET>,
            lengthProlog: lengthProlog::<Identity, Impl, OFFSET>,
            lengthSavedRegisters: lengthSavedRegisters::<Identity, Impl, OFFSET>,
            systemExceptionHandling: systemExceptionHandling::<Identity, Impl, OFFSET>,
            cplusplusExceptionHandling: cplusplusExceptionHandling::<Identity, Impl, OFFSET>,
            functionStart: functionStart::<Identity, Impl, OFFSET>,
            allocatesBasePointer: allocatesBasePointer::<Identity, Impl, OFFSET>,
            maxStack: maxStack::<Identity, Impl, OFFSET>,
            get_registerValue: get_registerValue::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaStackFrame as ::windows::core::Interface>::IID
    }
}
pub trait IDiaStackWalkFrame_Impl: Sized {
    fn get_registerValue(&self, index: u32) -> ::windows::core::Result<u64>;
    fn put_registerValue(&self, index: u32, newval: u64) -> ::windows::core::Result<()>;
    fn readMemory(&self, r#type: MemoryTypeEnum, va: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
    fn searchForReturnAddress(&self, frame: &::core::option::Option<IDiaFrameData>) -> ::windows::core::Result<u64>;
    fn searchForReturnAddressStart(&self, frame: &::core::option::Option<IDiaFrameData>, startaddress: u64) -> ::windows::core::Result<u64>;
}
impl ::windows::core::RuntimeName for IDiaStackWalkFrame {}
impl IDiaStackWalkFrame_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkFrame_Impl, const OFFSET: isize>() -> IDiaStackWalkFrame_Vtbl {
        unsafe extern "system" fn get_registerValue<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.get_registerValue(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn put_registerValue<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, newval: u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.put_registerValue(::core::mem::transmute_copy(&index), ::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn readMemory<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: MemoryTypeEnum, va: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.readMemory(::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        unsafe extern "system" fn searchForReturnAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void, returnaddress: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.searchForReturnAddress(::core::mem::transmute(&frame)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(returnaddress, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn searchForReturnAddressStart<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void, startaddress: u64, returnaddress: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.searchForReturnAddressStart(::core::mem::transmute(&frame), ::core::mem::transmute_copy(&startaddress)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(returnaddress, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            get_registerValue: get_registerValue::<Identity, Impl, OFFSET>,
            put_registerValue: put_registerValue::<Identity, Impl, OFFSET>,
            readMemory: readMemory::<Identity, Impl, OFFSET>,
            searchForReturnAddress: searchForReturnAddress::<Identity, Impl, OFFSET>,
            searchForReturnAddressStart: searchForReturnAddressStart::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaStackWalkFrame as ::windows::core::Interface>::IID
    }
}
pub trait IDiaStackWalkHelper_Impl: Sized {
    fn get_registerValue(&self, index: u32) -> ::windows::core::Result<u64>;
    fn put_registerValue(&self, index: u32, newval: u64) -> ::windows::core::Result<()>;
    fn readMemory(&self, r#type: MemoryTypeEnum, va: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
    fn searchForReturnAddress(&self, frame: &::core::option::Option<IDiaFrameData>) -> ::windows::core::Result<u64>;
    fn searchForReturnAddressStart(&self, frame: &::core::option::Option<IDiaFrameData>, startaddress: u64) -> ::windows::core::Result<u64>;
    fn frameForVA(&self, va: u64) -> ::windows::core::Result<IDiaFrameData>;
    fn symbolForVA(&self, va: u64) -> ::windows::core::Result<IDiaSymbol>;
    fn pdataForVA(&self, va: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
    fn imageForVA(&self, vacontext: u64) -> ::windows::core::Result<u64>;
    fn addressForVA(&self, va: u64, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::Result<()>;
    fn numberOfFunctionFragmentsForVA(&self, vafunc: u64, cbfunc: u32) -> ::windows::core::Result<u32>;
    fn functionFragmentsForVA(&self, vafunc: u64, cbfunc: u32, cfragments: u32, pvafragment: *mut u64, plenfragment: *mut u32) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaStackWalkHelper {}
impl IDiaStackWalkHelper_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>() -> IDiaStackWalkHelper_Vtbl {
        unsafe extern "system" fn get_registerValue<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.get_registerValue(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn put_registerValue<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, newval: u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.put_registerValue(::core::mem::transmute_copy(&index), ::core::mem::transmute_copy(&newval)).into()
        }
        unsafe extern "system" fn readMemory<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: MemoryTypeEnum, va: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.readMemory(::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        unsafe extern "system" fn searchForReturnAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void, returnaddress: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.searchForReturnAddress(::core::mem::transmute(&frame)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(returnaddress, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn searchForReturnAddressStart<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, frame: *mut ::core::ffi::c_void, startaddress: u64, returnaddress: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.searchForReturnAddressStart(::core::mem::transmute(&frame), ::core::mem::transmute_copy(&startaddress)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(returnaddress, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn frameForVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, ppframe: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.frameForVA(::core::mem::transmute_copy(&va)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppframe, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn symbolForVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, ppsymbol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symbolForVA(::core::mem::transmute_copy(&va)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppsymbol, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn pdataForVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.pdataForVA(::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        unsafe extern "system" fn imageForVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, vacontext: u64, pvaimagestart: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.imageForVA(::core::mem::transmute_copy(&vacontext)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pvaimagestart, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressForVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, pisect: *mut u32, poffset: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.addressForVA(::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&pisect), ::core::mem::transmute_copy(&poffset)).into()
        }
        unsafe extern "system" fn numberOfFunctionFragmentsForVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, vafunc: u64, cbfunc: u32, pnumfragments: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.numberOfFunctionFragmentsForVA(::core::mem::transmute_copy(&vafunc), ::core::mem::transmute_copy(&cbfunc)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pnumfragments, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn functionFragmentsForVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, vafunc: u64, cbfunc: u32, cfragments: u32, pvafragment: *mut u64, plenfragment: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.functionFragmentsForVA(::core::mem::transmute_copy(&vafunc), ::core::mem::transmute_copy(&cbfunc), ::core::mem::transmute_copy(&cfragments), ::core::mem::transmute_copy(&pvafragment), ::core::mem::transmute_copy(&plenfragment)).into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            get_registerValue: get_registerValue::<Identity, Impl, OFFSET>,
            put_registerValue: put_registerValue::<Identity, Impl, OFFSET>,
            readMemory: readMemory::<Identity, Impl, OFFSET>,
            searchForReturnAddress: searchForReturnAddress::<Identity, Impl, OFFSET>,
            searchForReturnAddressStart: searchForReturnAddressStart::<Identity, Impl, OFFSET>,
            frameForVA: frameForVA::<Identity, Impl, OFFSET>,
            symbolForVA: symbolForVA::<Identity, Impl, OFFSET>,
            pdataForVA: pdataForVA::<Identity, Impl, OFFSET>,
            imageForVA: imageForVA::<Identity, Impl, OFFSET>,
            addressForVA: addressForVA::<Identity, Impl, OFFSET>,
            numberOfFunctionFragmentsForVA: numberOfFunctionFragmentsForVA::<Identity, Impl, OFFSET>,
            functionFragmentsForVA: functionFragmentsForVA::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaStackWalkHelper as ::windows::core::Interface>::IID
    }
}
pub trait IDiaStackWalkHelper2_Impl: Sized + IDiaStackWalkHelper_Impl {}
impl ::windows::core::RuntimeName for IDiaStackWalkHelper2 {}
impl IDiaStackWalkHelper2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalkHelper2_Impl, const OFFSET: isize>() -> IDiaStackWalkHelper2_Vtbl {
        Self { base__: IDiaStackWalkHelper_Vtbl::new::<Identity, Impl, OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaStackWalkHelper2 as ::windows::core::Interface>::IID || iid == &<IDiaStackWalkHelper as ::windows::core::Interface>::IID
    }
}
pub trait IDiaStackWalker_Impl: Sized {
    fn getEnumFrames(&self, phelper: &::core::option::Option<IDiaStackWalkHelper>) -> ::windows::core::Result<IDiaEnumStackFrames>;
    fn getEnumFrames2(&self, cpuid: CV_CPU_TYPE_e, phelper: &::core::option::Option<IDiaStackWalkHelper>) -> ::windows::core::Result<IDiaEnumStackFrames>;
}
impl ::windows::core::RuntimeName for IDiaStackWalker {}
impl IDiaStackWalker_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalker_Impl, const OFFSET: isize>() -> IDiaStackWalker_Vtbl {
        unsafe extern "system" fn getEnumFrames<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phelper: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getEnumFrames(::core::mem::transmute(&phelper)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn getEnumFrames2<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalker_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cpuid: CV_CPU_TYPE_e, phelper: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getEnumFrames2(::core::mem::transmute_copy(&cpuid), ::core::mem::transmute(&phelper)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            getEnumFrames: getEnumFrames::<Identity, Impl, OFFSET>,
            getEnumFrames2: getEnumFrames2::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaStackWalker as ::windows::core::Interface>::IID
    }
}
pub trait IDiaStackWalker2_Impl: Sized + IDiaStackWalker_Impl {}
impl ::windows::core::RuntimeName for IDiaStackWalker2 {}
impl IDiaStackWalker2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaStackWalker2_Impl, const OFFSET: isize>() -> IDiaStackWalker2_Vtbl {
        Self { base__: IDiaStackWalker_Vtbl::new::<Identity, Impl, OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaStackWalker2 as ::windows::core::Interface>::IID || iid == &<IDiaStackWalker as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol_Impl: Sized {
    fn symIndexId(&self) -> ::windows::core::Result<u32>;
    fn symTag(&self) -> ::windows::core::Result<u32>;
    fn name(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn lexicalParent(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn classParent(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn r#type(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn dataKind(&self) -> ::windows::core::Result<u32>;
    fn locationType(&self) -> ::windows::core::Result<u32>;
    fn addressSection(&self) -> ::windows::core::Result<u32>;
    fn addressOffset(&self) -> ::windows::core::Result<u32>;
    fn relativeVirtualAddress(&self) -> ::windows::core::Result<u32>;
    fn virtualAddress(&self) -> ::windows::core::Result<u64>;
    fn registerId(&self) -> ::windows::core::Result<u32>;
    fn offset(&self) -> ::windows::core::Result<i32>;
    fn length(&self) -> ::windows::core::Result<u64>;
    fn slot(&self) -> ::windows::core::Result<u32>;
    fn volatileType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn constType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn unalignedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn access(&self) -> ::windows::core::Result<u32>;
    fn libraryName(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn platform(&self) -> ::windows::core::Result<u32>;
    fn language(&self) -> ::windows::core::Result<u32>;
    fn editAndContinueEnabled(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn frontEndMajor(&self) -> ::windows::core::Result<u32>;
    fn frontEndMinor(&self) -> ::windows::core::Result<u32>;
    fn frontEndBuild(&self) -> ::windows::core::Result<u32>;
    fn backEndMajor(&self) -> ::windows::core::Result<u32>;
    fn backEndMinor(&self) -> ::windows::core::Result<u32>;
    fn backEndBuild(&self) -> ::windows::core::Result<u32>;
    fn sourceFileName(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn unused(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn thunkOrdinal(&self) -> ::windows::core::Result<u32>;
    fn thisAdjust(&self) -> ::windows::core::Result<i32>;
    fn virtualBaseOffset(&self) -> ::windows::core::Result<u32>;
    fn r#virtual(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn intro(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn pure(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn callingConvention(&self) -> ::windows::core::Result<u32>;
    fn value(&self) -> ::windows::core::Result<::windows::Win32::System::Com::VARIANT>;
    fn baseType(&self) -> ::windows::core::Result<u32>;
    fn token(&self) -> ::windows::core::Result<u32>;
    fn timeStamp(&self) -> ::windows::core::Result<u32>;
    fn guid(&self) -> ::windows::core::Result<::windows::core::GUID>;
    fn symbolsFileName(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn reference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn count(&self) -> ::windows::core::Result<u32>;
    fn bitPosition(&self) -> ::windows::core::Result<u32>;
    fn arrayIndexType(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn packed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn constructor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn overloadedOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn nested(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasNestedTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasAssignmentOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasCastOperator(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn scoped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn virtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn indirectVirtualBaseClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn virtualBasePointerOffset(&self) -> ::windows::core::Result<i32>;
    fn virtualTableShape(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn lexicalParentId(&self) -> ::windows::core::Result<u32>;
    fn classParentId(&self) -> ::windows::core::Result<u32>;
    fn typeId(&self) -> ::windows::core::Result<u32>;
    fn arrayIndexTypeId(&self) -> ::windows::core::Result<u32>;
    fn virtualTableShapeId(&self) -> ::windows::core::Result<u32>;
    fn code(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn function(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn managed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn msil(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn virtualBaseDispIndex(&self) -> ::windows::core::Result<u32>;
    fn undecoratedName(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn age(&self) -> ::windows::core::Result<u32>;
    fn signature(&self) -> ::windows::core::Result<u32>;
    fn compilerGenerated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn addressTaken(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn rank(&self) -> ::windows::core::Result<u32>;
    fn lowerBound(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn upperBound(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn lowerBoundId(&self) -> ::windows::core::Result<u32>;
    fn upperBoundId(&self) -> ::windows::core::Result<u32>;
    fn get_dataBytes(&self, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::Result<()>;
    fn findChildren(&self, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findChildrenEx(&self, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findChildrenExByAddr(&self, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findChildrenExByVA(&self, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findChildrenExByRVA(&self, symtag: SymTag, name: &::windows::core::PCWSTR, compareflags: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn targetSection(&self) -> ::windows::core::Result<u32>;
    fn targetOffset(&self) -> ::windows::core::Result<u32>;
    fn targetRelativeVirtualAddress(&self) -> ::windows::core::Result<u32>;
    fn targetVirtualAddress(&self) -> ::windows::core::Result<u64>;
    fn machineType(&self) -> ::windows::core::Result<u32>;
    fn oemId(&self) -> ::windows::core::Result<u32>;
    fn oemSymbolId(&self) -> ::windows::core::Result<u32>;
    fn get_types(&self, ctypes: u32, pctypes: *mut u32, ptypes: *mut ::core::option::Option<IDiaSymbol>) -> ::windows::core::Result<()>;
    fn get_typeIds(&self, ctypeids: u32, pctypeids: *mut u32, pdwtypeids: *mut u32) -> ::windows::core::Result<()>;
    fn objectPointerType(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn udtKind(&self) -> ::windows::core::Result<u32>;
    fn get_undecoratedNameEx(&self, undecorateoptions: u32) -> ::windows::core::Result<::windows::core::BSTR>;
    fn noReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn customCallingConvention(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn noInline(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn optimizedCodeDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn notReached(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn interruptReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn farReturn(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isStatic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasDebugInfo(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isLTCG(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isDataAligned(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasSecurityChecks(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn compilerName(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn hasAlloca(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasSetJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasLongJump(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasInlAsm(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasSEH(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasEHa(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isNaked(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isAggregated(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isSplitted(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn container(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn inlSpec(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn noStackOrdering(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn virtualBaseTableType(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn hasManagedCode(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isHotpatchable(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isCVTCIL(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isMSILNetmodule(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isCTypes(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isStripped(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn frontEndQFE(&self) -> ::windows::core::Result<u32>;
    fn backEndQFE(&self) -> ::windows::core::Result<u32>;
    fn wasInlined(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn strictGSCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isCxxReturnUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isConstructorVirtualBase(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn RValueReference(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn unmodifiedType(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn framePointerPresent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isSafeBuffers(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn intrinsic(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn sealed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hfaFloat(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hfaDouble(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn liveRangeStartAddressSection(&self) -> ::windows::core::Result<u32>;
    fn liveRangeStartAddressOffset(&self) -> ::windows::core::Result<u32>;
    fn liveRangeStartRelativeVirtualAddress(&self) -> ::windows::core::Result<u32>;
    fn countLiveRanges(&self) -> ::windows::core::Result<u32>;
    fn liveRangeLength(&self) -> ::windows::core::Result<u64>;
    fn offsetInUdt(&self) -> ::windows::core::Result<u32>;
    fn paramBasePointerRegisterId(&self) -> ::windows::core::Result<u32>;
    fn localBasePointerRegisterId(&self) -> ::windows::core::Result<u32>;
    fn isLocationControlFlowDependent(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn stride(&self) -> ::windows::core::Result<u32>;
    fn numberOfRows(&self) -> ::windows::core::Result<u32>;
    fn numberOfColumns(&self) -> ::windows::core::Result<u32>;
    fn isMatrixRowMajor(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn get_numericProperties(&self, cnt: u32, pcnt: *mut u32, pproperties: *mut u32) -> ::windows::core::Result<()>;
    fn get_modifierValues(&self, cnt: u32, pcnt: *mut u32, pmodifiers: *mut u16) -> ::windows::core::Result<()>;
    fn isReturnValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isOptimizedAway(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn builtInKind(&self) -> ::windows::core::Result<u32>;
    fn registerType(&self) -> ::windows::core::Result<u32>;
    fn baseDataSlot(&self) -> ::windows::core::Result<u32>;
    fn baseDataOffset(&self) -> ::windows::core::Result<u32>;
    fn textureSlot(&self) -> ::windows::core::Result<u32>;
    fn samplerSlot(&self) -> ::windows::core::Result<u32>;
    fn uavSlot(&self) -> ::windows::core::Result<u32>;
    fn sizeInUdt(&self) -> ::windows::core::Result<u32>;
    fn memorySpaceKind(&self) -> ::windows::core::Result<u32>;
    fn unmodifiedTypeId(&self) -> ::windows::core::Result<u32>;
    fn subTypeId(&self) -> ::windows::core::Result<u32>;
    fn subType(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn numberOfModifiers(&self) -> ::windows::core::Result<u32>;
    fn numberOfRegisterIndices(&self) -> ::windows::core::Result<u32>;
    fn isHLSLData(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isPointerToDataMember(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isPointerToMemberFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isSingleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isMultipleInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isVirtualInheritance(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn restrictedType(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isPointerBasedOnSymbolValue(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn baseSymbol(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn baseSymbolId(&self) -> ::windows::core::Result<u32>;
    fn objectFileName(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn isAcceleratorGroupSharedLocal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isAcceleratorPointerTagLiveRange(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isAcceleratorStubFunction(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn numberOfAcceleratorPointerTags(&self) -> ::windows::core::Result<u32>;
    fn isSdl(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isWinRTPointer(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isRefUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isValueUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isInterfaceUdt(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn findInlineFramesByAddr(&self, isect: u32, offset: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findInlineFramesByRVA(&self, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findInlineFramesByVA(&self, va: u64) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findInlineeLines(&self) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInlineeLinesByAddr(&self, isect: u32, offset: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInlineeLinesByRVA(&self, rva: u32, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findInlineeLinesByVA(&self, va: u64, length: u32) -> ::windows::core::Result<IDiaEnumLineNumbers>;
    fn findSymbolsForAcceleratorPointerTag(&self, tagvalue: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn findSymbolsByRVAForAcceleratorPointerTag(&self, tagvalue: u32, rva: u32) -> ::windows::core::Result<IDiaEnumSymbols>;
    fn get_acceleratorPointerTags(&self, cnt: u32, pcnt: *mut u32, ppointertags: *mut u32) -> ::windows::core::Result<()>;
    fn getSrcLineOnTypeDefn(&self) -> ::windows::core::Result<IDiaLineNumber>;
    fn isPGO(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn hasValidPGOCounts(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isOptimizedForSpeed(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn PGOEntryCount(&self) -> ::windows::core::Result<u32>;
    fn PGOEdgeCount(&self) -> ::windows::core::Result<u32>;
    fn PGODynamicInstructionCount(&self) -> ::windows::core::Result<u64>;
    fn staticSize(&self) -> ::windows::core::Result<u32>;
    fn finalLiveStaticSize(&self) -> ::windows::core::Result<u32>;
    fn phaseName(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn hasControlFlowCheck(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn constantExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn dataExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn privateExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn noNameExport(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn exportHasExplicitlyAssignedOrdinal(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn exportIsForwarder(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn ordinal(&self) -> ::windows::core::Result<u32>;
    fn frameSize(&self) -> ::windows::core::Result<u32>;
    fn exceptionHandlerAddressSection(&self) -> ::windows::core::Result<u32>;
    fn exceptionHandlerAddressOffset(&self) -> ::windows::core::Result<u32>;
    fn exceptionHandlerRelativeVirtualAddress(&self) -> ::windows::core::Result<u32>;
    fn exceptionHandlerVirtualAddress(&self) -> ::windows::core::Result<u64>;
    fn findInputAssemblyFile(&self) -> ::windows::core::Result<IDiaInputAssemblyFile>;
    fn characteristics(&self) -> ::windows::core::Result<u32>;
    fn coffGroup(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn bindID(&self) -> ::windows::core::Result<u32>;
    fn bindSpace(&self) -> ::windows::core::Result<u32>;
    fn bindSlot(&self) -> ::windows::core::Result<u32>;
}
impl ::windows::core::RuntimeName for IDiaSymbol {}
impl IDiaSymbol_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>() -> IDiaSymbol_Vtbl {
        unsafe extern "system" fn symIndexId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symIndexId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn symTag<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symTag() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn name<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.name() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lexicalParent<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lexicalParent() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn classParent<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.classParent() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn r#type<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.r#type() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn dataKind<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.dataKind() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn locationType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.locationType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressSection<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressSection() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn relativeVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.relativeVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn registerId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.registerId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn offset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.offset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn length<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.length() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn slot<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.slot() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn volatileType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.volatileType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn constType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.constType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn unalignedType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.unalignedType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn access<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.access() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn libraryName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.libraryName() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn platform<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.platform() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn language<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.language() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn editAndContinueEnabled<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.editAndContinueEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn frontEndMajor<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.frontEndMajor() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn frontEndMinor<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.frontEndMinor() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn frontEndBuild<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.frontEndBuild() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn backEndMajor<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.backEndMajor() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn backEndMinor<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.backEndMinor() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn backEndBuild<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.backEndBuild() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn sourceFileName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.sourceFileName() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn unused<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.unused() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn thunkOrdinal<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.thunkOrdinal() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn thisAdjust<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.thisAdjust() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualBaseOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualBaseOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn r#virtual<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.r#virtual() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn intro<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.intro() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn pure<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.pure() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn callingConvention<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.callingConvention() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn value<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::Win32::System::Com::VARIANT>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.value() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn baseType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.baseType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn token<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.token() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn timeStamp<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.timeStamp() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn guid<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.guid() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn symbolsFileName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.symbolsFileName() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn reference<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.reference() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn bitPosition<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.bitPosition() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn arrayIndexType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.arrayIndexType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn packed<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.packed() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn constructor<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.constructor() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn overloadedOperator<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.overloadedOperator() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn nested<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.nested() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasNestedTypes<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasNestedTypes() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasAssignmentOperator<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasAssignmentOperator() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasCastOperator<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasCastOperator() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn scoped<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.scoped() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualBaseClass<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualBaseClass() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn indirectVirtualBaseClass<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.indirectVirtualBaseClass() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualBasePointerOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualBasePointerOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualTableShape<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualTableShape() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lexicalParentId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lexicalParentId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn classParentId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.classParentId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn typeId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.typeId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn arrayIndexTypeId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.arrayIndexTypeId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualTableShapeId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualTableShapeId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn code<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.code() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn function<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.function() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn managed<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.managed() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn msil<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.msil() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualBaseDispIndex<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualBaseDispIndex() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn undecoratedName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.undecoratedName() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn age<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.age() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn signature<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.signature() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn compilerGenerated<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.compilerGenerated() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn addressTaken<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.addressTaken() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn rank<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.rank() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lowerBound<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lowerBound() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn upperBound<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.upperBound() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn lowerBoundId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.lowerBoundId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn upperBoundId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.upperBoundId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn get_dataBytes<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbdata: u32, pcbdata: *mut u32, pbdata: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_dataBytes(::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&pbdata)).into()
        }
        unsafe extern "system" fn findChildren<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildren(::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findChildrenEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildrenEx(::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findChildrenExByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, isect: u32, offset: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildrenExByAddr(::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags), ::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findChildrenExByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, va: u64, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildrenExByVA(::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags), ::core::mem::transmute_copy(&va)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findChildrenExByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symtag: SymTag, name: ::windows::core::PCWSTR, compareflags: u32, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findChildrenExByRVA(::core::mem::transmute_copy(&symtag), ::core::mem::transmute(&name), ::core::mem::transmute_copy(&compareflags), ::core::mem::transmute_copy(&rva)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn targetSection<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.targetSection() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn targetOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.targetOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn targetRelativeVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.targetRelativeVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn targetVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.targetVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn machineType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.machineType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn oemId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.oemId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn oemSymbolId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.oemSymbolId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn get_types<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ctypes: u32, pctypes: *mut u32, ptypes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_types(::core::mem::transmute_copy(&ctypes), ::core::mem::transmute_copy(&pctypes), ::core::mem::transmute_copy(&ptypes)).into()
        }
        unsafe extern "system" fn get_typeIds<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ctypeids: u32, pctypeids: *mut u32, pdwtypeids: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_typeIds(::core::mem::transmute_copy(&ctypeids), ::core::mem::transmute_copy(&pctypeids), ::core::mem::transmute_copy(&pdwtypeids)).into()
        }
        unsafe extern "system" fn objectPointerType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.objectPointerType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn udtKind<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.udtKind() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn get_undecoratedNameEx<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, undecorateoptions: u32, name: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.get_undecoratedNameEx(::core::mem::transmute_copy(&undecorateoptions)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(name, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn noReturn<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.noReturn() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn customCallingConvention<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.customCallingConvention() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn noInline<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.noInline() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn optimizedCodeDebugInfo<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.optimizedCodeDebugInfo() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn notReached<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.notReached() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn interruptReturn<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.interruptReturn() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn farReturn<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.farReturn() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isStatic<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isStatic() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasDebugInfo<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasDebugInfo() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isLTCG<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isLTCG() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isDataAligned<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isDataAligned() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasSecurityChecks<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasSecurityChecks() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn compilerName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.compilerName() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasAlloca<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasAlloca() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasSetJump<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasSetJump() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasLongJump<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasLongJump() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasInlAsm<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasInlAsm() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasEH<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasEH() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasSEH<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasSEH() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasEHa<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasEHa() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isNaked<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isNaked() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isAggregated<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isAggregated() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isSplitted<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isSplitted() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn container<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.container() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn inlSpec<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.inlSpec() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn noStackOrdering<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.noStackOrdering() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn virtualBaseTableType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.virtualBaseTableType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasManagedCode<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasManagedCode() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isHotpatchable<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isHotpatchable() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isCVTCIL<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isCVTCIL() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isMSILNetmodule<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isMSILNetmodule() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isCTypes<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isCTypes() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isStripped<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isStripped() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn frontEndQFE<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.frontEndQFE() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn backEndQFE<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.backEndQFE() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn wasInlined<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.wasInlined() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn strictGSCheck<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.strictGSCheck() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isCxxReturnUdt<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isCxxReturnUdt() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isConstructorVirtualBase<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isConstructorVirtualBase() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RValueReference<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.RValueReference() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn unmodifiedType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.unmodifiedType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn framePointerPresent<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.framePointerPresent() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isSafeBuffers<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isSafeBuffers() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn intrinsic<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.intrinsic() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn sealed<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.sealed() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hfaFloat<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hfaFloat() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hfaDouble<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hfaDouble() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn liveRangeStartAddressSection<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.liveRangeStartAddressSection() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn liveRangeStartAddressOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.liveRangeStartAddressOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn liveRangeStartRelativeVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.liveRangeStartRelativeVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn countLiveRanges<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.countLiveRanges() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn liveRangeLength<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.liveRangeLength() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn offsetInUdt<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.offsetInUdt() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn paramBasePointerRegisterId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.paramBasePointerRegisterId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn localBasePointerRegisterId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.localBasePointerRegisterId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isLocationControlFlowDependent<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isLocationControlFlowDependent() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn stride<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.stride() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn numberOfRows<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.numberOfRows() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn numberOfColumns<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.numberOfColumns() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isMatrixRowMajor<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isMatrixRowMajor() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn get_numericProperties<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cnt: u32, pcnt: *mut u32, pproperties: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_numericProperties(::core::mem::transmute_copy(&cnt), ::core::mem::transmute_copy(&pcnt), ::core::mem::transmute_copy(&pproperties)).into()
        }
        unsafe extern "system" fn get_modifierValues<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cnt: u32, pcnt: *mut u32, pmodifiers: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_modifierValues(::core::mem::transmute_copy(&cnt), ::core::mem::transmute_copy(&pcnt), ::core::mem::transmute_copy(&pmodifiers)).into()
        }
        unsafe extern "system" fn isReturnValue<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isReturnValue() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isOptimizedAway<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isOptimizedAway() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn builtInKind<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.builtInKind() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn registerType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.registerType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn baseDataSlot<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.baseDataSlot() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn baseDataOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.baseDataOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn textureSlot<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.textureSlot() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn samplerSlot<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.samplerSlot() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn uavSlot<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.uavSlot() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn sizeInUdt<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.sizeInUdt() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn memorySpaceKind<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.memorySpaceKind() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn unmodifiedTypeId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.unmodifiedTypeId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn subTypeId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.subTypeId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn subType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.subType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn numberOfModifiers<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.numberOfModifiers() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn numberOfRegisterIndices<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.numberOfRegisterIndices() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isHLSLData<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isHLSLData() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isPointerToDataMember<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isPointerToDataMember() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isPointerToMemberFunction<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isPointerToMemberFunction() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isSingleInheritance<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isSingleInheritance() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isMultipleInheritance<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isMultipleInheritance() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isVirtualInheritance<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isVirtualInheritance() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn restrictedType<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.restrictedType() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isPointerBasedOnSymbolValue<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isPointerBasedOnSymbolValue() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn baseSymbol<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.baseSymbol() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn baseSymbolId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.baseSymbolId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn objectFileName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.objectFileName() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isAcceleratorGroupSharedLocal<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isAcceleratorGroupSharedLocal() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isAcceleratorPointerTagLiveRange<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isAcceleratorPointerTagLiveRange() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isAcceleratorStubFunction<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isAcceleratorStubFunction() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn numberOfAcceleratorPointerTags<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.numberOfAcceleratorPointerTags() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isSdl<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isSdl() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isWinRTPointer<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isWinRTPointer() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isRefUdt<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isRefUdt() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isValueUdt<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isValueUdt() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isInterfaceUdt<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isInterfaceUdt() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineFramesByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineFramesByAddr(::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineFramesByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineFramesByRVA(::core::mem::transmute_copy(&rva)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineFramesByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineFramesByVA(::core::mem::transmute_copy(&va)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineeLines<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineeLines() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineeLinesByAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, isect: u32, offset: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineeLinesByAddr(::core::mem::transmute_copy(&isect), ::core::mem::transmute_copy(&offset), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineeLinesByRVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rva: u32, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineeLinesByRVA(::core::mem::transmute_copy(&rva), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInlineeLinesByVA<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, va: u64, length: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInlineeLinesByVA(::core::mem::transmute_copy(&va), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findSymbolsForAcceleratorPointerTag<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tagvalue: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findSymbolsForAcceleratorPointerTag(::core::mem::transmute_copy(&tagvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findSymbolsByRVAForAcceleratorPointerTag<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tagvalue: u32, rva: u32, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findSymbolsByRVAForAcceleratorPointerTag(::core::mem::transmute_copy(&tagvalue), ::core::mem::transmute_copy(&rva)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn get_acceleratorPointerTags<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cnt: u32, pcnt: *mut u32, ppointertags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_acceleratorPointerTags(::core::mem::transmute_copy(&cnt), ::core::mem::transmute_copy(&pcnt), ::core::mem::transmute_copy(&ppointertags)).into()
        }
        unsafe extern "system" fn getSrcLineOnTypeDefn<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.getSrcLineOnTypeDefn() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isPGO<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isPGO() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasValidPGOCounts<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasValidPGOCounts() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isOptimizedForSpeed<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isOptimizedForSpeed() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PGOEntryCount<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.PGOEntryCount() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PGOEdgeCount<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.PGOEdgeCount() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PGODynamicInstructionCount<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.PGODynamicInstructionCount() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn staticSize<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.staticSize() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn finalLiveStaticSize<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.finalLiveStaticSize() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn phaseName<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.phaseName() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn hasControlFlowCheck<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasControlFlowCheck() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn constantExport<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.constantExport() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn dataExport<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.dataExport() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn privateExport<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.privateExport() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn noNameExport<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.noNameExport() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn exportHasExplicitlyAssignedOrdinal<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.exportHasExplicitlyAssignedOrdinal() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn exportIsForwarder<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.exportIsForwarder() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ordinal<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.ordinal() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn frameSize<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.frameSize() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn exceptionHandlerAddressSection<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.exceptionHandlerAddressSection() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn exceptionHandlerAddressOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.exceptionHandlerAddressOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn exceptionHandlerRelativeVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.exceptionHandlerRelativeVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn exceptionHandlerVirtualAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.exceptionHandlerVirtualAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn findInputAssemblyFile<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresult: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.findInputAssemblyFile() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppresult, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn characteristics<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.characteristics() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn coffGroup<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.coffGroup() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn bindID<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.bindID() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn bindSpace<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.bindSpace() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn bindSlot<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.bindSlot() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            symIndexId: symIndexId::<Identity, Impl, OFFSET>,
            symTag: symTag::<Identity, Impl, OFFSET>,
            name: name::<Identity, Impl, OFFSET>,
            lexicalParent: lexicalParent::<Identity, Impl, OFFSET>,
            classParent: classParent::<Identity, Impl, OFFSET>,
            r#type: r#type::<Identity, Impl, OFFSET>,
            dataKind: dataKind::<Identity, Impl, OFFSET>,
            locationType: locationType::<Identity, Impl, OFFSET>,
            addressSection: addressSection::<Identity, Impl, OFFSET>,
            addressOffset: addressOffset::<Identity, Impl, OFFSET>,
            relativeVirtualAddress: relativeVirtualAddress::<Identity, Impl, OFFSET>,
            virtualAddress: virtualAddress::<Identity, Impl, OFFSET>,
            registerId: registerId::<Identity, Impl, OFFSET>,
            offset: offset::<Identity, Impl, OFFSET>,
            length: length::<Identity, Impl, OFFSET>,
            slot: slot::<Identity, Impl, OFFSET>,
            volatileType: volatileType::<Identity, Impl, OFFSET>,
            constType: constType::<Identity, Impl, OFFSET>,
            unalignedType: unalignedType::<Identity, Impl, OFFSET>,
            access: access::<Identity, Impl, OFFSET>,
            libraryName: libraryName::<Identity, Impl, OFFSET>,
            platform: platform::<Identity, Impl, OFFSET>,
            language: language::<Identity, Impl, OFFSET>,
            editAndContinueEnabled: editAndContinueEnabled::<Identity, Impl, OFFSET>,
            frontEndMajor: frontEndMajor::<Identity, Impl, OFFSET>,
            frontEndMinor: frontEndMinor::<Identity, Impl, OFFSET>,
            frontEndBuild: frontEndBuild::<Identity, Impl, OFFSET>,
            backEndMajor: backEndMajor::<Identity, Impl, OFFSET>,
            backEndMinor: backEndMinor::<Identity, Impl, OFFSET>,
            backEndBuild: backEndBuild::<Identity, Impl, OFFSET>,
            sourceFileName: sourceFileName::<Identity, Impl, OFFSET>,
            unused: unused::<Identity, Impl, OFFSET>,
            thunkOrdinal: thunkOrdinal::<Identity, Impl, OFFSET>,
            thisAdjust: thisAdjust::<Identity, Impl, OFFSET>,
            virtualBaseOffset: virtualBaseOffset::<Identity, Impl, OFFSET>,
            r#virtual: r#virtual::<Identity, Impl, OFFSET>,
            intro: intro::<Identity, Impl, OFFSET>,
            pure: pure::<Identity, Impl, OFFSET>,
            callingConvention: callingConvention::<Identity, Impl, OFFSET>,
            value: value::<Identity, Impl, OFFSET>,
            baseType: baseType::<Identity, Impl, OFFSET>,
            token: token::<Identity, Impl, OFFSET>,
            timeStamp: timeStamp::<Identity, Impl, OFFSET>,
            guid: guid::<Identity, Impl, OFFSET>,
            symbolsFileName: symbolsFileName::<Identity, Impl, OFFSET>,
            reference: reference::<Identity, Impl, OFFSET>,
            count: count::<Identity, Impl, OFFSET>,
            bitPosition: bitPosition::<Identity, Impl, OFFSET>,
            arrayIndexType: arrayIndexType::<Identity, Impl, OFFSET>,
            packed: packed::<Identity, Impl, OFFSET>,
            constructor: constructor::<Identity, Impl, OFFSET>,
            overloadedOperator: overloadedOperator::<Identity, Impl, OFFSET>,
            nested: nested::<Identity, Impl, OFFSET>,
            hasNestedTypes: hasNestedTypes::<Identity, Impl, OFFSET>,
            hasAssignmentOperator: hasAssignmentOperator::<Identity, Impl, OFFSET>,
            hasCastOperator: hasCastOperator::<Identity, Impl, OFFSET>,
            scoped: scoped::<Identity, Impl, OFFSET>,
            virtualBaseClass: virtualBaseClass::<Identity, Impl, OFFSET>,
            indirectVirtualBaseClass: indirectVirtualBaseClass::<Identity, Impl, OFFSET>,
            virtualBasePointerOffset: virtualBasePointerOffset::<Identity, Impl, OFFSET>,
            virtualTableShape: virtualTableShape::<Identity, Impl, OFFSET>,
            lexicalParentId: lexicalParentId::<Identity, Impl, OFFSET>,
            classParentId: classParentId::<Identity, Impl, OFFSET>,
            typeId: typeId::<Identity, Impl, OFFSET>,
            arrayIndexTypeId: arrayIndexTypeId::<Identity, Impl, OFFSET>,
            virtualTableShapeId: virtualTableShapeId::<Identity, Impl, OFFSET>,
            code: code::<Identity, Impl, OFFSET>,
            function: function::<Identity, Impl, OFFSET>,
            managed: managed::<Identity, Impl, OFFSET>,
            msil: msil::<Identity, Impl, OFFSET>,
            virtualBaseDispIndex: virtualBaseDispIndex::<Identity, Impl, OFFSET>,
            undecoratedName: undecoratedName::<Identity, Impl, OFFSET>,
            age: age::<Identity, Impl, OFFSET>,
            signature: signature::<Identity, Impl, OFFSET>,
            compilerGenerated: compilerGenerated::<Identity, Impl, OFFSET>,
            addressTaken: addressTaken::<Identity, Impl, OFFSET>,
            rank: rank::<Identity, Impl, OFFSET>,
            lowerBound: lowerBound::<Identity, Impl, OFFSET>,
            upperBound: upperBound::<Identity, Impl, OFFSET>,
            lowerBoundId: lowerBoundId::<Identity, Impl, OFFSET>,
            upperBoundId: upperBoundId::<Identity, Impl, OFFSET>,
            get_dataBytes: get_dataBytes::<Identity, Impl, OFFSET>,
            findChildren: findChildren::<Identity, Impl, OFFSET>,
            findChildrenEx: findChildrenEx::<Identity, Impl, OFFSET>,
            findChildrenExByAddr: findChildrenExByAddr::<Identity, Impl, OFFSET>,
            findChildrenExByVA: findChildrenExByVA::<Identity, Impl, OFFSET>,
            findChildrenExByRVA: findChildrenExByRVA::<Identity, Impl, OFFSET>,
            targetSection: targetSection::<Identity, Impl, OFFSET>,
            targetOffset: targetOffset::<Identity, Impl, OFFSET>,
            targetRelativeVirtualAddress: targetRelativeVirtualAddress::<Identity, Impl, OFFSET>,
            targetVirtualAddress: targetVirtualAddress::<Identity, Impl, OFFSET>,
            machineType: machineType::<Identity, Impl, OFFSET>,
            oemId: oemId::<Identity, Impl, OFFSET>,
            oemSymbolId: oemSymbolId::<Identity, Impl, OFFSET>,
            get_types: get_types::<Identity, Impl, OFFSET>,
            get_typeIds: get_typeIds::<Identity, Impl, OFFSET>,
            objectPointerType: objectPointerType::<Identity, Impl, OFFSET>,
            udtKind: udtKind::<Identity, Impl, OFFSET>,
            get_undecoratedNameEx: get_undecoratedNameEx::<Identity, Impl, OFFSET>,
            noReturn: noReturn::<Identity, Impl, OFFSET>,
            customCallingConvention: customCallingConvention::<Identity, Impl, OFFSET>,
            noInline: noInline::<Identity, Impl, OFFSET>,
            optimizedCodeDebugInfo: optimizedCodeDebugInfo::<Identity, Impl, OFFSET>,
            notReached: notReached::<Identity, Impl, OFFSET>,
            interruptReturn: interruptReturn::<Identity, Impl, OFFSET>,
            farReturn: farReturn::<Identity, Impl, OFFSET>,
            isStatic: isStatic::<Identity, Impl, OFFSET>,
            hasDebugInfo: hasDebugInfo::<Identity, Impl, OFFSET>,
            isLTCG: isLTCG::<Identity, Impl, OFFSET>,
            isDataAligned: isDataAligned::<Identity, Impl, OFFSET>,
            hasSecurityChecks: hasSecurityChecks::<Identity, Impl, OFFSET>,
            compilerName: compilerName::<Identity, Impl, OFFSET>,
            hasAlloca: hasAlloca::<Identity, Impl, OFFSET>,
            hasSetJump: hasSetJump::<Identity, Impl, OFFSET>,
            hasLongJump: hasLongJump::<Identity, Impl, OFFSET>,
            hasInlAsm: hasInlAsm::<Identity, Impl, OFFSET>,
            hasEH: hasEH::<Identity, Impl, OFFSET>,
            hasSEH: hasSEH::<Identity, Impl, OFFSET>,
            hasEHa: hasEHa::<Identity, Impl, OFFSET>,
            isNaked: isNaked::<Identity, Impl, OFFSET>,
            isAggregated: isAggregated::<Identity, Impl, OFFSET>,
            isSplitted: isSplitted::<Identity, Impl, OFFSET>,
            container: container::<Identity, Impl, OFFSET>,
            inlSpec: inlSpec::<Identity, Impl, OFFSET>,
            noStackOrdering: noStackOrdering::<Identity, Impl, OFFSET>,
            virtualBaseTableType: virtualBaseTableType::<Identity, Impl, OFFSET>,
            hasManagedCode: hasManagedCode::<Identity, Impl, OFFSET>,
            isHotpatchable: isHotpatchable::<Identity, Impl, OFFSET>,
            isCVTCIL: isCVTCIL::<Identity, Impl, OFFSET>,
            isMSILNetmodule: isMSILNetmodule::<Identity, Impl, OFFSET>,
            isCTypes: isCTypes::<Identity, Impl, OFFSET>,
            isStripped: isStripped::<Identity, Impl, OFFSET>,
            frontEndQFE: frontEndQFE::<Identity, Impl, OFFSET>,
            backEndQFE: backEndQFE::<Identity, Impl, OFFSET>,
            wasInlined: wasInlined::<Identity, Impl, OFFSET>,
            strictGSCheck: strictGSCheck::<Identity, Impl, OFFSET>,
            isCxxReturnUdt: isCxxReturnUdt::<Identity, Impl, OFFSET>,
            isConstructorVirtualBase: isConstructorVirtualBase::<Identity, Impl, OFFSET>,
            RValueReference: RValueReference::<Identity, Impl, OFFSET>,
            unmodifiedType: unmodifiedType::<Identity, Impl, OFFSET>,
            framePointerPresent: framePointerPresent::<Identity, Impl, OFFSET>,
            isSafeBuffers: isSafeBuffers::<Identity, Impl, OFFSET>,
            intrinsic: intrinsic::<Identity, Impl, OFFSET>,
            sealed: sealed::<Identity, Impl, OFFSET>,
            hfaFloat: hfaFloat::<Identity, Impl, OFFSET>,
            hfaDouble: hfaDouble::<Identity, Impl, OFFSET>,
            liveRangeStartAddressSection: liveRangeStartAddressSection::<Identity, Impl, OFFSET>,
            liveRangeStartAddressOffset: liveRangeStartAddressOffset::<Identity, Impl, OFFSET>,
            liveRangeStartRelativeVirtualAddress: liveRangeStartRelativeVirtualAddress::<Identity, Impl, OFFSET>,
            countLiveRanges: countLiveRanges::<Identity, Impl, OFFSET>,
            liveRangeLength: liveRangeLength::<Identity, Impl, OFFSET>,
            offsetInUdt: offsetInUdt::<Identity, Impl, OFFSET>,
            paramBasePointerRegisterId: paramBasePointerRegisterId::<Identity, Impl, OFFSET>,
            localBasePointerRegisterId: localBasePointerRegisterId::<Identity, Impl, OFFSET>,
            isLocationControlFlowDependent: isLocationControlFlowDependent::<Identity, Impl, OFFSET>,
            stride: stride::<Identity, Impl, OFFSET>,
            numberOfRows: numberOfRows::<Identity, Impl, OFFSET>,
            numberOfColumns: numberOfColumns::<Identity, Impl, OFFSET>,
            isMatrixRowMajor: isMatrixRowMajor::<Identity, Impl, OFFSET>,
            get_numericProperties: get_numericProperties::<Identity, Impl, OFFSET>,
            get_modifierValues: get_modifierValues::<Identity, Impl, OFFSET>,
            isReturnValue: isReturnValue::<Identity, Impl, OFFSET>,
            isOptimizedAway: isOptimizedAway::<Identity, Impl, OFFSET>,
            builtInKind: builtInKind::<Identity, Impl, OFFSET>,
            registerType: registerType::<Identity, Impl, OFFSET>,
            baseDataSlot: baseDataSlot::<Identity, Impl, OFFSET>,
            baseDataOffset: baseDataOffset::<Identity, Impl, OFFSET>,
            textureSlot: textureSlot::<Identity, Impl, OFFSET>,
            samplerSlot: samplerSlot::<Identity, Impl, OFFSET>,
            uavSlot: uavSlot::<Identity, Impl, OFFSET>,
            sizeInUdt: sizeInUdt::<Identity, Impl, OFFSET>,
            memorySpaceKind: memorySpaceKind::<Identity, Impl, OFFSET>,
            unmodifiedTypeId: unmodifiedTypeId::<Identity, Impl, OFFSET>,
            subTypeId: subTypeId::<Identity, Impl, OFFSET>,
            subType: subType::<Identity, Impl, OFFSET>,
            numberOfModifiers: numberOfModifiers::<Identity, Impl, OFFSET>,
            numberOfRegisterIndices: numberOfRegisterIndices::<Identity, Impl, OFFSET>,
            isHLSLData: isHLSLData::<Identity, Impl, OFFSET>,
            isPointerToDataMember: isPointerToDataMember::<Identity, Impl, OFFSET>,
            isPointerToMemberFunction: isPointerToMemberFunction::<Identity, Impl, OFFSET>,
            isSingleInheritance: isSingleInheritance::<Identity, Impl, OFFSET>,
            isMultipleInheritance: isMultipleInheritance::<Identity, Impl, OFFSET>,
            isVirtualInheritance: isVirtualInheritance::<Identity, Impl, OFFSET>,
            restrictedType: restrictedType::<Identity, Impl, OFFSET>,
            isPointerBasedOnSymbolValue: isPointerBasedOnSymbolValue::<Identity, Impl, OFFSET>,
            baseSymbol: baseSymbol::<Identity, Impl, OFFSET>,
            baseSymbolId: baseSymbolId::<Identity, Impl, OFFSET>,
            objectFileName: objectFileName::<Identity, Impl, OFFSET>,
            isAcceleratorGroupSharedLocal: isAcceleratorGroupSharedLocal::<Identity, Impl, OFFSET>,
            isAcceleratorPointerTagLiveRange: isAcceleratorPointerTagLiveRange::<Identity, Impl, OFFSET>,
            isAcceleratorStubFunction: isAcceleratorStubFunction::<Identity, Impl, OFFSET>,
            numberOfAcceleratorPointerTags: numberOfAcceleratorPointerTags::<Identity, Impl, OFFSET>,
            isSdl: isSdl::<Identity, Impl, OFFSET>,
            isWinRTPointer: isWinRTPointer::<Identity, Impl, OFFSET>,
            isRefUdt: isRefUdt::<Identity, Impl, OFFSET>,
            isValueUdt: isValueUdt::<Identity, Impl, OFFSET>,
            isInterfaceUdt: isInterfaceUdt::<Identity, Impl, OFFSET>,
            findInlineFramesByAddr: findInlineFramesByAddr::<Identity, Impl, OFFSET>,
            findInlineFramesByRVA: findInlineFramesByRVA::<Identity, Impl, OFFSET>,
            findInlineFramesByVA: findInlineFramesByVA::<Identity, Impl, OFFSET>,
            findInlineeLines: findInlineeLines::<Identity, Impl, OFFSET>,
            findInlineeLinesByAddr: findInlineeLinesByAddr::<Identity, Impl, OFFSET>,
            findInlineeLinesByRVA: findInlineeLinesByRVA::<Identity, Impl, OFFSET>,
            findInlineeLinesByVA: findInlineeLinesByVA::<Identity, Impl, OFFSET>,
            findSymbolsForAcceleratorPointerTag: findSymbolsForAcceleratorPointerTag::<Identity, Impl, OFFSET>,
            findSymbolsByRVAForAcceleratorPointerTag: findSymbolsByRVAForAcceleratorPointerTag::<Identity, Impl, OFFSET>,
            get_acceleratorPointerTags: get_acceleratorPointerTags::<Identity, Impl, OFFSET>,
            getSrcLineOnTypeDefn: getSrcLineOnTypeDefn::<Identity, Impl, OFFSET>,
            isPGO: isPGO::<Identity, Impl, OFFSET>,
            hasValidPGOCounts: hasValidPGOCounts::<Identity, Impl, OFFSET>,
            isOptimizedForSpeed: isOptimizedForSpeed::<Identity, Impl, OFFSET>,
            PGOEntryCount: PGOEntryCount::<Identity, Impl, OFFSET>,
            PGOEdgeCount: PGOEdgeCount::<Identity, Impl, OFFSET>,
            PGODynamicInstructionCount: PGODynamicInstructionCount::<Identity, Impl, OFFSET>,
            staticSize: staticSize::<Identity, Impl, OFFSET>,
            finalLiveStaticSize: finalLiveStaticSize::<Identity, Impl, OFFSET>,
            phaseName: phaseName::<Identity, Impl, OFFSET>,
            hasControlFlowCheck: hasControlFlowCheck::<Identity, Impl, OFFSET>,
            constantExport: constantExport::<Identity, Impl, OFFSET>,
            dataExport: dataExport::<Identity, Impl, OFFSET>,
            privateExport: privateExport::<Identity, Impl, OFFSET>,
            noNameExport: noNameExport::<Identity, Impl, OFFSET>,
            exportHasExplicitlyAssignedOrdinal: exportHasExplicitlyAssignedOrdinal::<Identity, Impl, OFFSET>,
            exportIsForwarder: exportIsForwarder::<Identity, Impl, OFFSET>,
            ordinal: ordinal::<Identity, Impl, OFFSET>,
            frameSize: frameSize::<Identity, Impl, OFFSET>,
            exceptionHandlerAddressSection: exceptionHandlerAddressSection::<Identity, Impl, OFFSET>,
            exceptionHandlerAddressOffset: exceptionHandlerAddressOffset::<Identity, Impl, OFFSET>,
            exceptionHandlerRelativeVirtualAddress: exceptionHandlerRelativeVirtualAddress::<Identity, Impl, OFFSET>,
            exceptionHandlerVirtualAddress: exceptionHandlerVirtualAddress::<Identity, Impl, OFFSET>,
            findInputAssemblyFile: findInputAssemblyFile::<Identity, Impl, OFFSET>,
            characteristics: characteristics::<Identity, Impl, OFFSET>,
            coffGroup: coffGroup::<Identity, Impl, OFFSET>,
            bindID: bindID::<Identity, Impl, OFFSET>,
            bindSpace: bindSpace::<Identity, Impl, OFFSET>,
            bindSlot: bindSlot::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol10_Impl: Sized + IDiaSymbol9_Impl {
    fn get_sourceLink(&self, cb: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IDiaSymbol10 {}
impl IDiaSymbol10_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol10_Impl, const OFFSET: isize>() -> IDiaSymbol10_Vtbl {
        unsafe extern "system" fn get_sourceLink<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol10_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cb: u32, pcb: *mut u32, pb: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.get_sourceLink(::core::mem::transmute_copy(&cb), ::core::mem::transmute_copy(&pcb), ::core::mem::transmute_copy(&pb)).into()
        }
        Self {
            base__: IDiaSymbol9_Vtbl::new::<Identity, Impl, OFFSET>(),
            get_sourceLink: get_sourceLink::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol10 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol2 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol3 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol4 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol5 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol6 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol7 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol8 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol9 as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol2_Impl: Sized + IDiaSymbol_Impl {
    fn isObjCClass(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isObjCCategory(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
    fn isObjCProtocol(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
}
impl ::windows::core::RuntimeName for IDiaSymbol2 {}
impl IDiaSymbol2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol2_Impl, const OFFSET: isize>() -> IDiaSymbol2_Vtbl {
        unsafe extern "system" fn isObjCClass<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isObjCClass() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isObjCCategory<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isObjCCategory() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isObjCProtocol<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isObjCProtocol() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: IDiaSymbol_Vtbl::new::<Identity, Impl, OFFSET>(),
            isObjCClass: isObjCClass::<Identity, Impl, OFFSET>,
            isObjCCategory: isObjCCategory::<Identity, Impl, OFFSET>,
            isObjCProtocol: isObjCProtocol::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol2 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol3_Impl: Sized + IDiaSymbol2_Impl {
    fn inlinee(&self) -> ::windows::core::Result<IDiaSymbol>;
    fn inlineeId(&self) -> ::windows::core::Result<u32>;
}
impl ::windows::core::RuntimeName for IDiaSymbol3 {}
impl IDiaSymbol3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol3_Impl, const OFFSET: isize>() -> IDiaSymbol3_Vtbl {
        unsafe extern "system" fn inlinee<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.inlinee() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn inlineeId<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.inlineeId() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: IDiaSymbol2_Vtbl::new::<Identity, Impl, OFFSET>(),
            inlinee: inlinee::<Identity, Impl, OFFSET>,
            inlineeId: inlineeId::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol3 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol as ::windows::core::Interface>::IID || iid == &<IDiaSymbol2 as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol4_Impl: Sized + IDiaSymbol3_Impl {
    fn noexcept(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
}
impl ::windows::core::RuntimeName for IDiaSymbol4 {}
impl IDiaSymbol4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol4_Impl, const OFFSET: isize>() -> IDiaSymbol4_Vtbl {
        unsafe extern "system" fn noexcept<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.noexcept() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: IDiaSymbol3_Vtbl::new::<Identity, Impl, OFFSET>(),
            noexcept: noexcept::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol4 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol as ::windows::core::Interface>::IID || iid == &<IDiaSymbol2 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol3 as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol5_Impl: Sized + IDiaSymbol4_Impl {
    fn hasAbsoluteAddress(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
}
impl ::windows::core::RuntimeName for IDiaSymbol5 {}
impl IDiaSymbol5_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol5_Impl, const OFFSET: isize>() -> IDiaSymbol5_Vtbl {
        unsafe extern "system" fn hasAbsoluteAddress<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol5_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.hasAbsoluteAddress() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: IDiaSymbol4_Vtbl::new::<Identity, Impl, OFFSET>(),
            hasAbsoluteAddress: hasAbsoluteAddress::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol5 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol as ::windows::core::Interface>::IID || iid == &<IDiaSymbol2 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol3 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol4 as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol6_Impl: Sized + IDiaSymbol5_Impl {
    fn isStaticMemberFunc(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
}
impl ::windows::core::RuntimeName for IDiaSymbol6 {}
impl IDiaSymbol6_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol6_Impl, const OFFSET: isize>() -> IDiaSymbol6_Vtbl {
        unsafe extern "system" fn isStaticMemberFunc<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol6_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isStaticMemberFunc() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: IDiaSymbol5_Vtbl::new::<Identity, Impl, OFFSET>(),
            isStaticMemberFunc: isStaticMemberFunc::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol6 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol as ::windows::core::Interface>::IID || iid == &<IDiaSymbol2 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol3 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol4 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol5 as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol7_Impl: Sized + IDiaSymbol6_Impl {
    fn isSignRet(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
}
impl ::windows::core::RuntimeName for IDiaSymbol7 {}
impl IDiaSymbol7_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol7_Impl, const OFFSET: isize>() -> IDiaSymbol7_Vtbl {
        unsafe extern "system" fn isSignRet<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol7_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isSignRet() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: IDiaSymbol6_Vtbl::new::<Identity, Impl, OFFSET>(),
            isSignRet: isSignRet::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol7 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol as ::windows::core::Interface>::IID || iid == &<IDiaSymbol2 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol3 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol4 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol5 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol6 as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol8_Impl: Sized + IDiaSymbol7_Impl {
    fn coroutineKind(&self) -> ::windows::core::Result<u32>;
    fn associatedSymbolKind(&self) -> ::windows::core::Result<u32>;
    fn associatedSymbolSection(&self) -> ::windows::core::Result<u32>;
    fn associatedSymbolOffset(&self) -> ::windows::core::Result<u32>;
    fn associatedSymbolRva(&self) -> ::windows::core::Result<u32>;
    fn associatedSymbolAddr(&self) -> ::windows::core::Result<u64>;
}
impl ::windows::core::RuntimeName for IDiaSymbol8 {}
impl IDiaSymbol8_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol8_Impl, const OFFSET: isize>() -> IDiaSymbol8_Vtbl {
        unsafe extern "system" fn coroutineKind<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.coroutineKind() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn associatedSymbolKind<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.associatedSymbolKind() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn associatedSymbolSection<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.associatedSymbolSection() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn associatedSymbolOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.associatedSymbolOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn associatedSymbolRva<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.associatedSymbolRva() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn associatedSymbolAddr<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol8_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.associatedSymbolAddr() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: IDiaSymbol7_Vtbl::new::<Identity, Impl, OFFSET>(),
            coroutineKind: coroutineKind::<Identity, Impl, OFFSET>,
            associatedSymbolKind: associatedSymbolKind::<Identity, Impl, OFFSET>,
            associatedSymbolSection: associatedSymbolSection::<Identity, Impl, OFFSET>,
            associatedSymbolOffset: associatedSymbolOffset::<Identity, Impl, OFFSET>,
            associatedSymbolRva: associatedSymbolRva::<Identity, Impl, OFFSET>,
            associatedSymbolAddr: associatedSymbolAddr::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol8 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol as ::windows::core::Interface>::IID || iid == &<IDiaSymbol2 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol3 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol4 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol5 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol6 as ::windows::core::Interface>::IID || iid == &<IDiaSymbol7 as ::windows::core::Interface>::IID
    }
}
pub trait IDiaSymbol9_Impl: Sized + IDiaSymbol8_Impl {
    fn framePadSize(&self) -> ::windows::core::Result<u32>;
    fn framePadOffset(&self) -> ::windows::core::Result<u32>;
    fn isRTCs(&self) -> ::windows::core::Result<::windows::Win32::Foundation::BOOL>;
}
impl ::windows::core::RuntimeName for IDiaSymbol9 {}
impl IDiaSymbol9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol9_Impl, const OFFSET: isize>() -> IDiaSymbol9_Vtbl {
        unsafe extern "system" fn framePadSize<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.framePadSize() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn framePadOffset<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.framePadOffset() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn isRTCs<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaSymbol9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::windows::Win32::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.isRTCs() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: IDiaSymbol8_Vtbl::new::<Identity, Impl, OFFSET>(),
            framePadSize: framePadSize::<Identity, Impl, OFFSET>,
            framePadOffset: framePadOffset::<Identity, Impl, OFFSET>,
            isRTCs: isRTCs::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaSymbol9 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol2 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol3 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol4 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol5 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol6 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol7 as ::windows::core::Interface>::IID
            || iid == &<IDiaSymbol8 as ::windows::core::Interface>::IID
    }
}
pub trait IDiaTable_Impl: Sized + ::windows::Win32::System::Com::IEnumUnknown_Impl {
    fn Skip2(&self, celt: u32) -> ::windows::core::Result<()>;
    fn Reset2(&self) -> ::windows::core::Result<()>;
    fn Clone2(&self) -> ::windows::core::Result<::windows::Win32::System::Com::IEnumUnknown>;
    fn _NewEnum(&self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn name(&self) -> ::windows::core::Result<::windows::core::BSTR>;
    fn Count(&self) -> ::windows::core::Result<i32>;
    fn Item(&self, index: u32) -> ::windows::core::Result<::windows::core::IUnknown>;
}
impl ::windows::core::RuntimeName for IDiaTable {}
impl IDiaTable_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaTable_Impl, const OFFSET: isize>() -> IDiaTable_Vtbl {
        unsafe extern "system" fn Skip2<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaTable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, celt: u32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Skip2(::core::mem::transmute_copy(&celt)).into()
        }
        unsafe extern "system" fn Reset2<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaTable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset2().into()
        }
        unsafe extern "system" fn Clone2<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaTable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppenum: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Clone2() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppenum, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn _NewEnum<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaTable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this._NewEnum() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn name<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaTable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut ::core::mem::ManuallyDrop<::windows::core::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.name() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Count<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaTable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pretval: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Count() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pretval, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Identity: ::windows::core::IUnknownImpl<Impl = Impl>, Impl: IDiaTable_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, element: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.Item(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(element, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::Win32::System::Com::IEnumUnknown_Vtbl::new::<Identity, Impl, OFFSET>(),
            Skip2: Skip2::<Identity, Impl, OFFSET>,
            Reset2: Reset2::<Identity, Impl, OFFSET>,
            Clone2: Clone2::<Identity, Impl, OFFSET>,
            _NewEnum: _NewEnum::<Identity, Impl, OFFSET>,
            name: name::<Identity, Impl, OFFSET>,
            Count: Count::<Identity, Impl, OFFSET>,
            Item: Item::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDiaTable as ::windows::core::Interface>::IID || iid == &<::windows::Win32::System::Com::IEnumUnknown as ::windows::core::Interface>::IID
    }
}
